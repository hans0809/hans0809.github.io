<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>跨考小白学刷题(上) | 南极Python</title><meta name="keywords" content="Python|机器学习|深度学习|生活感悟"><meta name="author" content="雨落诗山山亦奇"><meta name="copyright" content="雨落诗山山亦奇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章1-1 对一组数据进行排序时，要考虑这组数据有什么样的特征。  包含大量重复元素-&gt;三路快排 近乎有序-&gt;插入排序 取值范围有限-&gt;计数排序 要求稳定排序-&gt;归并排序 使用链表存储-&gt; 归并排序 数据量很大-&gt;外部排序 1-4 当没有思路时  尝试简单测试用例 暴力法 第二章2-1O(f(n))表示算法执行的上界  最后一项，nlog(n)是数组全部元素比">
<meta property="og:type" content="article">
<meta property="og:title" content="跨考小白学刷题(上)">
<meta property="og:url" content="http://yoursite.com/2021/11/12/%E8%B7%A8%E8%80%83%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%88%B7%E9%A2%98(%E4%B8%8A)/index.html">
<meta property="og:site_name" content="南极Python">
<meta property="og:description" content="第一章1-1 对一组数据进行排序时，要考虑这组数据有什么样的特征。  包含大量重复元素-&gt;三路快排 近乎有序-&gt;插入排序 取值范围有限-&gt;计数排序 要求稳定排序-&gt;归并排序 使用链表存储-&gt; 归并排序 数据量很大-&gt;外部排序 1-4 当没有思路时  尝试简单测试用例 暴力法 第二章2-1O(f(n))表示算法执行的上界  最后一项，nlog(n)是数组全部元素比">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.cdnjson.com/images/2021/11/21/1_VJNqt2qR5keOZ_ukx8fmwA.jpg">
<meta property="article:published_time" content="2021-11-12T05:54:19.000Z">
<meta property="article:modified_time" content="2021-11-30T12:34:13.719Z">
<meta property="article:author" content="雨落诗山山亦奇">
<meta property="article:tag" content="Python|机器学习|深度学习|生活感悟">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.cdnjson.com/images/2021/11/21/1_VJNqt2qR5keOZ_ukx8fmwA.jpg"><link rel="shortcut icon" href="https://www.cdnjson.com/images/2021/11/27/_20210211193948.png"><link rel="canonical" href="http://yoursite.com/2021/11/12/%E8%B7%A8%E8%80%83%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%88%B7%E9%A2%98(%E4%B8%8A)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '跨考小白学刷题(上)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-30 20:34:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macblack.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://www.cdnjson.com/images/2021/11/27/_20210211193948.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">136</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.cdnjson.com/images/2021/11/21/1_VJNqt2qR5keOZ_ukx8fmwA.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">南极Python</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">跨考小白学刷题(上)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-12T05:54:19.000Z" title="发表于 2021-11-12 13:54:19">2021-11-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-30T12:34:13.719Z" title="更新于 2021-11-30 20:34:13">2021-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%B7%A8%E8%80%83%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%88%B7%E9%A2%98/">跨考小白学刷题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">35.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>155分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="跨考小白学刷题(上)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1-1"></a>1-1</h2><blockquote>
<p>对一组数据进行排序时，要考虑这组数据有什么样的特征。</p>
</blockquote>
<p>包含大量重复元素-&gt;三路快排</p>
<p>近乎有序-&gt;插入排序</p>
<p>取值范围有限-&gt;计数排序</p>
<p>要求稳定排序-&gt;归并排序</p>
<p>使用链表存储-&gt; 归并排序</p>
<p>数据量很大-&gt;外部排序</p>
<h2 id="1-4"><a href="#1-4" class="headerlink" title="1-4"></a>1-4</h2><blockquote>
<p>当没有思路时</p>
</blockquote>
<p>尝试简单测试用例</p>
<p>暴力法</p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2-1"></a>2-1</h2><p>O(f(n))表示算法执行的上界</p>
<p><img src="./1.png" alt="Alt text"></p>
<p>最后一项，nlog(n)是数组全部元素比较的次数，s指的是确定两个字符串的字典序需要O(s).</p>
<p>因此，最终的时间复杂度是：O(nslog(s)+snlog(n))</p>
<h2 id="2-2"><a href="#2-2" class="headerlink" title="2-2"></a>2-2</h2><p><img src="./2.png" alt="Alt text"></p>
<p>第一个，只需要ret和i</p>
<p>第二个，递归深度为n</p>
<h2 id="2-3"><a href="#2-3" class="headerlink" title="2-3"></a>2-3</h2><p><img src="./3.png" alt="Alt text"></p>
<p><img src="./4.png" alt="Alt text"></p>
<p><img src="./5.png" alt="Alt text"></p>
<p><img src="./6.png" alt="Alt text"></p>
<p><img src="./7.png" alt="Alt text"></p>
<p><img src="./8.png" alt="Alt text"></p>
<p><img src="./9.png" alt="Alt text"></p>
<p><img src="./10.png" alt="Alt text"><br>reverse函数的时间复杂度是O(m/2)=O(m)，其中m指的是s的长度，又由于s的长度和while中执行次数是一样的(每执行一次，s多一位)，因此也是s的长度也是logn，从而整体的时间复杂度是O(2logn)=O(logn).</p>
<p><img src="./11.png" alt="Alt text"></p>
<p>可见，log的底并不重要。</p>
<p><img src="./12.png" alt="Alt text"><br>第一重循环log(n)次，因此整体时间复杂度是O(nlogn).</p>
<p><img src="./13.png" alt="Alt text"></p>
<h2 id="2-4"><a href="#2-4" class="headerlink" title="2-4"></a>2-4</h2><p><img src="./14.png" alt="Alt text"></p>
<p><img src="./15.png" alt="Alt text"></p>
<p><img src="./16.png" alt="Alt text"></p>
<h2 id="2-6"><a href="#2-6" class="headerlink" title="2-6"></a>2-6</h2><p>动态数组</p>
<p>添加/删除一个元素的均摊复杂度是O(1)</p>
<p>添加元素<br><img src="./17.png" alt="Alt text"></p>
<p>但删除元素时可能出现复杂度震荡，此时位于数组长度的一半位置<br><img src="./18.png" alt="Alt text"></p>
<p>解决：<br><img src="./19.png" alt="Alt text"></p>
<h1 id="第三章-：从数组开始"><a href="#第三章-：从数组开始" class="headerlink" title="第三章 ：从数组开始"></a>第三章 ：从数组开始</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3-1"></a>3-1</h2><p>二分查找的代码<br><img src="./20.png" alt="Alt text"></p>
<h2 id="3-2"><a href="#3-2" class="headerlink" title="3-2"></a>3-2</h2><p>二分查找的另一种代码<br><img src="./21.png" alt="Alt text"></p>
<h2 id="3-3"><a href="#3-3" class="headerlink" title="3-3"></a>3-3</h2><p>问题：Move Zeros<br><img src="./22.png" alt="Alt text"></p>
<p>解法1：用一个新的数组按顺序存储nums中的非零元素，然后将这个数组中的元素覆盖在nums，nums后续位置全部置0：<br><img src="./23.png" alt="Alt text"></p>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h2 id="3-4"><a href="#3-4" class="headerlink" title="3-4"></a>3-4</h2><p>优化上一节的问题。</p>
<p>解法2：不使用额外数组，直接覆盖<br><img src="./24.png" alt="Alt text"><br>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<p>解法3：将覆盖改为交换<br><img src="./25.png" alt="Alt text"><br>时间复杂度：O(n)<br>空间复杂度：O(1)<br>解法4：当整个数组全部非零时，解法3需要自己和自己做交换，可以改进<br><img src="./26.png" alt="Alt text"><br>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<p>课后习题：<br><img src="./27.png" alt="Alt text"></p>
<p>不需要考虑数组中超出新长度后面的元素。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p><strong>解法1</strong>：两个指针一前一后向右走</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        i,j=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;<span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[j]!=val:</span><br><span class="line">                nums[i]=nums[j]</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中 n 为序列的长度。我们只需要遍历该序列至多两次。</p>
<p>空间复杂度：O(1)。我们只需要常数的空间保存若干变量。</p>
<p><strong>解法2</strong>：两个指针一个向右走，一个向左走</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        i,j=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=j:</span><br><span class="line">            <span class="keyword">if</span> nums[i]==val:</span><br><span class="line">                nums[i]=nums[j]</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中 n 为序列的长度。我们只需要遍历该序列至多一次。</p>
<p>空间复杂度：O(1)。我们只需要常数的空间保存若干变量。</p>
<p><strong>我的解法</strong>：基于解法2，加入了判断j位置元素是否为val(内部while)，保证只做一次赋值操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        i,j=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=j:<span class="comment">#j后面全是为val的</span></span><br><span class="line">            <span class="keyword">if</span> nums[i]==val:<span class="comment">#该处理了</span></span><br><span class="line">                <span class="keyword">if</span> nums[j]!=val:</span><br><span class="line">                    nums[i]=nums[j]</span><br><span class="line">                    j-=<span class="number">1</span></span><br><span class="line">                    i+=<span class="number">1</span><span class="comment">#不加也能过，但是加了可以少判断一次</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> i&lt;=j <span class="keyword">and</span> nums[j]==val:</span><br><span class="line">                        j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n方？)，其中 n 为序列的长度。我们只需要遍历该序列至多一次。</p>
<p>空间复杂度：O(1)。我们只需要常数的空间保存若干变量。</p>
<p><img src="./28.png" alt="Alt text"><br>不需要考虑数组中超出新长度后面的元素。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>注意<strong>有序</strong>这个条件！</p>
<p><strong>我的解法：</strong>使用双指针，慢指针i以及慢指针i之前的元素都是不重复的，快指针j用于判断当前遍历到的元素是否重复（使用last指向当前慢指针维护的最右边的一个元素）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="comment">#不加这个判断也能AC</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        i=<span class="number">0</span><span class="comment">#i以及i之前的元素都不重复</span></span><br><span class="line">        j=<span class="number">1</span><span class="comment">#j遍历</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;n:</span><br><span class="line">            last=nums[i]</span><br><span class="line">            <span class="keyword">if</span> nums[j]!=nums[i]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j&lt;n <span class="keyword">and</span> nums[j]!=last:</span><br><span class="line">                    nums[i+<span class="number">1</span>]=nums[j]</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>官方代码</strong>：快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。不需要考虑0，因为当数组的长度大于 0时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        fast = slow = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; n:</span><br><span class="line">            <span class="comment">#if nums[fast] != nums[slow - 1],这句和下面这句效果一样，但这样写能够和下一题官方题解统一起来，所以按照这句来理解比较好。因为slow维护当前处理好的序列，指向当前待处理元素的位置。</span></span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[fast - <span class="number">1</span>]:<span class="comment">#新的元素出现</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。</p>
<p>空间复杂度：O(1)。只需要使用常数的额外空间。</p>
<p><img src="./29.png" alt="Alt text"><br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>因为空间复杂度要求O(1)，所以不能哈希了。</p>
<p><strong>官方解法</strong></p>
<p>和上一题差不多，但没有Python的，我根据其它语言改写的Python版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        i,j=<span class="number">2</span>,<span class="number">2</span><span class="comment">#i指向下一个待补充的位置，j遍历</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> j&lt;n:</span><br><span class="line">            <span class="keyword">if</span> nums[j]!=nums[i-<span class="number">2</span>]:<span class="comment">#必须是i-2！！！</span></span><br><span class="line">                nums[i]=nums[j]</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>

<p><strong>第三方题解通用解法</strong>：拓展到了最多保留重复的k个数。</p>
<p>由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留</p>
<p>对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">k</span>):</span></span><br><span class="line">            u = <span class="number">0</span><span class="comment">#u指向当前待处理元素位置</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> u &lt; k <span class="keyword">or</span> nums[u - k] != x:</span><br><span class="line">                    nums[u] = x</span><br><span class="line">                    u += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> u</span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>以上两题思路是一样的：<strong>把所有不重复元素进行保留 可以通过双指针来实现 (该思维框架可以总结成模板运用到很多类似题)：即定义两个指针left和right，right从左到右把所有元素扫一遍，将不重复k次的元素赋给left的下一位</strong>。</p>
<h2 id="3-5"><a href="#3-5" class="headerlink" title="3-5"></a>3-5</h2><p><img src="./30.png" alt="Alt text"></p>
<p>计数排序：<br><img src="./31.png" alt="Alt text"></p>
<p>3路快排：<br><img src="./32.png" alt="Alt text"></p>
<p><img src="./33.png" alt="Alt text"></p>
<p>课后习题：<br><img src="./34.png" alt="Alt text"><br>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n</p>
<p>可以直接合并然后暴力排序，也可以开辟一个新数组，但是这样空间复杂度都是O(m+n).</p>
<p>数组有序！可以用双指针，此时空间复杂度为O(1)</p>
<p>如果直接合并到数组 nums1中，nums1中的元素可能会在取出之前被覆盖。那么如何直接避免覆盖 nums1中的元素呢？观察可知，nums1的后半部分是空的，可以直接覆盖而不会影响结果。因此可以指针设置为从后向前遍历，每次取两者之中的较大者放进 nums1的最后面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i,j=m-<span class="number">1</span>,n-<span class="number">1</span><span class="comment">#遍历</span></span><br><span class="line">        tail=m+n-<span class="number">1</span><span class="comment">#tail后面是处理完的有序序列，不包括tail</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="comment">#nums1处理完了</span></span><br><span class="line">            <span class="keyword">if</span> i==-<span class="number">1</span>:</span><br><span class="line">                nums1[tail]=nums2[j]</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#nums2处理完了</span></span><br><span class="line">            <span class="keyword">elif</span> j==-<span class="number">1</span>:</span><br><span class="line">                nums1[tail]=nums1[i]</span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                nums1[tail]=nums1[i]</span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[tail]=nums2[j]</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            tail-=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="./35.png" alt="Alt text"></p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p><strong>方法1</strong>：基于快速排序，改为快速选择。</p>
<p><img src="./36.png" alt="Alt text"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self,nums,left,right</span>):</span></span><br><span class="line">        pivot=right</span><br><span class="line">        key=nums[pivot]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left]&lt;=key:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right]&gt;=key:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="comment">#到这里，nums[left]&gt;pivot，nums[right]&lt;pivot，所以接下来就需要交换一下这两者</span></span><br><span class="line">            nums[left],nums[right]=nums[right],nums[left]</span><br><span class="line">        nums[left],nums[pivot]=key,nums[left]<span class="comment">#必须是交换才可以！！！！</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#普通快排，这里用不到 ，只是回顾一下</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">self,nums, left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right:</span><br><span class="line">            index = self.partition(nums, left, right)</span><br><span class="line">            self.quicksort(nums, left, index-<span class="number">1</span>)</span><br><span class="line">            self.quicksort(nums, index+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#改编自quicksort</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topk_split</span>(<span class="params">self,nums, k, left, right</span>):</span></span><br><span class="line">        <span class="comment">#寻找到第k个数停止递归，使得nums数组中index左边是前k个小的数，index右边是后面n-k个大的数</span></span><br><span class="line">        <span class="keyword">if</span> (left&lt;right):</span><br><span class="line">            index = self.partition(nums, left, right)</span><br><span class="line">            <span class="built_in">print</span>(index)</span><br><span class="line">            <span class="keyword">if</span> index==k:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;找到&#x27;</span>,index)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">elif</span> index &lt; k:</span><br><span class="line">                self.topk_split(nums, k, index+<span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.topk_split(nums, k, left, index-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#self.quicksort(nums,left,right)</span></span><br><span class="line">        self.topk_split(nums,<span class="built_in">len</span>(nums)-k,left,right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)-k]</span><br></pre></td></tr></table></figure>

<p>如果pivot取值为left，则需要调换一下两个while的顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self,nums,left,right</span>):</span></span><br><span class="line">    pivot=left</span><br><span class="line">    key=nums[pivot]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right]&gt;=key:</span><br><span class="line">            right-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left]&lt;=key:</span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#到这里，nums[left]&gt;key，nums[right]&lt;key，所以接下来就需要交换一下这两者</span></span><br><span class="line">        nums[left],nums[right]=nums[right],nums[left]</span><br><span class="line">    nums[left],nums[pivot]=key,nums[left]<span class="comment">#必须是交换才可以！！！！</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<p><strong>方法2：</strong>堆排序</p>
<p>调包：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        maxHeap = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            heapq.heappush(maxHeap, -x)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>):</span><br><span class="line">            heapq.heappop(maxHeap)</span><br><span class="line">        <span class="keyword">return</span> -maxHeap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<p>手写堆：</p>
<p>先复习一下堆：</p>
<p><img src="./37.png" alt="Alt text"></p>
<p>堆是完全二叉树</p>
<p><img src="./38.png" alt="Alt text"><br><img src="./39.png" alt="Alt text"></p>
<p>原地堆排序代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#原地堆排序</span></span><br><span class="line"><span class="comment">#最后一个非叶子节点的索引是(n-1)/2,(n-2)/2 ？都可以吧，前者多了一次不通过的判断</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span>(<span class="params">arr,n</span>):</span></span><br><span class="line">    <span class="comment">#建堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((n-<span class="number">2</span>)//<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        shiftdown(arr,n,i)</span><br><span class="line">    <span class="built_in">print</span>(arr)<span class="comment">#[999, 9, 10, 8, 5, 1, 1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#原地堆排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        arr[<span class="number">0</span>],arr[i]=arr[i],arr[<span class="number">0</span>]</span><br><span class="line">        shiftdown(arr,i,<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(arr)<span class="comment">#[1, 1, 2, 5, 8, 9, 10, 999]</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shiftdown</span>(<span class="params">arr,n,k</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(k)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">2</span>*k+<span class="number">1</span>&lt;n:</span><br><span class="line">        j=<span class="number">2</span>*k+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;n <span class="keyword">and</span> arr[j+<span class="number">1</span>]&gt;arr[j]:</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> arr[k]&gt;=arr[j]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        arr[k],arr[j]=arr[j],arr[k]</span><br><span class="line">        k=j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试栗子</span></span><br><span class="line">arr=[<span class="number">4</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">999</span>,<span class="number">8</span>]</span><br><span class="line">n=<span class="number">9</span></span><br><span class="line">heapSort(arr,n)</span><br><span class="line"><span class="built_in">print</span>(arr)<span class="comment">#[1, 1, 2, 5, 8, 9, 999,3]</span></span><br></pre></td></tr></table></figure>


<p>先构建堆:  从最后一个非叶子节点开始，从下往上、从右到左依次进行比较</p>
<p>那么，如何确定最后一个非叶子节点的下标？</p>
<p>假设给定的序列长度为n，则最后一个孩子节点的下标为n-1，设其父节点下标为p，分两种情况讨论：</p>
<p>最终节点为左孩子节点，则有n-1=2*p+1，即p=(n-2)/2</p>
<p>最终节点为右孩子节点，则有n-1=2*p+2，即p=(n-3)/2 </p>
<p>根据地板除向下取整的特性，我们选择p=(n-2)//2就都能满足这两种情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment">#原地堆排序</span></span><br><span class="line">    <span class="comment">#最后一个非叶子节点的索引是(n-1)/2,(n-2)/2 ？都可以吧，前者多了一次不通过的判断</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapSort</span>(<span class="params">self,arr,n</span>):</span></span><br><span class="line">        <span class="comment">#建堆，后续叶子节点已经是满足堆的定义了</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((n-<span class="number">2</span>)//<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            self.shiftdown(arr,n,i)</span><br><span class="line">        <span class="comment">#print(arr)#[999, 10, 9, 8, 2, 5, 1, 1, 4]</span></span><br><span class="line">        <span class="comment">#原地堆排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            arr[<span class="number">0</span>],arr[i]=arr[i],arr[<span class="number">0</span>]</span><br><span class="line">            self.shiftdown(arr,i,<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#print(arr)#[1, 1, 2, 4, 5, 8, 9, 10, 999]</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment">#建堆</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((n-<span class="number">2</span>)//<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            self.shiftdown(nums,n,i)</span><br><span class="line">        <span class="comment">#求解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,n-k,-<span class="number">1</span>):</span><br><span class="line">            nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">            self.shiftdown(nums,i,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]<span class="comment">#经过k-1次操作，此时堆顶就是第k大的数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shiftdown</span>(<span class="params">self,arr,n,k</span>):</span></span><br><span class="line">        <span class="comment">#print(k)</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">2</span>*k+<span class="number">1</span>&lt;n:</span><br><span class="line">            j=<span class="number">2</span>*k+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span>&lt;n <span class="keyword">and</span> arr[j+<span class="number">1</span>]&gt;arr[j]:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> arr[k]&gt;=arr[j]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            arr[k],arr[j]=arr[j],arr[k]</span><br><span class="line">            k=j</span><br></pre></td></tr></table></figure>

<h2 id="3-6"><a href="#3-6" class="headerlink" title="3-6"></a>3-6</h2><p><img src="./40.png" alt="Alt text"><br>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length.</p>
<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>
<p><img src="./41.png" alt="Alt text"></p>
<p><strong>二分</strong>的时间复杂度是O(nlogn)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(numbers)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            low, high = i + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">                mid = (low + high) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> numbers[mid] == target - numbers[i]:</span><br><span class="line">                    <span class="keyword">return</span> [i + <span class="number">1</span>, mid + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> numbers[mid] &gt; target - numbers[i]:</span><br><span class="line">                    high = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    low = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>对撞指针法</strong>：<br><img src="./42.png" alt="Alt text"></p>
<p>时间复杂度：O(n)，其中 n 是数组的长度。两个指针移动的总次数最多为 n 次。</p>
<p>空间复杂度：O(1)。</p>
<p>课后习题：</p>
<p><img src="./43.png" alt="Alt text"><br>我的解法，和官方解法3相同，使用对撞指针，空间复杂度O(1)，时间复杂度O(字符串长度)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check_valid</span>(<span class="params">c</span>):</span></span><br><span class="line">            <span class="keyword">if</span> c.isdigit() <span class="keyword">or</span> c.isalpha():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        n=<span class="built_in">len</span>(s)</span><br><span class="line">        i,j=<span class="number">0</span>,n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> check_valid(s[i]) <span class="keyword">and</span> i&lt;j:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> check_valid(s[j]) <span class="keyword">and</span> i&lt;j:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            t1,t2=s[i],s[j]</span><br><span class="line">            <span class="keyword">if</span> t1.isalpha():</span><br><span class="line">                t1=t1.lower()</span><br><span class="line">            <span class="keyword">if</span> t2.isalpha():</span><br><span class="line">                t2=t2.lower()</span><br><span class="line">            <span class="keyword">if</span> i&lt;j <span class="keyword">and</span> t1!=t2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><img src="./44.png" alt="Alt text"><br>直接对撞。</p>
<p><img src="./45.png" alt="Alt text"><br>我的解法：对撞指针：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        n=<span class="built_in">len</span>(s)</span><br><span class="line">        lis=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span>]</span><br><span class="line">        slis=[i  <span class="keyword">for</span> i <span class="keyword">in</span> s]</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> lis:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> lis:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            slis[i],slis[j]=slis[j],slis[i]</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(slis)</span><br></pre></td></tr></table></figure>

<p><img src="./46.png" alt="Alt text"></p>
<p>还是对撞指针，理论证明略</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n=<span class="built_in">len</span>(height)</span><br><span class="line">        i,j=<span class="number">0</span>,n-<span class="number">1</span></span><br><span class="line">        maxArea=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            area=<span class="built_in">min</span>(height[i],height[j])*(j-i)</span><br><span class="line">            <span class="keyword">if</span> area&gt;maxArea:</span><br><span class="line">                maxArea=area</span><br><span class="line">            <span class="keyword">if</span> height[i]&lt;height[j]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br></pre></td></tr></table></figure>

<h2 id="3-7"><a href="#3-7" class="headerlink" title="3-7"></a>3-7</h2><p>双索引技术：<strong>滑动窗口</strong></p>
<p>滑动窗口算法可以用以解决数组/字符串的子元素问题，它可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。</p>
<p><img src="./47.png" alt="Alt text"></p>
<p><img src="./48.png" alt="Alt text"></p>
<p>暴力解法可以优化求和操作，使得时间复杂度变成O(n^2)，官方代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, s: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                total += nums[j]</span><br><span class="line">                <span class="keyword">if</span> total &gt;= s:</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, j - i + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>滑动窗口：</strong></p>
<p>注意到<strong>连续</strong>的条件</p>
<p><img src="./49.png" alt="Alt text"><br>我改写成了Python版本的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, s: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = n + <span class="number">1</span></span><br><span class="line">        i,j = <span class="number">0</span>, -<span class="number">1</span><span class="comment">#j从0开始会报错</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span>&lt;n <span class="keyword">and</span> <span class="built_in">sum</span>&lt;s:</span><br><span class="line">                <span class="built_in">sum</span>+=nums[j+<span class="number">1</span>]</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">sum</span>-=nums[i]</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>&gt;=s:</span><br><span class="line">                res=<span class="built_in">min</span>(res,j-i+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> res == n + <span class="number">1</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>



<p>官方提供的Python版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, s: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = n + <span class="number">1</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; n:</span><br><span class="line">            total += nums[end]</span><br><span class="line">            <span class="keyword">while</span> total &gt;= s:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, end - start + <span class="number">1</span>)</span><br><span class="line">                total -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="3-8"><a href="#3-8" class="headerlink" title="3-8"></a>3-8</h2><p>还是滑动窗口的栗子<br><img src="./50.png" alt="Alt text"></p>
<p><img src="./51.png" alt="Alt text"></p>
<p>对应的Python版本代码（改自上述C++代码以及官方代码）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        occ = <span class="built_in">set</span>()</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        i,rk, ans =<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            <span class="keyword">if</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                occ.add(s[rk + <span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s[i])</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>


<p>官方提供的代码（不顺）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        occ = <span class="built_in">set</span>()</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        rk, ans = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                occ.add(s[rk + <span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>课后习题：<br><img src="./52.png" alt="Alt text"></p>
<p>什么情况下会想到滑动窗口法：</p>
<p>任何题目如果没有思路其实都可以想一下暴力解法。这道题暴力解法思路简单：</p>
<pre><code>遍历任意i，j，使得i和j之间的子串长度，等于p串的长度。该子串称之为x。该步复杂度为O（n）。
判断x是否与p是异位词。是的话，则把i加入答案中。该步复杂度为O（n）。
</code></pre>
<p>暴力法的复杂度为O（n^2）。显然不高效。</p>
<p>评论区<strong>滑动窗口+空间换时间</strong>的答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n, m, res = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p), []</span><br><span class="line">        <span class="keyword">if</span> n &lt; m: <span class="keyword">return</span> res</span><br><span class="line">        p_cnt = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        s_cnt = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            p_cnt[<span class="built_in">ord</span>(p[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            s_cnt[<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s_cnt == p_cnt:</span><br><span class="line">            res.append(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, n):</span><br><span class="line">            s_cnt[<span class="built_in">ord</span>(s[i - m]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">            s_cnt[<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s_cnt == p_cnt:</span><br><span class="line">                res.append(i - m + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，for循环有O(n)，数组的长度是常数，所以数组的比较也是常数级别的，那最终的时间复杂度就是O(n)</p>
<p>空间复杂度：O(1)，需要常数级别的额外空间</p>
<p>评论区<strong>滑动窗口+双指针</strong>解法（还没看懂，不想看了）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n, m, res = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p), []</span><br><span class="line">        <span class="keyword">if</span> n &lt; m: <span class="keyword">return</span> res</span><br><span class="line">        p_cnt = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        s_cnt = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            p_cnt[<span class="built_in">ord</span>(p[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cur_right = <span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            s_cnt[cur_right] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> s_cnt[cur_right] &gt; p_cnt[cur_right]:</span><br><span class="line">                cur_left = <span class="built_in">ord</span>(s[left]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                s_cnt[cur_left] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right - left + <span class="number">1</span> == m:</span><br><span class="line">                res.append(left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><img src="./53.png" alt="Alt text"></p>
<h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><p>滑动窗口不怎么会，之后还得看。</p>
<h2 id="2021-11-25更新-滑动窗口模板-13道题"><a href="#2021-11-25更新-滑动窗口模板-13道题" class="headerlink" title="2021/11/25更新: 滑动窗口模板(13道题)"></a>2021/11/25更新: 滑动窗口模板(13道题)</h2><p>这里总结了滑动窗口的模板，共13道题：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x/</a></p>
<h3 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643. 子数组最大平均数 I"></a>643. 子数组最大平均数 I</h3><p>给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。</p>
<p>请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。</p>
<p>任何误差小于 10-5 的答案都将被视为正确答案。</p>
<p>示例 1：</p>
<p>输入：nums = [1,12,-5,-6,50,3], k = 4<br>输出：12.75<br>解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</p>
<p>示例 2：</p>
<p>输入：nums = [5], k = 1<br>输出：5.00000</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxAverage</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 本题求最大平均值 (其实就是求最大和)，所以需要定义sum_, 同时定义一个max_avg (初始值为负无穷)</span></span><br><span class="line">        sum_, max_avg = <span class="number">0</span>, -math.inf</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (sum_, max_avg), 不断把当前值积累到sum_上</span></span><br><span class="line">            sum_ += nums[end]</span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == k:</span><br><span class="line">                max_avg = <span class="built_in">max</span>(max_avg, sum_ / k)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口首指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (sum_)</span></span><br><span class="line">            <span class="comment">#step4中的if判断写成end+1&gt;=k也能过，因为start后续都要移动一次，但下面更好理解，end-start+1就是当前滑动窗口的长度</span></span><br><span class="line">            <span class="keyword">if</span> end -start+<span class="number">1</span>&gt;=k:</span><br><span class="line">                sum_ -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> max_avg</span><br></pre></td></tr></table></figure>

<p>注意，上述代码中，step4的if判断中的&gt;=不能写成&gt;，否则会造成遗漏：</p>
<p>当写成&gt;时，若当前滑动窗口长度恰好等于k，则进入step3的if块，更新一次max_avg，然后忽略step4的if，直接进入下次循环，end会右移一次，此时发现滑动窗口长度大于k了，于是进入step4的if块内，执行完里面的代码后，窗口长度又等于k了，进入下一次循环，end右移，此时又发现滑动窗口长度大于k了，于是进入step4的if块内，执行完里面的代码后，窗口长度又等于k了，进入下一次循环，end右移，此时又发现滑动窗口长度大于k了…</p>
<p>看吧，后面根本进不去step3中的if块了。</p>
<p>另外，上述代码有些故意套模板，可以改成更简洁的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxAverage</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 本题求最大平均值 (其实就是求最大和)，所以需要定义sum_, 同时定义一个max_avg (初始值为负无穷)</span></span><br><span class="line">        sum_, max_avg = <span class="number">0</span>, -math.inf</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (sum_, max_avg), 不断把当前值积累到sum_上</span></span><br><span class="line">            sum_ += nums[end]</span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == k:</span><br><span class="line">                max_avg = <span class="built_in">max</span>(max_avg, sum_ / k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                sum_ -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> max_avg</span><br></pre></td></tr></table></figure>

<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2:</p>
<p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3:</p>
<p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量, 本题求最大长度，所以需要定义max_len, 该题又涉及去重，因此还需要一个哈希表</span></span><br><span class="line">        max_len, hashmap = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (max_len, hashmap)</span></span><br><span class="line">            <span class="comment"># i.e. 把窗口末端元素加入哈希表，使其频率加1，并且更新最大长度</span></span><br><span class="line">            hashmap[s[end]] = hashmap.get(s[end], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hashmap) == end - start + <span class="number">1</span>:<span class="comment">#满足题目条件</span></span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Step 4: </span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 当窗口长度大于哈希表长度时候 (说明存在重复元素)，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">while</span> end - start + <span class="number">1</span> &gt; <span class="built_in">len</span>(hashmap):</span><br><span class="line">                head = s[start]</span><br><span class="line">                hashmap[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<p>len(hashmap)是当前不同元素的个数，end - start + 1是滑动窗口的长度。</p>
<p>当两者相等时，满足题目条件，更新一次最长字串的长度max_len，也就是step3。</p>
<p>当滑动窗口长度end - start + 1大于当前不同元素的个数len(hashmap)时，说明当前滑动窗口内有重复元素，此时需要滑动，也就是step4。</p>
<h3 id="159-至多包含两个不同字符的最长子串"><a href="#159-至多包含两个不同字符的最长子串" class="headerlink" title="159. 至多包含两个不同字符的最长子串"></a>159. 至多包含两个不同字符的最长子串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># Step 1: </span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量, 本题求最大长度，所以需要定义max_len,</span></span><br><span class="line">        <span class="comment"># 该题又涉及计算不重复元素个数，因此还需要一个哈希表</span></span><br><span class="line">        max_len, hashmap = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (max_len, hashmap)</span></span><br><span class="line">            <span class="comment"># 首先，把当前元素的计数加一</span></span><br><span class="line">            <span class="comment"># 一旦哈希表长度小于等于2(之多包含2个不同元素)，尝试更新最大长度</span></span><br><span class="line">            tail = s[end]</span><br><span class="line">            hashmap[tail] = hashmap.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hashmap) &lt;= <span class="number">2</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4: </span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 哈希表长度大于2的时候 (说明存在至少3个重复元素)，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(hashmap) &gt; <span class="number">2</span>:</span><br><span class="line">                head = s[start]</span><br><span class="line">                hashmap[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>示例 1：</p>
<p>输入：target = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<p>示例 2：</p>
<p>输入：target = 4, nums = [1,4,4]<br>输出：1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量, 本题求最小长度，所以需要定义min_len, 本题又涉及求和，因此还需要一个sum变量</span></span><br><span class="line">        min_len, sum_ = math.inf, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (min_len, sum_)</span></span><br><span class="line">            sum_ += nums[end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这一段可以删除，因为下面的while已经handle了这一块儿逻辑，不过写在这也没影响</span></span><br><span class="line">            <span class="keyword">if</span> sum_ &gt;= target:</span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 这一题这里稍微有一点特别: sum_ &gt;= target其实是合法的，但由于我们要求的是最小长度，</span></span><br><span class="line">            <span class="comment"># 所以当sum_已经大于target的时候继续移动右指针没有意义，因此还是需要移动左指针慢慢逼近答案</span></span><br><span class="line">            <span class="comment"># 由于左指针的移动可能影响min_len和sum_的值，因此需要在移动前将它们更新</span></span><br><span class="line">            <span class="keyword">while</span> sum_ &gt;= target:</span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, end - start + <span class="number">1</span>)</span><br><span class="line">                sum_ -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5：返回答案 (最小长度)</span></span><br><span class="line">        <span class="keyword">return</span> min_len <span class="keyword">if</span> min_len!=math.inf <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="1695-删除子数组的最大得分"><a href="#1695-删除子数组的最大得分" class="headerlink" title="1695. 删除子数组的最大得分"></a>1695. 删除子数组的最大得分</h3><p>给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和 。</p>
<p>返回 只删除一个 子数组可获得的 最大得分 。</p>
<p>如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],…,a[r] ，那么它就是 a 的一个子数组。</p>
<p>示例 1：</p>
<p>输入：nums = [4,2,4,5,6]<br>输出：17<br>解释：最优子数组是 [2,4,5,6]</p>
<p>示例 2：</p>
<p>输入：nums = [5,2,1,2,5,2,1,2,5]<br>输出：8<br>解释：最优子数组是 [5,2,1] 或 [1,2,5]</p>
<p>感觉就是找数组元素和最大的无重复连续子数组，有点结合前两道题的意思。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumUniqueSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量, 本题最大得分，所以需要定义当前得分sum_和最大得分max_sum</span></span><br><span class="line">        <span class="comment"># 本题又涉及去重 (题目规定子数组不能有重复)，因此还需要一个哈希表</span></span><br><span class="line">        sum_, max_sum, hashmap = <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (sum_, hashmap)</span></span><br><span class="line">            <span class="comment"># sum和hashmap需要更新就不说了，max_sum当且仅当哈希表里面没有重复元素时 (end - start + 1 == len(hashmap)) 更新</span></span><br><span class="line">            tail = nums[end]</span><br><span class="line">            sum_ += tail</span><br><span class="line">            hashmap[tail] = hashmap.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == <span class="built_in">len</span>(hashmap):<span class="comment">#此时说明无重复元素</span></span><br><span class="line">                max_sum = <span class="built_in">max</span>(max_sum, sum_)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 哈希表里面有重复元素时 (end - start + 1 &gt; len(hashmap)) 窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap， sum_)</span></span><br><span class="line">            <span class="keyword">while</span> end - start + <span class="number">1</span> &gt; <span class="built_in">len</span>(hashmap):</span><br><span class="line">                head = nums[start]</span><br><span class="line">                hashmap[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap[head]</span><br><span class="line">                sum_ -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>

<h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h3><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p>示例 1:</p>
<p>输入: s = “cbaebabacd”, p = “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p>
<p> 示例 2:</p>
<p>输入: s = “abab”, p = “ab”<br>输出: [0,1,2]<br>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># Step 1: </span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 本文需要对比两组字符串是否为异位词，所以用哈希表 (abc和bac是异位词是因为他们对应的哈希表相等)</span></span><br><span class="line">        <span class="comment"># 同时我们需要找到所有合法解，所以还需要一个res数组</span></span><br><span class="line">        res, hashmap = [], &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1.1： 同时把p的哈希表也建立了 (这个哈希表不需要维护，为定值)</span></span><br><span class="line">        hashmap_p = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> p:</span><br><span class="line">            hashmap_p[char] = hashmap_p.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (hashmap)， 如果hashmap == hashmap_p，代表找到了一个解，加入到res</span></span><br><span class="line">            hashmap[s[end]] = hashmap.get(s[end], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hashmap == hashmap_p:</span><br><span class="line">                res.append(start)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4 </span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定=len(p), 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">if</span> end-start+<span class="number">1</span> &gt;= <span class="built_in">len</span>(p) :</span><br><span class="line">                hashmap[s[start]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[s[start]] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap[s[start]]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这题的step4和643. 子数组最大平均数 I介绍的一样。</p>
<h3 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a>567. 字符串的排列</h3><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p>
<p>换句话说，s1 的排列之一是 s2 的 子串 。</p>
<p>示例 1：</p>
<p>输入：s1 = “ab” s2 = “eidbaooo”<br>输出：true<br>解释：s2 包含 s1 的排列之一 (“ba”).</p>
<p>示例 2：</p>
<p>输入：s1= “ab” s2 = “eidboaoo”<br>输出：false</p>
<p>也是维护一个滑动窗口，滑动窗口内的元素的哈希表如果等于s1的哈希表，就满足题目条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 因为和排列相关 (元素相同，顺序可以不同)，使用哈希表</span></span><br><span class="line">        hashmap2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1.1: 同时建立s1的哈希表 (这个哈希表不需要维护，为定值)</span></span><br><span class="line">        hashmap1 = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s1:</span><br><span class="line">            hashmap1[char] = hashmap1.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2)):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (hashmap2)， 如果hashmap1 == hashmap2，代表s2包含s1的排列，直接return</span></span><br><span class="line">            tail = s2[end]</span><br><span class="line">            hashmap2[tail] = hashmap2.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hashmap1 == hashmap2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4: </span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (hashmap2)</span></span><br><span class="line">            <span class="keyword">if</span> end -start+<span class="number">1</span>&gt;= <span class="built_in">len</span>(s1):</span><br><span class="line">                head = s2[start]</span><br><span class="line">                hashmap2[head] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap2[head] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap2[head]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5： 没有在s2中找到s1的排列，返回False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="487-最大连续1的个数-II"><a href="#487-最大连续1的个数-II" class="headerlink" title="487. 最大连续1的个数 II"></a>487. 最大连续1的个数 II</h3><p>给定一个二进制数组，你可以最多将 1 个 0 翻转为 1，找出其中最大连续 1 的个数。</p>
<p>示例 1：</p>
<p>输入：[1,0,1,1,0]<br>输出：4<br>解释：翻转第一个 0 可以得到最长的连续 1。<br>     当翻转以后，最大连续 1 的个数为 4。</p>
<p>维护一个滑动窗口，滑动窗口内最多只能有一个0.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 因为是求最大长度，所以有max_len，又同时涉及计数 (0的个数不能超过1个)，所以还要一个哈希表</span></span><br><span class="line">        max_len, hashmap = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量 (hashmap， max_len)</span></span><br><span class="line">            tail = nums[end]</span><br><span class="line">            hashmap[tail] = hashmap.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hashmap.get(<span class="number">0</span>, <span class="number">0</span>) &lt;= <span class="number">1</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 当hashmap里面0的个数大于1的时候，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)</span></span><br><span class="line">            <span class="keyword">while</span> hashmap.get(<span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">1</span>:</span><br><span class="line">                head = nums[start]</span><br><span class="line">                hashmap[head] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a>1004. 最大连续1的个数 III</h3><p>给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。</p>
<p>返回仅包含 1 的最长（连续）子数组的长度。</p>
<p>示例 1：</p>
<p>输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2<br>输出：6<br>解释：<br>[1,1,1,0,0,1,1,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 6。</p>
<p>示例 2：</p>
<p>输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3<br>输出：10<br>解释：<br>[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 10。</p>
<p>上面那题最多只能改动一个0变成1，这里最多可以改动K个0变成1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        max_len, hashmap = <span class="number">0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        start =  <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            tail = nums[end]</span><br><span class="line">            hashmap[tail] = hashmap.get(tail, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hashmap.get(<span class="number">0</span>, <span class="number">0</span>) &lt;= k:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 相比较于上一题，只需要把1改成k</span></span><br><span class="line">            <span class="keyword">while</span> hashmap.get(<span class="number">0</span>, <span class="number">0</span>) &gt; k:</span><br><span class="line">                head = nums[start]</span><br><span class="line">                hashmap[head] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h3 id="1208-尽可能使字符串相等"><a href="#1208-尽可能使字符串相等" class="headerlink" title="1208. 尽可能使字符串相等"></a>1208. 尽可能使字符串相等</h3><p>给你两个长度相同的字符串，s 和 t。</p>
<p>将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p>
<p>用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p>
<p>如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。</p>
<p>如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。</p>
<p>示例 1：</p>
<p>输入：s = “abcd”, t = “bcdf”, maxCost = 3<br>输出：3<br>解释：s 中的 “abc” 可以变为 “bcd”。开销为 3，所以最大长度为 3。</p>
<p>示例 2：</p>
<p>输入：s = “abcd”, t = “cdef”, maxCost = 3<br>输出：1<br>解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。</p>
<p>示例 3：</p>
<p>输入：s = “abcd”, t = “acde”, maxCost = 0<br>输出：1<br>解释：a -&gt; a, cost = 0，字符串未发生变化，所以最大长度为 1。</p>
<p>注意求的是满足要求的子字符串的最大长度，是连续的，因此考虑滑动窗口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equalSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span>, max_cost: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量</span></span><br><span class="line">        <span class="comment"># 因为是求最大长度，所以有max_len，又同时涉及计算开销 (和求和一个道理)， 所以还要一个cur_cost</span></span><br><span class="line">        cur_cost, max_len = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (cur_cost)</span></span><br><span class="line">            <span class="comment"># 每一对字符的order差值就是当前时间点的开销，直接累积在cur_cost上即可</span></span><br><span class="line">            <span class="comment"># cur_cost只要不超过最大开销，就更新max_len</span></span><br><span class="line">            cur_cost += <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[end]) - <span class="built_in">ord</span>(t[end]))</span><br><span class="line">            <span class="keyword">if</span> cur_cost &lt;= max_cost:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 当cur_cost大于最大开销时候，窗口不合法</span></span><br><span class="line">            <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法 (cur_cost &lt;= max_cost)</span></span><br><span class="line">            <span class="keyword">while</span> cur_cost &gt; max_cost:</span><br><span class="line">                cur_cost -= <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[start])-  <span class="built_in">ord</span>(t[start]))</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (最大长度)</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h3 id="1052-爱生气的书店老板"><a href="#1052-爱生气的书店老板" class="headerlink" title="1052. 爱生气的书店老板"></a>1052. 爱生气的书店老板</h3><p>今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p>
<p>在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p>
<p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。</p>
<p>请你返回这一天营业下来，最多有多少客户能够感到满意。</p>
<p>示例：</p>
<p>输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3<br>输出：16<br>解释：<br>书店老板在最后 3 分钟保持冷静。<br>感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.</p>
<p>维护一个大小为X（即代码中的minutes，代表老板发动技能持续的时间）的滑动窗口，找滑动窗口内对应的最多的customer数量，并且这里只针对老板发脾气(grumpy[i]=1)的时间进行统计，不发脾气(grumpy[i]=0)的时间本来就是顾客满意的，就不用管了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfied</span>(<span class="params">self, customers: <span class="type">List</span>[<span class="built_in">int</span>], grumpy: <span class="type">List</span>[<span class="built_in">int</span>], minutes: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量,</span></span><br><span class="line">        <span class="comment"># 因为涉及求和所以定义sum_和max_sum, 同时需要知道老板什么时候&#x27;发动技能&#x27;，再定义一个max_start</span></span><br><span class="line">        sum_, max_sum, max_start = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(customers)):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (sum_)</span></span><br><span class="line">            <span class="comment"># 注意：这里只有当老板在当前时间点会发脾气的时候才维护</span></span><br><span class="line">            <span class="comment"># sum_就不说了，和前面N道题的维护方法一样，新多出来的max_start也就是记录一样时间点而已，没什么fancy的</span></span><br><span class="line">            <span class="keyword">if</span> grumpy[end] == <span class="number">1</span>:</span><br><span class="line">                sum_ += customers[end]</span><br><span class="line">            <span class="keyword">if</span> sum_ &gt; max_sum:</span><br><span class="line">                max_sum = sum_</span><br><span class="line">                max_start = start</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定 (老板技能持续时间固定)，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (sum_, max_avg)</span></span><br><span class="line">            <span class="keyword">if</span> end -start+<span class="number">1</span>&gt;= minutes:</span><br><span class="line">                <span class="keyword">if</span> grumpy[start]==<span class="number">1</span>:<span class="comment">#只删除生气的，因为本来就只维护生气的</span></span><br><span class="line">                    sum_ -= customers[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里对比其他题目多了一小步: 在找到老板发动技能的最大收益时间点(max_start)后</span></span><br><span class="line">        <span class="comment"># 需要把受技能影响时间段中的grumpy全部置0 - 代表老板成功压制了自己的怒火</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_start, max_start + minutes):</span><br><span class="line">            grumpy[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 5: 再遍历一遍数组求customer总数量并且返回结果</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(customers)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> grumpy[i]:</span><br><span class="line">                res += customers[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423. 可获得的最大点数"></a>1423. 可获得的最大点数</h3><p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。</p>
<p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。</p>
<p>你的点数就是你拿到手中的所有卡牌的点数之和。</p>
<p>给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</p>
<p>示例 1：</p>
<p>输入：cardPoints = [1,2,3,4,5,6,1], k = 3<br>输出：12<br>解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。</p>
<p>示例 2：</p>
<p>输入：cardPoints = [2,2,2], k = 2<br>输出：4<br>解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</p>
<p>示例 3：</p>
<p>输入：cardPoints = [9,7,7,9,7,7,9], k = 7<br>输出：55<br>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</p>
<p>示例 4：</p>
<p>输入：cardPoints = [1,1000,1], k = 1<br>输出：1<br>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 </p>
<p>示例 5：</p>
<p>输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3<br>输出：202</p>
<p>题目要求首尾串最大点数，其实就是求非首尾串的连续序列的最小点数。</p>
<p>维护一个长度为len(cardPoints)-k的滑动窗口，求滑动窗口内所有元素之和的最小值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这题相比前面的题目加了一丢丢小的变通: 题目要求首尾串最大点数，其实就是求非首尾串的连续序列的最小点数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span>(<span class="params">self, cardPoints: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 特解</span></span><br><span class="line">        n = <span class="built_in">len</span>(cardPoints)</span><br><span class="line">        <span class="keyword">if</span> k == n:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(cardPoints)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量，因为涉及求和所以定义sum_和min_sum</span></span><br><span class="line">        m = n - k<span class="comment">#滑动窗口长度</span></span><br><span class="line">        sum_, min_sum = <span class="number">0</span>, math.inf</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (sum_)</span></span><br><span class="line">            sum_ += cardPoints[end]</span><br><span class="line">            <span class="keyword">if</span> end-start+<span class="number">1</span>==m:</span><br><span class="line">                min_sum = <span class="built_in">min</span>(min_sum, sum_)</span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定,</span></span><br><span class="line">            <span class="keyword">if</span> end-start+<span class="number">1</span> &gt;= m:</span><br><span class="line"></span><br><span class="line">                sum_ -= cardPoints[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (总点数减去非首尾串的连续序列的最小点数就可以得到首尾串的最大点数)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(cardPoints) - min_sum</span><br></pre></td></tr></table></figure>

<h3 id="1151-最少交换次数来组合所有的-1"><a href="#1151-最少交换次数来组合所有的-1" class="headerlink" title="1151. 最少交换次数来组合所有的 1"></a>1151. 最少交换次数来组合所有的 1</h3><p>给出一个二进制数组 data，你需要通过交换位置，将数组中 任何位置 上的 1 组合到一起，并返回所有可能中所需 最少的交换次数。</p>
<p>示例 1：<br>输入：[1,0,1,0,1]<br>输出：1<br>解释：<br>有三种可能的方法可以把所有的 1 组合在一起：<br>[1,1,1,0,0]，交换 1 次；<br>[0,1,1,1,0]，交换 2 次；<br>[0,0,1,1,1]，交换 1 次。<br>所以最少的交换次数为 1。</p>
<p>示例 2：<br>输入：[0,0,0,1,0]<br>输出：0<br>解释：<br>由于数组中只有一个 1，所以不需要交换。</p>
<p>示例 3：<br>输入：[1,0,1,0,1,0,0,1,1,0,1]<br>输出：3<br>解释：<br>交换 3 次，一种可行的只用 3 次交换的解决方案是 [0,0,0,0,0,1,1,1,1,1,1]。</p>
<p>提示：<br>1 &lt;= data.length &lt;= 10^5<br>0 &lt;= data[i] &lt;= 1</p>
<p>先数出一共有多少个1，输出来的个数就是滑动窗口的长度。</p>
<p>求最小交换次数其实就是求滑动窗口中0个数的最小值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSwaps</span>(<span class="params">self, data: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 先数出一共有多少个1，输出来的个数就是窗口的长度</span></span><br><span class="line">        num_ones = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="keyword">if</span> data[i] == <span class="number">1</span>:</span><br><span class="line">                num_ones += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1</span></span><br><span class="line">        <span class="comment"># 定义需要维护的变量，求最小swap次数其实就是求窗口中0个数的最小值，因此定义num_zeros, min_num_zeros</span></span><br><span class="line">        num_zeros, min_num_zeros = <span class="number">0</span>, math.inf</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="comment"># Step 3</span></span><br><span class="line">            <span class="comment"># 更新需要维护的变量 (num_zeros， min_num_zeros)</span></span><br><span class="line">            <span class="keyword">if</span> data[end] == <span class="number">0</span>:</span><br><span class="line">                num_zeros += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == num_ones:</span><br><span class="line">                min_num_zeros = <span class="built_in">min</span>(min_num_zeros, num_zeros)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4</span></span><br><span class="line">            <span class="comment"># 根据题意可知窗口长度固定 (数组1的总个数)，所以用if</span></span><br><span class="line">            <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定, 同时提前更新需要维护的变量 (num_zeros)</span></span><br><span class="line">            <span class="keyword">if</span> end -start+<span class="number">1</span> &gt;= num_ones:</span><br><span class="line">                <span class="keyword">if</span> data[start] == <span class="number">0</span>:</span><br><span class="line">                    num_zeros -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 5: 返回答案 (如果min_num_zeros依旧是math.inf说明数组没有1存在，不能swap，返回0即可)</span></span><br><span class="line">        <span class="keyword">if</span> min_num_zeros == math.inf:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min_num_zeros</span><br></pre></td></tr></table></figure>
<h3 id="用模板解第219题：219-存在重复元素-II"><a href="#用模板解第219题：219-存在重复元素-II" class="headerlink" title="用模板解第219题：219. 存在重复元素 II"></a>用模板解第219题：219. 存在重复元素 II</h3><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,1], k = 3<br>输出: true</p>
<p>示例 2:</p>
<p>输入: nums = [1,0,1,1], k = 1<br>输出: true</p>
<p>示例 3:</p>
<p>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false</p>
<p>维护长度为k+1的滑动窗口，判断窗口内是否存在两个取值相同的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#step1：定义需要维护的变量</span></span><br><span class="line">        record=<span class="built_in">set</span>()<span class="comment">#长度最多为k+1的哈希表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#step2：定义长度为k+1的滑动窗口，判断窗口内是否存在两个取值相同的元素</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment">#step3：更新需要维护的变量&amp;判断是否满足题目条件</span></span><br><span class="line">            <span class="keyword">if</span> nums[end] <span class="keyword">in</span> record:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            record.add(nums[end])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> end-start+<span class="number">1</span>&gt;=k+<span class="number">1</span>:<span class="comment">#长度大于k+1了</span></span><br><span class="line">                record.remove(nums[start])<span class="comment">#删除最左边的元素</span></span><br><span class="line">                start+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h1 id="第四章：查找问题"><a href="#第四章：查找问题" class="headerlink" title="第四章：查找问题"></a>第四章：查找问题</h1><h2 id="4-1set"><a href="#4-1set" class="headerlink" title="4-1set"></a>4-1set</h2><p><img src="./54.png" alt="Alt text"><br>我的解法，使用set</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        set1=<span class="built_in">set</span>(nums1)</span><br><span class="line">        record=<span class="built_in">set</span>()<span class="comment">#记录结果</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> set1:</span><br><span class="line">                record.add(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(record)</span><br></pre></td></tr></table></figure>

<h2 id="4-2-map-dict"><a href="#4-2-map-dict" class="headerlink" title="4-2 map(dict)"></a>4-2 map(dict)</h2><p><img src="./55.png" alt="Alt text"><br>我的解法，使用dict</p>
<p>在Python中，字典是通过散列表（哈希表）实现的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        s1,s2=nums1,nums2</span><br><span class="line">        <span class="comment">#保证s1长度大于等于s2长度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums1)&lt;<span class="built_in">len</span>(nums2):</span><br><span class="line">            s1=nums2</span><br><span class="line">            s2=nums1</span><br><span class="line">        dic=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> s1:</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[item]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[item]+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> s2:</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">in</span> dic.keys() <span class="keyword">and</span> dic[item]&gt;<span class="number">0</span>:</span><br><span class="line">                res.append(item)</span><br><span class="line">                dic[item]-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="4-3"><a href="#4-3" class="headerlink" title="4-3"></a>4-3</h2><p><img src="./56.png" alt="Alt text"><br>哈希表很牛，但元素是无序的。</p>
<p>因此，二分搜索树可以解决类似下面的有序问题，而哈希表不能：<br><img src="./57.png" alt="Alt text"></p>
<p><img src="./58.png" alt="Alt text"></p>
<p>课后习题：<br><img src="./59.png" alt="Alt text"><br>我的解法，使用dict</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        s1,s2=s,t</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s1)!=<span class="built_in">len</span>(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dic=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> s1:</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[item]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[item]+=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> s2:</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">in</span> dic <span class="keyword">and</span> dic[item]&gt;<span class="number">0</span>:</span><br><span class="line">                dic[item]-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><img src="./60.png" alt="Alt text"></p>
<p><img src="./61.png" alt="Alt text"></p>
<p><strong>解法1：哈希表</strong><br>思想：如果出现重复，则陷入循环</p>
<p>第 1 部分我们按照题目的要求做数位分离，求平方和。</p>
<p>第 2 部分可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。</p>
<pre><code>如果它不在哈希集合中，我们应该添加它。
如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span>(<span class="params">n</span>):</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            n, digit = <span class="built_in">divmod</span>(n, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="comment">#n!=1，说明还没不能确定n是快乐数，否则</span></span><br><span class="line">    <span class="comment">#n not in seen ，说明还没有进入无限循环，否则进入了无限循环(此时n不等于1)</span></span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">        seen.add(n)</span><br><span class="line">        n = get_next(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>或者这样写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_next</span>(<span class="params">n</span>):</span></span><br><span class="line">            total_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                n, digit = <span class="built_in">divmod</span>(n, <span class="number">10</span>)</span><br><span class="line">                total_sum += digit ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment">#n not in seen ，说明还没有进入无限循环，否则进入了无限循环(此时n不等于1)</span></span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            seen.add(n)</span><br><span class="line">            n = get_next(n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span><span class="comment">#此时n in seen，出现不为1的重复数字</span></span><br></pre></td></tr></table></figure>

<p><strong>解法2：快慢指针</strong>：</p>
<p>意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的慢的称为 “乌龟”，跑得快的称为 “兔子”。</p>
<p>我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 getNext(n) 函数的嵌套调用）。</p>
<p><strong>如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。</strong></p>
<p><strong>如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span>  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_next</span>(<span class="params">number</span>):</span></span><br><span class="line">            total_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">                number, digit = <span class="built_in">divmod</span>(number, <span class="number">10</span>)</span><br><span class="line">                total_sum += digit ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">        slow_runner = n</span><br><span class="line">        fast_runner = get_next(n)</span><br><span class="line">        <span class="comment">#如果满足第一个条件，则不是环，则是快乐数；</span></span><br><span class="line">        <span class="comment">#如果满足第二个条件，则有环，则不是快乐数</span></span><br><span class="line">        <span class="comment">#两个条件必满足其一</span></span><br><span class="line">        <span class="keyword">while</span> fast_runner != <span class="number">1</span> <span class="keyword">and</span> slow_runner != fast_runner:</span><br><span class="line">            slow_runner = get_next(slow_runner)<span class="comment">#走一步</span></span><br><span class="line">            fast_runner = get_next(get_next(fast_runner))<span class="comment">#走两步</span></span><br><span class="line">        <span class="keyword">return</span> fast_runner == <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p><img src="./62.png" alt="Alt text"><br>你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span>(<span class="params">self, pattern: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        ch2word=&#123;&#125;</span><br><span class="line">        word2ch=&#123;&#125;</span><br><span class="line"></span><br><span class="line">        words=s.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(words) !=<span class="built_in">len</span>(pattern):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch,word <span class="keyword">in</span> <span class="built_in">zip</span>(pattern,words):</span><br><span class="line">            <span class="comment">#当前word是word2ch的key，但是对应value不是当前ch</span></span><br><span class="line">            <span class="comment">#or 当前ch是ch2word的key，但是对应value不是当前word</span></span><br><span class="line">            <span class="keyword">if</span> (word <span class="keyword">in</span> word2ch <span class="keyword">and</span> word2ch[word] !=ch) <span class="keyword">or</span> (ch <span class="keyword">in</span> ch2word <span class="keyword">and</span> ch2word[ch]!=word):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            ch2word[ch]=word</span><br><span class="line">            word2ch[word]=ch</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<p><img src="./63.png" alt="Alt text"></p>
<p>可以假设 s 和 t 长度相同。</p>
<p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<p>使用哈希表，此时和上一题一样的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        s2t,t2s=&#123;&#125;,&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i ,j  <span class="keyword">in</span> <span class="built_in">zip</span>(s,t):</span><br><span class="line">            <span class="keyword">if</span> (i <span class="keyword">in</span> s2t <span class="keyword">and</span> s2t[i]!=j) <span class="keyword">or</span> (j <span class="keyword">in</span> t2s <span class="keyword">and</span> t2s[j]!=i):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            s2t[i]=j</span><br><span class="line">            t2s[j]=i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>以上两道题一样的，只是第一题多做了个split.</p>
<p><strong>对于第二个题，还有一种思路</strong>：</p>
<p>之前，我们判断 s 和 t 是否一一对应，通过对两个方向分别考虑来解决的。</p>
<p>这里的话，我们找一个第三方来解决，即，按照字母出现的顺序，把两个字符串都映射到另一个集合中。</p>
<p>举个现实生活中的例子，一个人说中文，一个人说法语，怎么判断他们说的是一个意思呢？把中文翻译成英语，把法语也翻译成英语，然后看最后的英语是否相同即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">将第一个出现的字母映射成 1，第二个出现的字母映射成 2</span><br><span class="line"></span><br><span class="line">对于 egg</span><br><span class="line">e -&gt; 1</span><br><span class="line">g -&gt; 2</span><br><span class="line">也就是将 egg 的 e 换成 1, g 换成 2, 就变成了 122</span><br><span class="line"></span><br><span class="line">对于 add</span><br><span class="line">a -&gt; 1</span><br><span class="line">d -&gt; 2</span><br><span class="line">也就是将 add 的 a 换成 1, d 换成 2, 就变成了 122</span><br><span class="line"></span><br><span class="line">egg -&gt; 122, add -&gt; 122</span><br><span class="line">都变成了 122，所以两个字符串异构。</span><br></pre></td></tr></table></figure>
<p>代码的话，只需要将两个字符串分别翻译成第三种类型即可，比如翻译成数字串</p>
<p>我们也可以用两个 map 分别记录两个字符串每个字母的映射。<strong>将所有字母初始都映射到 0</strong>。记录过程中，如果发现了当前映射不一致，就可以立即返回 false 了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        n=<span class="built_in">len</span>(s)</span><br><span class="line">        s_dic=&#123;&#125;</span><br><span class="line">        t_dic=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment">#当前的映射值是否相同</span></span><br><span class="line">            <span class="keyword">if</span> s_dic.get(s[i],<span class="number">0</span>)!=t_dic.get(t[i],<span class="number">0</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#此时相等（都出现过 or 都没出现过）</span></span><br><span class="line">            <span class="comment">#若都没出现过，则加入字典里，否则什么都不做</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> s_dic:</span><br><span class="line">                s_dic[s[i]]=i+<span class="number">1</span></span><br><span class="line">                t_dic[t[i]]=i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这种思想其实可以直调用Python的index：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s.index(s[i]) != t.index(t[i]):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="./64.png" alt="Alt text"><br>我的解法：哈希表(字典排序)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frequencySort</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        dic=&#123;&#125;</span><br><span class="line">        <span class="comment">#将每个字符的出现频次存入哈希表</span></span><br><span class="line">        <span class="keyword">for</span> le <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> le <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[le]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[le]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        lis=<span class="built_in">sorted</span>(dic.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        res=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> lis:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(v):</span><br><span class="line">                res.append(k)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n+klog⁡k)</p>
<p>O(n + k log k)，其中 n 是字符串 s 的长度，k是字符串 s 包含的不同字符的个数</p>
<p>遍历字符串统计每个字符出现的频率需要 O(n)的时间。<br>将字符按照出现频率排序需要 O(klogk) 的时间。<br>生成排序后的字符串，需要遍历 k 个不同字符，需要 O(k)的时间，拼接字符串需要 O(n)的时间。</p>
<p>空间复杂度：O(n+k)，其中 n 是字符串 s 的长度，k 是字符串 s 包含的不同字符的个数。空间复杂度主要取决于哈希表、列表和生成的排序后的字符串。</p>
<h2 id="4-4"><a href="#4-4" class="headerlink" title="4-4"></a>4-4</h2><p><img src="./65.png" alt="Alt text"></p>
<p><img src="./66.png" alt="Alt text"></p>
<p>官方Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<p>课后习题：<br><img src="./67.png" alt="Alt text"><br>注意：答案中不可以包含重复的三元组。</p>
<p><strong>官方题解</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> first &gt; <span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># c 对应的指针初始指向数组的最右端</span></span><br><span class="line">            third = n - <span class="number">1</span></span><br><span class="line">            target = -nums[first]</span><br><span class="line">            <span class="comment"># 枚举 b</span></span><br><span class="line">            <span class="keyword">for</span> second <span class="keyword">in</span> <span class="built_in">range</span>(first + <span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 需要和上一次枚举的数不相同</span></span><br><span class="line">                <span class="keyword">if</span> second &gt; first + <span class="number">1</span> <span class="keyword">and</span> nums[second] == nums[second - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span> second &lt; third <span class="keyword">and</span> nums[second] + nums[third] &gt; target:</span><br><span class="line">                    third -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">                <span class="comment"># 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span> second == third:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[second] + nums[third] == target:</span><br><span class="line">                    ans.append([nums[first], nums[second], nums[third]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p><strong>评论区比较易懂的代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        </span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> nums <span class="keyword">or</span> n&lt;<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>):</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="comment">#结果不能重复</span></span><br><span class="line">            <span class="comment">#之所以只比较相邻，是因为数组已经做了排序</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(L&lt;R):</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[L]+nums[R]==<span class="number">0</span>):</span><br><span class="line">                    res.append([nums[i],nums[L],nums[R]])</span><br><span class="line">                    <span class="keyword">while</span>(L&lt;R <span class="keyword">and</span> nums[L]==nums[L+<span class="number">1</span>]):</span><br><span class="line">                        L=L+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span>(L&lt;R <span class="keyword">and</span> nums[R]==nums[R-<span class="number">1</span>]):</span><br><span class="line">                        R=R-<span class="number">1</span></span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                    R=R-<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span>(nums[i]+nums[L]+nums[R]&gt;<span class="number">0</span>):</span><br><span class="line">                    R=R-<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p>
<p><img src="./68.png" alt="Alt text"><br>和上题一样，官方貌似参考了上题中的评论区解法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        quadruplets = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="built_in">len</span>(nums) &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> quadruplets</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, length - <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left, right = j + <span class="number">1</span>, length - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    total = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line">                    <span class="keyword">if</span> total == target:</span><br><span class="line">                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> quadruplets</span><br></pre></td></tr></table></figure>


<p><img src="./69.png" alt="Alt text"><br>我的解法：双指针，在上面题代码上修改得到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;nums&#x27;</span>,nums)</span><br><span class="line"></span><br><span class="line">        res=<span class="built_in">abs</span>(target+<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(L&lt;R):</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[i]+nums[L]+nums[R]-target)&lt;res):</span><br><span class="line">                    ret=nums[i]+nums[L]+nums[R]<span class="comment">#三数之和</span></span><br><span class="line">                    res=<span class="built_in">abs</span>(ret-target)</span><br><span class="line">                <span class="comment">#因为有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[L]+nums[R]&lt;target:</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    R=R-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>也可以这样，三数之和等于target时就直接返回，可以kuai一点点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;nums&#x27;</span>,nums)</span><br><span class="line"></span><br><span class="line">        res=<span class="built_in">abs</span>(target+<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            L=i+<span class="number">1</span></span><br><span class="line">            R=n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(L&lt;R):</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[i]+nums[L]+nums[R]-target)&lt;res):</span><br><span class="line">                    ret=nums[i]+nums[L]+nums[R]<span class="comment">#三数之和</span></span><br><span class="line">                    res=<span class="built_in">abs</span>(ret-target)</span><br><span class="line">                <span class="comment">#因为有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[L]+nums[R]&lt;target:</span><br><span class="line">                    L=L+<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[L]+nums[R]&gt;target:</span><br><span class="line">                    R=R-<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> nums[i]+nums[L]+nums[R]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="4-5"><a href="#4-5" class="headerlink" title="4-5"></a>4-5</h2><p><img src="./70.png" alt="Alt text"></p>
<p><img src="./71.png" alt="Alt text"></p>
<p><img src="./72.png" alt="Alt text"></p>
<p>我写的Python版本答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dic=<span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> nums3:</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> nums4:</span><br><span class="line">                <span class="keyword">if</span> a+b <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                    dic[a+b]=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dic[a+b]+=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">        cnt=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">                <span class="keyword">if</span> (-nums1[i]-nums2[j]) <span class="keyword">in</span> dic:</span><br><span class="line">                    cnt+=dic[-nums1[i]-nums2[j]]</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<p>官方代码更简洁，思想一样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>], B: <span class="type">List</span>[<span class="built_in">int</span>], C: <span class="type">List</span>[<span class="built_in">int</span>], D: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        countAB = collections.Counter(u + v <span class="keyword">for</span> u <span class="keyword">in</span> A <span class="keyword">for</span> v <span class="keyword">in</span> B)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> C:</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> D:</span><br><span class="line">                <span class="keyword">if</span> -u - v <span class="keyword">in</span> countAB:</span><br><span class="line">                    ans += countAB[-u - v]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>课后习题<br><img src="./73.png" alt="Alt text"><br>strs[i] 仅包含小写字母。</p>
<p>思路：组成这种词的不同字母个数是一样的，因此可以以此为key，value是包含了同一类Anagrams的list，最后返回value即可。</p>
<p>官方代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">        mp = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> st <span class="keyword">in</span> strs:</span><br><span class="line">            counts = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> st:</span><br><span class="line">                counts[<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 需要将 list 转换成 tuple 才能进行哈希,list is not hashable!</span></span><br><span class="line">            mp[<span class="built_in">tuple</span>(counts)].append(st)</span><br><span class="line">        <span class="built_in">print</span>(mp)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(mp.values())</span><br></pre></td></tr></table></figure>

<h2 id="4-6"><a href="#4-6" class="headerlink" title="4-6"></a>4-6</h2><p><img src="./74.png" alt="Alt text"></p>
<p><img src="./75.png" alt="Alt text"></p>
<p><img src="./76.png" alt="Alt text"></p>
<p>后面的if可省略：<br><img src="./77.png" alt="Alt text"></p>
<p>解释一下：</p>
<p>哈希表的key是其余每一个点与第i个点（<strong>枢纽点</strong>）之间的距离，value是与第i个点之间的距离是当前key的点的个数。</p>
<p>那么，如果某个key对应的value=m，即对应m个这样的点，那么满足题意得点对组合总共有m*(m-1)个。</p>
<p>我改写的Python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfBoomerangs</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">        n=<span class="built_in">len</span>(points)</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cal_dist</span>(<span class="params">i,j</span>):</span></span><br><span class="line">            <span class="keyword">return</span> (points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>])**<span class="number">2</span>+(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>])**<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dic=<span class="built_in">dict</span>()</span><br><span class="line">            <span class="keyword">for</span>  j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> j!=i:<span class="comment">#可不要</span></span><br><span class="line">                    dis=cal_dist(i,j)</span><br><span class="line">                    <span class="keyword">if</span> dis <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                        dic[dis]=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dic[dis]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">                <span class="keyword">if</span> v&gt;=<span class="number">2</span>:</span><br><span class="line">                    res+=v*(v-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)，其中 n 是数组长度</p>
<p>空间复杂度：O(n)</p>
<p>同样的思路，官方使用了defaultdict，使得代码更简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfBoomerangs</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> points:</span><br><span class="line">            cnt = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">            <span class="keyword">for</span> q <span class="keyword">in</span> points:</span><br><span class="line">                dis = (p[<span class="number">0</span>] - q[<span class="number">0</span>]) * (p[<span class="number">0</span>] - q[<span class="number">0</span>]) + (p[<span class="number">1</span>] - q[<span class="number">1</span>]) * (p[<span class="number">1</span>] - q[<span class="number">1</span>])</span><br><span class="line">                cnt[dis] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> cnt.values():</span><br><span class="line">                ans += m * (m - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>课后习题<br><img src="./78.png" alt="Alt text"><br>points 中的所有点互不相同。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-points-on-a-line/solution/tong-ge-lai-shua-ti-la-liang-chong-si-lu-94gy/">https://leetcode-cn.com/problems/max-points-on-a-line/solution/tong-ge-lai-shua-ti-la-liang-chong-si-lu-94gy/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-points-on-a-line/solution/python-shi-yong-cheng-fa-bi-mian-jing-du-ml2d/">https://leetcode-cn.com/problems/max-points-on-a-line/solution/python-shi-yong-cheng-fa-bi-mian-jing-du-ml2d/</a></p>
<p>两两之差用乘法判断在不在一条直线上。(但是需要o(n^3)暴力判断)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 三点在一条直线上时,斜率相等</span></span><br><span class="line">        <span class="comment"># y2 - y1 = k * (x2 - x1), y3 - y2 = k * (x3 - x2)</span></span><br><span class="line">        <span class="comment"># (y2 - y1) * (x3 - x2) = (y3 - y2) * (x2 - x1)</span></span><br><span class="line">        </span><br><span class="line">        explored = <span class="built_in">set</span>()</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(points)):</span><br><span class="line">                curr = <span class="number">2</span></span><br><span class="line">                dx,dy = points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>],points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>, <span class="built_in">len</span>(points)):</span><br><span class="line">                    <span class="keyword">if</span> (i,j) <span class="keyword">in</span> explored <span class="keyword">or</span> (i,k) <span class="keyword">in</span> explored <span class="keyword">or</span> (j,k) <span class="keyword">in</span> explored:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> dy * (points[k][<span class="number">0</span>] - points[j][<span class="number">0</span>]) == (points[k][<span class="number">1</span>] - points[j][<span class="number">1</span>]) * dx:</span><br><span class="line">                        curr += <span class="number">1</span></span><br><span class="line">                        explored.add((j,k))</span><br><span class="line">                        explored.add((i,k))</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, curr)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>使用哈希表统计同一kx+b的个数可以少一层循环。(需要使用辗转相除法避免除法精度问题)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">m, n</span>):</span></span><br><span class="line">            <span class="keyword">return</span> m <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">else</span> gcd(n, m%n)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getslope</span>(<span class="params">p1, p2</span>):</span></span><br><span class="line">            dx = p1[<span class="number">0</span>] - p2[<span class="number">0</span>]</span><br><span class="line">            dy = p1[<span class="number">1</span>] - p2[<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> dx == <span class="number">0</span>: <span class="keyword">return</span> (p1[<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> dy == <span class="number">0</span>: <span class="keyword">return</span> (<span class="number">0</span>, p1[<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">            d = gcd(dx, dy)</span><br><span class="line">            <span class="keyword">return</span> (dx//d, dy//d)</span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points)):</span><br><span class="line">            d = defaultdict(<span class="keyword">lambda</span>:<span class="number">0</span>)</span><br><span class="line">            same, maxi = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">            p1 = points[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(points)):</span><br><span class="line">                p2 = points[j]</span><br><span class="line">                <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                    same += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    slope = getslope(p1, p2)</span><br><span class="line">                    d[slope] += <span class="number">1</span></span><br><span class="line">                    maxi = <span class="built_in">max</span>(maxi, d[slope])</span><br><span class="line">            res = <span class="built_in">max</span>(res, same + maxi)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>因为直线总是以经过外层循环的点，所以取一个斜率即可(一个点和一个斜率确定一条直线)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">hdiv</span>(<span class="params">dividend, divisor, accuracy</span>):</span></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            功能: 完成高精度的除法</span></span><br><span class="line"><span class="string">            参数:</span></span><br><span class="line"><span class="string">                dividend: 被除数</span></span><br><span class="line"><span class="string">                divisor: 除数</span></span><br><span class="line"><span class="string">                accuracy: 除法精度</span></span><br><span class="line"><span class="string">            返回: 计算结果(字符串)</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="comment"># 定义存储结果的字符串</span></span><br><span class="line">            res = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 定义保存正负数的变量</span></span><br><span class="line">            isNegative = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 确定正负号</span></span><br><span class="line">            <span class="keyword">if</span> dividend &lt; <span class="number">0</span> <span class="keyword">and</span> divisor &gt; <span class="number">0</span>:</span><br><span class="line">                dividend = <span class="built_in">abs</span>(dividend)</span><br><span class="line">                isNegative = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> divisor &lt; <span class="number">0</span> <span class="keyword">and</span> dividend &gt; <span class="number">0</span>:</span><br><span class="line">                divisor = <span class="built_in">abs</span>(divisor)</span><br><span class="line">                isNegative = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 在结果添加正负号</span></span><br><span class="line">            <span class="keyword">if</span> isNegative:</span><br><span class="line">                res += <span class="string">&#x27;-&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算整数部分</span></span><br><span class="line">            integer = <span class="built_in">round</span>(dividend // divisor)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将结果添加入结果</span></span><br><span class="line">            res += <span class="built_in">str</span>(integer) + <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算余数</span></span><br><span class="line">            remainder = dividend % divisor</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算小数部分</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(accuracy):</span><br><span class="line">                dividend = remainder * <span class="number">10</span></span><br><span class="line">                res += <span class="built_in">str</span>(<span class="built_in">round</span>(dividend // divisor))</span><br><span class="line">                remainder = dividend % divisor</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># k = (y2 - y1) / (x2 - x1), b = y - k * x</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points)):</span><br><span class="line">            d = Counter()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(points)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]:</span><br><span class="line">                    k = inf</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k = hdiv(points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>],points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>],<span class="number">10</span>)</span><br><span class="line">                d[k] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(d.values()) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>不用gcd得代码也能过：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points) - <span class="number">1</span>):</span><br><span class="line">            curr = Counter()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(points)):</span><br><span class="line">                dx, dy = points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>], points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>]</span><br><span class="line">                curr[dy / dx <span class="keyword">if</span> dx <span class="keyword">else</span> inf] += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(curr.values()) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>hard，这题以后再看吧~</p>
<h2 id="4-7"><a href="#4-7" class="headerlink" title="4-7"></a>4-7</h2><p><img src="./79.png" alt="Alt text"></p>
<p>固定长度的滑动窗口+哈希表</p>
<p><del>维护滑动窗口的长度为k+1：</del></p>
<p><del>比如k=3，那么i为0，j为3，满足j-i&lt;=k，这样，i和j总共包含了k+1=4个元素（最多，因为i、和j还可以靠近些）</del></p>
<p><del>窗口再大的话，j-i就可能不满足小于等于k了</del></p>
<p>nonono，是k~</p>
<p>滑动窗口长度为k，对于新到来的的元素，它的下标和滑动窗口中最前面元素的下标恰好是k。</p>
<p><img src="./80.png" alt="Alt text"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        record=<span class="built_in">set</span>()<span class="comment">#长度最多为k的哈希表</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> record:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            record.add(nums[i])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(record)==k+<span class="number">1</span>:<span class="comment">#长度大于k了</span></span><br><span class="line">                record.remove(nums[i-k])<span class="comment">#删除最左边的元素，对应下标是i-k，画个图就清楚了</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>维护一个哈希表，里面始终最多包含 k 个元素，当出现重复值时则说明在 k 距离内存在重复元素（数组=[2,1,0,4,2]，画个图就知道为什么是维度哈希表长度最多为k了，同样最左边元素下标是i-k也可以看出来，画图吧）</p>
<p>每次遍历一个元素则将其加入哈希表中，如果哈希表的大小大于 k，则移除最前面的数字</p>
<p>时间复杂度：O(nlogn)，n为数组长度,set底层是二叉树，查找一次花费logn</p>
<p>空间复杂度：O(k)</p>
<p>2021/11/29更新:</p>
<p>直接套滑动窗口模板：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#step1：定义需要维护的变量</span></span><br><span class="line">        record=<span class="built_in">set</span>()<span class="comment">#长度最多为k+1的哈希表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#step2：定义长度为k+1的滑动窗口，判断窗口内是否存在两个取值相同的元素</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment">#step3：更新需要维护的变量&amp;判断是否满足题目条件</span></span><br><span class="line">            <span class="keyword">if</span> nums[end] <span class="keyword">in</span> record:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            record.add(nums[end])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> end-start+<span class="number">1</span>&gt;=k+<span class="number">1</span>:<span class="comment">#长度大于k+1了</span></span><br><span class="line">                record.remove(nums[start])<span class="comment">#删除最左边的元素</span></span><br><span class="line">                start+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>课后习题<br><img src="./81.png" alt="Alt text"></p>
<p>本节题目的简化版本，我写的Python代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        record=<span class="built_in">set</span>()</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> record:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            record.add(nums[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>也可以排序，贴个官方代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-8"><a href="#4-8" class="headerlink" title="4-8"></a>4-8</h2><p><img src="./82.png" alt="Alt text"></p>
<p>直接在上一题的代码上稍加改动即可，具体的，改一下判断条件。</p>
<p>如何实现这一新的判断条件？看官方题解：<br><img src="./85.png" alt="Alt text"></p>
<p><img src="./84.png" alt="Alt text"></p>
<p><img src="./83.png" alt="Alt text"></p>
<p>改写成Python代码，注意Python自带的set是无序的，因此要使用有序的set：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment">#record=set()#长度最多为k的哈希表</span></span><br><span class="line">        <span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedSet</span><br><span class="line">        record=SortedSet()<span class="comment">#有序集合</span></span><br><span class="line">        </span><br><span class="line">  </span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">      </span><br><span class="line">            <span class="comment">#lis=[x for x in record if x&gt;=nums[i]-t]</span></span><br><span class="line">            <span class="comment">#if len(lis)&gt;0:</span></span><br><span class="line">            <span class="comment">#    temp=min(lis)</span></span><br><span class="line">            <span class="comment">#else:</span></span><br><span class="line">            <span class="comment">#    temp=None</span></span><br><span class="line">            <span class="comment">#print(temp)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">##查找第一个大于等于num-t的数的位置</span></span><br><span class="line">            index = record.bisect_left(nums[i] - t)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> index&lt;<span class="built_in">len</span>(record)  <span class="keyword">and</span> record[index]&lt;=nums[i]+t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            record.add(nums[i])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(record)==k+<span class="number">1</span>:<span class="comment">#长度大于k了</span></span><br><span class="line">                record.remove(nums[i-k])<span class="comment">#删除最左边的元素，对应下标是i-k，画个图就清楚了</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这个不太适合套滑动窗口模板。</p>
<h1 id="第五章：链表"><a href="#第五章：链表" class="headerlink" title="第五章：链表"></a>第五章：链表</h1><h2 id="5-1"><a href="#5-1" class="headerlink" title="5-1"></a>5-1</h2><p><img src="./86.png" alt="Alt text"></p>
<p><img src="./87.png" alt="Alt text"></p>
<p>我写的Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pre=<span class="literal">None</span></span><br><span class="line">        cur=head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">next</span>=cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            cur.<span class="built_in">next</span>=pre</span><br><span class="line"></span><br><span class="line">            pre=cur</span><br><span class="line">            cur=<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<p>也可以让pre初始为head，cur初始为head.next，但这样需要单独考虑链表长度为0和1的情况，并且要先初始化cur，因为初始化pre时需要执行pre.next=None，这样会把链表切断，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        cur=head.<span class="built_in">next</span></span><br><span class="line">        pre=head</span><br><span class="line">        pre.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">next</span>=cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            cur.<span class="built_in">next</span>=pre</span><br><span class="line"></span><br><span class="line">            pre=cur</span><br><span class="line">            cur=<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>


<p>课后习题<br><img src="./88.png" alt="Alt text"><br>m&lt;= n</p>
<p><strong>方法1：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">## 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span></span><br><span class="line">        dummy_node = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy_node.<span class="built_in">next</span> = head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#找到第left个节点的前驱节点a和第right个节点b</span></span><br><span class="line">        a=dummy_node</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left-<span class="number">1</span>):</span><br><span class="line">            a=a.<span class="built_in">next</span></span><br><span class="line">        b=dummy_node</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right):</span><br><span class="line">            b=b.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        tou=a.<span class="built_in">next</span><span class="comment">#待反转的部分链表的头</span></span><br><span class="line">        wei=b<span class="comment">##待反转的部分链表的尾</span></span><br><span class="line">        suc=wei.<span class="built_in">next</span><span class="comment">#第right个节点的后继节点</span></span><br><span class="line">        <span class="comment">#截断得到待反转的链表</span></span><br><span class="line">        a.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        wei.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#开始反转</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse_linked_list</span>(<span class="params">head: ListNode</span>):</span></span><br><span class="line">            <span class="comment"># 也可以使用递归反转一个链表</span></span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            cur = head</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = pre</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = <span class="built_in">next</span></span><br><span class="line">        reverse_linked_list(tou)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#最后再连接起来</span></span><br><span class="line">        a.<span class="built_in">next</span>=wei</span><br><span class="line">        tou.<span class="built_in">next</span>=suc</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy_node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(N)，其中 NNN 是链表总节点数。最坏情况下，需要遍历整个链表。</p>
<p>空间复杂度：O(1)。只使用到常数个变量。</p>
<p>关于加了个头节点的解释：</p>
<p><img src="./89.png" alt="Alt text"></p>
<p><img src="./90.png" alt="Alt text"></p>
<p><strong>方法2：一次遍历「穿针引线」反转链表（头插法）</strong></p>
<p>方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 O(N)，但遍历了链表 2 次，可不可以只遍历一次呢？答案是可以的。</p>
<p>整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置.<br><img src="./91.png" alt="Alt text"></p>
<p><img src="./92.png" alt="Alt text"></p>
<p><img src="./93.png" alt="Alt text"><br><img src="./94.png" alt="Alt text"><br><img src="./95.png" alt="Alt text"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        dummy_node = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy_node.<span class="built_in">next</span> = head</span><br><span class="line">        pre = dummy_node</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left):</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = <span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span>.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2"><a href="#5-2" class="headerlink" title="5-2"></a>5-2</h2><p>介绍了一些链表的相关操作</p>
<p>课后习题<br><img src="./96.png" alt="Alt text"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p=head</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> p.val ==p.<span class="built_in">next</span>.val:</span><br><span class="line">                p.<span class="built_in">next</span>=p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p=p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<p><img src="./97.png" alt="Alt text"><br>你应当 保留 两个分区中每个节点的初始相对位置。</p>
<p>我看了题解后独立写的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, head: ListNode, x: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        small_dummy=ListNode(<span class="number">101</span>)</span><br><span class="line">        large_dummy=ListNode(<span class="number">101</span>)</span><br><span class="line">        small,large=small_dummy,large_dummy<span class="comment">#工作指针</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val&lt;x:</span><br><span class="line">                small.<span class="built_in">next</span>=head</span><br><span class="line">                small=small.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                large.<span class="built_in">next</span>=head</span><br><span class="line">                large=large.<span class="built_in">next</span></span><br><span class="line">            head=head.<span class="built_in">next</span></span><br><span class="line">        large.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        small.<span class="built_in">next</span>=large_dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> small_dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)，因为只生成了两个初始的头结点，之后的操作都是在原链表上进行的。</p>
<p><img src="./98.png" alt="Alt text"><br>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">            </span><br><span class="line">        odd=head<span class="comment">#奇</span></span><br><span class="line"></span><br><span class="line">        evenHead=head.<span class="built_in">next</span><span class="comment">#记录，后面连接时用到</span></span><br><span class="line">        even=evenHead<span class="comment">#偶</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> even <span class="keyword">and</span> even.<span class="built_in">next</span>:</span><br><span class="line">            odd.<span class="built_in">next</span>=even.<span class="built_in">next</span></span><br><span class="line">            odd=odd.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            even.<span class="built_in">next</span>=odd.<span class="built_in">next</span></span><br><span class="line">            even=even.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#连接</span></span><br><span class="line">        odd.<span class="built_in">next</span>=evenHead</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>


<p><img src="./99.png" alt="Alt text"><br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>并且每个节点只能存储 一位 数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">        dummy=ListNode(<span class="number">0</span>)</span><br><span class="line">        p=dummy</span><br><span class="line">        carry=<span class="number">0</span><span class="comment">#进位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            p.<span class="built_in">next</span>=ListNode((l1.val+l2.val+carry)%<span class="number">10</span>)</span><br><span class="line">            carry=(l1.val+l2.val+carry)//<span class="number">10</span><span class="comment">#更新进位，取值为0或者一个0到9的数字</span></span><br><span class="line">            l1=l1.<span class="built_in">next</span></span><br><span class="line">            l2=l2.<span class="built_in">next</span></span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            <span class="keyword">while</span> l2:</span><br><span class="line">                p.<span class="built_in">next</span>=ListNode((l2.val+carry)%<span class="number">10</span>)</span><br><span class="line">                carry=(l2.val+carry)//<span class="number">10</span><span class="comment">#更新进位，取值为0或者一个0到9的数字                </span></span><br><span class="line">                l2=l2.<span class="built_in">next</span></span><br><span class="line">                p=p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            <span class="keyword">while</span> l1:</span><br><span class="line">                p.<span class="built_in">next</span>=ListNode((l1.val+carry)%<span class="number">10</span>)</span><br><span class="line">                carry=(l1.val+carry)//<span class="number">10</span><span class="comment">#更新进位，取值为0或者一个0到9的数字                </span></span><br><span class="line">                l1=l1.<span class="built_in">next</span></span><br><span class="line">                p=p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> carry !=<span class="number">0</span>:<span class="comment">#if carry==1</span></span><br><span class="line">            p.<span class="built_in">next</span>=ListNode(carry)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>


<p><img src="./100.png" alt="Alt text"><br>进阶：如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转()</p>
<p>本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。</p>
<p>我怎么就没想到。。。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        s1, s2 = [], []</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            s1.append(l1.val)</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            s2.append(l2.val)</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s1 <span class="keyword">or</span> s2 <span class="keyword">or</span> carry != <span class="number">0</span>:</span><br><span class="line">            a = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> s1 <span class="keyword">else</span> s1.pop()</span><br><span class="line">            b = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> s2 <span class="keyword">else</span> s2.pop()</span><br><span class="line">            cur = a + b + carry</span><br><span class="line">            carry = cur // <span class="number">10</span></span><br><span class="line">            cur %= <span class="number">10</span></span><br><span class="line">            <span class="comment">#头插</span></span><br><span class="line">            curnode = ListNode(cur)</span><br><span class="line">            curnode.<span class="built_in">next</span> = ans</span><br><span class="line">            ans = curnode</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="5-3"><a href="#5-3" class="headerlink" title="5-3"></a>5-3</h2><p><img src="./101.png" alt="Alt text"></p>
<p>不设虚拟头节点：需要单独对第一个节点进行处理<br><img src="./102.png" alt="Alt text"></p>
<p>设置虚拟头节点：方便，统一<br><img src="./103.png" alt="Alt text"></p>
<p>Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        dumyHead=ListNode(<span class="number">111</span>,head)</span><br><span class="line">        p=dumyHead</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> p.<span class="built_in">next</span>.val==val:</span><br><span class="line">                p.<span class="built_in">next</span>=p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p=p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dumyHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>课后习题<br><img src="./104.png" alt="Alt text"></p>
<p>我写的答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">            </span><br><span class="line">        dummyHead=ListNode(-<span class="number">1000</span>)</span><br><span class="line">        dummyHead.<span class="built_in">next</span>=head</span><br><span class="line"></span><br><span class="line">        pre=dummyHead</span><br><span class="line">        p=dummyHead.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> p.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> p.val==p.<span class="built_in">next</span>.val:</span><br><span class="line">                temp=p.val</span><br><span class="line">                <span class="keyword">while</span> p <span class="keyword">and</span> p.val==temp:</span><br><span class="line">                    p=p.<span class="built_in">next</span></span><br><span class="line">                pre.<span class="built_in">next</span>=p</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre=p</span><br><span class="line">                p=p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中 n 是链表的长度。</p>
<p>空间复杂度：O(1).</p>
<p><img src="./105.png" alt="Alt text"></p>
<p>我的答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#两者都不为空</span></span><br><span class="line">        dummyHead=ListNode()</span><br><span class="line">        p=dummyHead<span class="comment">#新链表的虚拟头节点</span></span><br><span class="line"></span><br><span class="line">        p1,p2=l1,l2<span class="comment">#遍历两个链表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">or</span> p2:</span><br><span class="line">            <span class="comment">#l2遍历结束</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">                p.<span class="built_in">next</span>=p1</span><br><span class="line">                p=p.<span class="built_in">next</span></span><br><span class="line">                </span><br><span class="line">                p1=p1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment">#l1遍历结束</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">                p.<span class="built_in">next</span>=p2</span><br><span class="line">                p=p.<span class="built_in">next</span></span><br><span class="line">                </span><br><span class="line">                p2=p2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#l1和l2都还没遍历结束</span></span><br><span class="line">            <span class="keyword">if</span> p1 <span class="keyword">and</span>  p2:</span><br><span class="line">                <span class="keyword">if</span> p1.val&lt;p2.val:</span><br><span class="line">                    p.<span class="built_in">next</span>=p1</span><br><span class="line">                    p=p.<span class="built_in">next</span></span><br><span class="line">               </span><br><span class="line">                    p1=p1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.<span class="built_in">next</span>=p2</span><br><span class="line">                    p=p.<span class="built_in">next</span></span><br><span class="line">                    </span><br><span class="line">                    p2=p2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>官方的答案更简洁，更易懂</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        prehead = ListNode(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        prev = prehead</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                prev.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span>            </span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> l2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n+m)，其中n 和m分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m).</p>
<p>空间复杂度：O(1), 我们只需要常数的空间存放若干变量。</p>
<p>以上是迭代的方法，还可以采用递归的方法，官方题解如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">elif</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">elif</span> l1.val &lt; l2.val:</span><br><span class="line">            l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.<span class="built_in">next</span> = self.mergeTwoLists(l1, l2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。</p>
<p>空间复杂度：O(n+m)，其中 n 和 m分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m次，因此空间复杂度为 O(n+m)。</p>
<h2 id="5-4"><a href="#5-4" class="headerlink" title="5-4"></a>5-4</h2><p><img src="./106.png" alt="Alt text"></p>
<p><img src="./108.png" alt="Alt text"></p>
<p><img src="./107.png" alt="Alt text"></p>
<p>我改成Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummyHead=ListNode()</span><br><span class="line">        dummyHead.<span class="built_in">next</span>=head</span><br><span class="line"></span><br><span class="line">        p=dummyHead</span><br><span class="line">        <span class="comment">#保证存在两个将要交换位置的元素</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">and</span> p.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            node1=p.<span class="built_in">next</span></span><br><span class="line">            node2=node1.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span>=node2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#开始交换</span></span><br><span class="line">            p.<span class="built_in">next</span>=node2</span><br><span class="line">            node2.<span class="built_in">next</span>=node1</span><br><span class="line">            node1.<span class="built_in">next</span>=<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#走</span></span><br><span class="line">            p=node1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>课后习题</p>
<p><img src="./109.png" alt="Alt text"></p>
<p>参考官方代码+小改动，具体理解结合官方图解就很清晰了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment">#翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">sub_head,sub_tail</span>):</span></span><br><span class="line">            pre=<span class="literal">None</span></span><br><span class="line">            cur=sub_head</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#在普通的反转链表中，这里的判断条件是cur不为None</span></span><br><span class="line">            <span class="comment">#但这里，对于完整的链表，只反转sub_head到sub_tail之间的节点</span></span><br><span class="line">            <span class="comment">#所以判断条件成了pre!=tail</span></span><br><span class="line">            <span class="comment">#当然，也可以先保存tail的后继，然后就和之前普通的俩表反转方法一致了，如下：</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#sub_tail_nex=sub_tail.next</span></span><br><span class="line">            <span class="comment">#while cur!=sub_tail_nex:</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> pre!=tail:</span><br><span class="line">                <span class="built_in">next</span>=cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">                cur.<span class="built_in">next</span>=pre</span><br><span class="line"></span><br><span class="line">                pre=cur</span><br><span class="line">                cur=<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> sub_tail,sub_head<span class="comment">#tail成了头，head成了尾，是谓“链表反转”</span></span><br><span class="line">        </span><br><span class="line">        dummyHead=ListNode()</span><br><span class="line">        dummyHead.<span class="built_in">next</span>=head</span><br><span class="line"></span><br><span class="line">        pre=dummyHead</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            tail=pre</span><br><span class="line">            <span class="comment"># 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                tail = tail.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                    <span class="keyword">return</span> dummyHead.<span class="built_in">next</span></span><br><span class="line">            nex = tail.<span class="built_in">next</span></span><br><span class="line">            head, tail = reverseList(head, tail)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 把子链表重新接回原链表</span></span><br><span class="line">            pre.<span class="built_in">next</span> = head</span><br><span class="line">            tail.<span class="built_in">next</span> = nex</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#为下一次操作做准备</span></span><br><span class="line">            pre = tail</span><br><span class="line">            head = tail.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p><img src="./110.png" alt="Alt text"></p>
<p>看官方题解：</p>
<p>对于单向链表而言，只有指向后一个节点的指针，因此需要从链表的头节点开始往后遍历链表中的节点，寻找插入位置。</p>
<p><img src="./112.png" alt="Alt text"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        dummyHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummyHead.<span class="built_in">next</span> = head</span><br><span class="line">        lastSorted = head</span><br><span class="line">        curr = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> lastSorted.val &lt;= curr.val:</span><br><span class="line">                lastSorted = lastSorted.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = dummyHead</span><br><span class="line">                <span class="keyword">while</span> prev.<span class="built_in">next</span>.val &lt;= curr.val:</span><br><span class="line">                    prev = prev.<span class="built_in">next</span></span><br><span class="line">                lastSorted.<span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">                curr.<span class="built_in">next</span> = prev.<span class="built_in">next</span></span><br><span class="line">                prev.<span class="built_in">next</span> = curr</span><br><span class="line">            curr = lastSorted.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p><img src="./111.png" alt="Alt text"></p>
<p>暂时不想看。</p>
<h2 id="5-5"><a href="#5-5" class="headerlink" title="5-5"></a>5-5</h2><p><img src="./113.png" alt="Alt text"></p>
<p><img src="./114.png" alt="Alt text"></p>
<p>我改成Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.<span class="built_in">next</span>:</span><br><span class="line">            node=<span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        node.val=node.<span class="built_in">next</span>.val</span><br><span class="line">        node.<span class="built_in">next</span>=node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="5-6"><a href="#5-6" class="headerlink" title="5-6"></a>5-6</h2><p><img src="./115.png" alt="Alt text"></p>
<p>我写的解法1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        p=head</span><br><span class="line">        length=<span class="number">0</span><span class="comment">#链表长度</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            length+=<span class="number">1</span></span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        dummyHead=ListNode()</span><br><span class="line">        dummyHead.<span class="built_in">next</span>=head</span><br><span class="line">        pre=dummyHead<span class="comment">#待删除结点的前驱</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length-n):</span><br><span class="line">            pre=pre.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span>=pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>进阶：你能尝试使用一趟扫描实现吗？<br><img src="./116.png" alt="Alt text"></p>
<p>我根据题解写的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        dummyHead=ListNode()</span><br><span class="line">        dummyHead.<span class="built_in">next</span>=head</span><br><span class="line"></span><br><span class="line">        fast=head</span><br><span class="line">        slow=dummyHead</span><br><span class="line"></span><br><span class="line">        <span class="comment">#fast先行2步</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            fast=fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast=fast.<span class="built_in">next</span></span><br><span class="line">            slow=slow.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#此时slow指向待删除结点的前驱</span></span><br><span class="line">        slow.<span class="built_in">next</span>=slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>课后习题<br><img src="./117.png" alt="Alt text"></p>
<p>本想用上一题的方法，但发现本题的k可能大于链表长度，因此不可行，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#切成两段，前面一段，后面k个一段</span></span><br><span class="line">        <span class="comment">#然后将前面一段连接在k个一段的后面</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#因此需要先找到倒数第k个结点的前驱</span></span><br><span class="line">        </span><br><span class="line">        dummyHead=ListNode()</span><br><span class="line">        dummyHead.<span class="built_in">next</span>=head</span><br><span class="line"></span><br><span class="line">        slow=dummyHead</span><br><span class="line">        fast=head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            fast=fast.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast=fast.<span class="built_in">next</span></span><br><span class="line">            slow=slow.<span class="built_in">next</span></span><br><span class="line">        <span class="comment">#此时slow指向后一段的前驱</span></span><br><span class="line"></span><br><span class="line">        part2Head=slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span>=<span class="literal">None</span><span class="comment">#切断</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#找到后一段的尾巴结点</span></span><br><span class="line">        p=part2Head</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span>=dummyHead.<span class="built_in">next</span><span class="comment">#连起来</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> part2Head</span><br></pre></td></tr></table></figure>

<p>可以修改一下，k=length(head)%k</p>
<p>AC代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment">#求链表长度</span></span><br><span class="line">        length=<span class="number">0</span></span><br><span class="line">        q=head</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            length+=<span class="number">1</span></span><br><span class="line">            q=q.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> length==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment">#k可能大于length，</span></span><br><span class="line">        k=k%length</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#切成两段，前面一段，后面k个一段</span></span><br><span class="line">        <span class="comment">#然后将前面一段连接在k个一段的后面</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#因此需要先找到倒数第k个结点的前驱</span></span><br><span class="line">        </span><br><span class="line">        dummyHead=ListNode()</span><br><span class="line">        dummyHead.<span class="built_in">next</span>=head</span><br><span class="line"></span><br><span class="line">        slow=dummyHead</span><br><span class="line">        fast=head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            fast=fast.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast=fast.<span class="built_in">next</span></span><br><span class="line">            slow=slow.<span class="built_in">next</span></span><br><span class="line">        <span class="comment">#此时slow指向后一段的前驱</span></span><br><span class="line"></span><br><span class="line">        part2Head=slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span>=<span class="literal">None</span><span class="comment">#切断</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#找到后一段的尾巴结点</span></span><br><span class="line">        p=part2Head</span><br><span class="line"></span><br><span class="line">        <span class="comment">#p为空，说明第二段为空，因此不需要做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span>=dummyHead.<span class="built_in">next</span><span class="comment">#连起来</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> part2Head</span><br></pre></td></tr></table></figure>
<p><img src="./118.png" alt="Alt text"><br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>我自己的解法，按部就班来，官方也是这么做的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span>  head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment">#1. 先找到链表的中间结点</span></span><br><span class="line">        slow=head</span><br><span class="line">        fast=head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast=fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow=slow.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">#2. 中点前后切成两段子链表</span></span><br><span class="line">        part2Head=slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#3. 将第二段链表反转</span></span><br><span class="line">        p=part2Head</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">head</span>):</span></span><br><span class="line">            pre=<span class="literal">None</span></span><br><span class="line">            cur=head</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="built_in">next</span>=cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">                cur.<span class="built_in">next</span>=pre</span><br><span class="line"></span><br><span class="line">                pre=cur</span><br><span class="line">                cur=<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line">        part2Head=reverseList(p)</span><br><span class="line">   </span><br><span class="line">        <span class="comment">#4. 开一个新的结点，每一次分别从两个子链表中摘取第一个结点</span></span><br><span class="line">        newHead=ListNode()</span><br><span class="line">        p=newHead</span><br><span class="line">        <span class="comment">#奇数个结点时，第一段会多剩一个结点，直接连过去就好了</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">or</span> part2Head:</span><br><span class="line">            <span class="keyword">if</span> head:</span><br><span class="line">                p.<span class="built_in">next</span>=head</span><br><span class="line">                head=head.<span class="built_in">next</span></span><br><span class="line">                p=p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> part2Head:</span><br><span class="line">                p.<span class="built_in">next</span>=part2Head</span><br><span class="line">                part2Head=part2Head.<span class="built_in">next</span></span><br><span class="line">                p=p.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>此外 ，官方还提供了一种做法，不过此时需要开一个列表存储每一个结点，空间复杂度为O(n)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        vec = <span class="built_in">list</span>()</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            vec.append(node)</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(vec) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            vec[i].<span class="built_in">next</span> = vec[j]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            vec[j].<span class="built_in">next</span> = vec[i]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        vec[i].<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure>


<p><img src="./119.png" alt="Alt text"><br>进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p>能啊，和上题几乎一样，我直接写(在上一题的代码上复制+修改)出来了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span>  head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#1. 找到中间结点</span></span><br><span class="line">        slow=head</span><br><span class="line">        fast=head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast=fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow=slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#2. 以中间结点为切分点，将整个链表切分成两段</span></span><br><span class="line">        part2Head=slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#3. 对后一段链表进行反转</span></span><br><span class="line">        p=part2Head</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">head</span>):</span></span><br><span class="line">            pre=<span class="literal">None</span></span><br><span class="line">            cur=head</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="built_in">next</span>=cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">                cur.<span class="built_in">next</span>=pre</span><br><span class="line"></span><br><span class="line">                pre=cur</span><br><span class="line">                cur=<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line">        part2Head=reverseList(p)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#4. 两段链表逐个元素比较</span></span><br><span class="line">        <span class="comment">#即使结点个数为奇数也没关系，用and，忽略剩余的一个元素即可</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> part2Head:</span><br><span class="line">            <span class="keyword">if</span> head.val!=part2Head.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            head=head.<span class="built_in">next</span></span><br><span class="line">            part2Head=part2Head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>比较直接的，但空间复杂度为O(n)的做法，是将值存入列表，然后判断lis等不等于lis[::-1]：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        vals = []</span><br><span class="line">        current_node = head</span><br><span class="line">        <span class="keyword">while</span> current_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            vals.append(current_node.val)</span><br><span class="line">            current_node = current_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> vals == vals[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="第六章、栈和队列"><a href="#第六章、栈和队列" class="headerlink" title="第六章、栈和队列"></a>第六章、栈和队列</h1><h2 id="6-1"><a href="#6-1" class="headerlink" title="6-1"></a>6-1</h2><p><img src="./120.png" alt="Alt text"></p>
<p>我根据视频解法写的Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> <span class="string">&#x27;(&#123;[&#x27;</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">            <span class="comment">#ch in &#x27;)]&#125;&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> ch ==<span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    match=<span class="string">&#x27;(&#x27;</span></span><br><span class="line">                <span class="keyword">elif</span> ch==<span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    match=<span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line">                <span class="keyword">elif</span> ch==<span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                    match=<span class="string">&#x27;[&#x27;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">#比如&#x27;&#123;&#123;&#125;&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack)==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                cur=stack.pop()</span><br><span class="line">                <span class="keyword">if</span> cur!=match:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack)!=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>           </span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中 n 是字符串 s 的长度。</p>
<p>空间复杂度：O(n+∣Σ∣)其中 Σ\SigmaΣ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣=6|。栈中的字符数量为 O(n),而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。</p>
<p>课后习题<br><img src="./121.png" alt="Alt text"></p>
<p>我的解法：</p>
<p>遇到数字就入栈，否则遇到操作数弹出两个元素，执行运损，再把结果入栈。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="comment">#是数字，则入栈</span></span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;+-*/&#x27;</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(ch))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#是运算符，则取出栈中前两个数字，执行操作，再把操作结果压入栈中</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a=stack.pop()</span><br><span class="line">                b=stack.pop()</span><br><span class="line">                <span class="keyword">if</span> ch==<span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    res=a+b</span><br><span class="line">                <span class="keyword">elif</span> ch==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    res=b-a</span><br><span class="line">                <span class="keyword">elif</span> ch==<span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    res=a*b</span><br><span class="line">                <span class="keyword">elif</span> ch==<span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    res=<span class="built_in">int</span>(b/a)<span class="comment">#注意Python遇到负数除法时会跟题目不一致，因此这里不能直接用b//a</span></span><br><span class="line">                stack.append(res)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure>

<p><img src="./122.png" alt="Alt text"></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：path = &quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：path = &quot;/../&quot;</span><br><span class="line">输出：&quot;/&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：path = &quot;/home//foo/&quot;</span><br><span class="line">输出：&quot;/home/foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：path = &quot;/a/./b/../../c/&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br></pre></td></tr></table></figure>
<p>评论区答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">self, path</span>):</span></span><br><span class="line">        stack = []</span><br><span class="line">        all_chs=path.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> all_chs:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> p == <span class="string">&#x27;..&#x27;</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">elif</span> p <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot; ..&quot;</span>:</span><br><span class="line">                stack.append(p)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;/&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure>
<p>split妙啊~~</p>
<h2 id="6-2"><a href="#6-2" class="headerlink" title="6-2"></a>6-2</h2><p>栈与递归。</p>
<p>以二叉树的遍历为例：</p>
<p><img src="./123.png" alt="Alt text"></p>
<p>递归需要系统栈。</p>
<p>可以手动栈代替系统栈，将递归转为非递归。</p>
<h2 id="6-3"><a href="#6-3" class="headerlink" title="6-3"></a>6-3</h2><p>非递归实现二叉树遍历。</p>
<p>用栈。</p>
<p><strong>1. 前序遍历</strong></p>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                f(root.left)</span><br><span class="line">                f(root.right)</span><br><span class="line">        f(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p>
<p>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(log⁡n)，最坏情况下树呈现链状，为 O(n)。</p>
<p>非递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack=[root]</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node=stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>非递归解法2：模板解法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res=[]</span><br><span class="line">        stack=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root=root.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            t=stack.pop()</span><br><span class="line">            r=t.right</span><br><span class="line">            <span class="keyword">while</span> r:</span><br><span class="line">                res.append(r.val)</span><br><span class="line">                stack.append(r)</span><br><span class="line">                r=r.left</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<p><strong>2. 中序遍历</strong></p>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                f(root.left)</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                f(root.right)</span><br><span class="line">        f(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>非递归 模板解法：</p>
<p>前序遍历中，入栈前就访问元素</p>
<p>中序遍历中，出栈时才访问元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res=[]</span><br><span class="line">        stack=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line"></span><br><span class="line">            stack.append(root)</span><br><span class="line">            root=root.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            t=stack.pop()</span><br><span class="line">            res.append(t.val)<span class="comment">#访问</span></span><br><span class="line">            r=t.right</span><br><span class="line">            <span class="keyword">while</span> r:</span><br><span class="line">                stack.append(r)</span><br><span class="line">                r=r.left</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><strong>3. 后序遍历</strong></p>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                f(root.left)</span><br><span class="line">                f(root.right)</span><br><span class="line">                res.append(root.val)</span><br><span class="line">        f(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<p>非递归 模板解法：</p>
<p>前序遍历：根 左 右</p>
<p>后序遍历：左 右 根</p>
<p>后序遍历的逆序：根 右 左</p>
<p>因此，可以直接拿前序遍历的代码，改一下左右子树的访问顺序即可，最后返回结果的逆序，就是后序遍历的结果啦：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res=[]</span><br><span class="line">        stack=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            res.append(root.val)<span class="comment">#访问</span></span><br><span class="line">            stack.append(root)</span><br><span class="line">            root=root.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            t=stack.pop()</span><br><span class="line">            r=t.left</span><br><span class="line">            <span class="keyword">while</span> r:</span><br><span class="line">                res.append(r.val)<span class="comment">#访问</span></span><br><span class="line">                stack.append(r)</span><br><span class="line">                r=r.right</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>总结：前序和中序的区别就在于前者是入栈时访问，而后者是出栈时才访问；后序可借助前序得到，只需更改一下左右结点入栈顺序。</p>
<p>课后习题<br><img src="./124.png" alt="Alt text"></p>
<p><img src="./125.png" alt="Alt text"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/solution/fu-xue-ming-zhu-xiang-jie-ti-yi-shu-li-d-n4qa/">https://leetcode-cn.com/problems/flatten-nested-list-iterator/solution/fu-xue-ming-zhu-xiang-jie-ti-yi-shu-li-d-n4qa/</a></p>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, nests</span>):</span></span><br><span class="line">        <span class="keyword">for</span> nest <span class="keyword">in</span> nests:</span><br><span class="line">            <span class="keyword">if</span> nest.isInteger():</span><br><span class="line">                self.queue.append(nest.getInteger())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.dfs(nest.getList())</span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nestedList</span>):</span></span><br><span class="line">        self.queue = collections.deque()</span><br><span class="line">        self.dfs(nestedList)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue)</span><br></pre></td></tr></table></figure>

<p>非递归：栈</p>
<p>在递归方法中，我们在遍历时如果遇到一个嵌套的 子list，就立即处理该 子list，直到全部展开；</p>
<p>在迭代方法中，我们不需要全部展开，只需要把 当前list 的所有元素放入 list 中。</p>
<p>算法整体的流程，通过举例说明。假如输入 [1, [2,3]] 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 在构造函数中：栈里面放的应该是 stack = [[2, 3], 1]</span><br><span class="line">2. 在调用 hasNext() 方法时，访问栈顶元素是 1，为 int，那么直接返回 true;</span><br><span class="line">3. 然后调用 next() 方法，弹出栈顶元素 1；</span><br><span class="line">4. 再调用 hasNext() 方法时，访问栈顶元素是 [2,3]，为 list，那么需要摊平，继续放到栈中。</span><br><span class="line">        当前的栈是 stack = [3, 2]</span><br><span class="line">5. 然后调用 next() 方法，弹出栈顶元素 2；</span><br><span class="line">6. 然后调用 next() 方法，弹出栈顶元素 3；</span><br><span class="line">7. 再调用 hasNext() 方法时，栈为空，因此返回 false，迭代器运行结束。</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"># You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"># &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#class NestedInteger:</span></span><br><span class="line"><span class="comment">#    def isInteger(self) -&gt; bool:</span></span><br><span class="line"><span class="comment">#        &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#        @return True if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment">#        &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    def getInteger(self) -&gt; int:</span></span><br><span class="line"><span class="comment">#        &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#        @return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment">#        Return None if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment">#        &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    def getList(self) -&gt; [NestedInteger]:</span></span><br><span class="line"><span class="comment">#        &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#        @return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment">#        Return None if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment">#        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nestedList</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nestedList) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            self.stack.append(nestedList[i])</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.stack.pop()</span><br><span class="line">        <span class="keyword">return</span> cur.getInteger()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.stack:</span><br><span class="line">            cur = self.stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> cur.isInteger():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            self.stack.pop()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cur.getList()) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                self.stack.append(cur.getList()[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># i, v = NestedIterator(nestedList), []</span></span><br><span class="line"><span class="comment"># while i.hasNext(): v.append(i.next())</span></span><br></pre></td></tr></table></figure>

<h2 id="6-4"><a href="#6-4" class="headerlink" title="6-4"></a>6-4</h2><p>队列。</p>
<p>树的BFS。</p>
<p><img src="./126.png" alt="Alt text"></p>
<p><img src="./127.png" alt="Alt text"></p>
<p>可以DFS也可以BFS，这里用BFS，借助队列先进先出的特性。</p>
<p>评论区答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">		<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">		:type root: TreeNode</span></span><br><span class="line"><span class="string">		:rtype: List[List[int]]</span></span><br><span class="line"><span class="string">		&quot;&quot;&quot;</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">			<span class="keyword">return</span> []</span><br><span class="line">		res = []</span><br><span class="line">		queue = [root]</span><br><span class="line">		<span class="keyword">while</span> queue:</span><br><span class="line">			<span class="comment"># 获取当前队列的长度，这个长度相当于 当前这一层的节点个数</span></span><br><span class="line">			size = <span class="built_in">len</span>(queue)</span><br><span class="line">			tmp = []</span><br><span class="line">			<span class="comment"># 将队列中的元素都拿出来(也就是获取这一层的节点)，放到临时list中</span></span><br><span class="line">			<span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span></span><br><span class="line">			<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">				r = queue.pop(<span class="number">0</span>)</span><br><span class="line">				tmp.append(r.val)</span><br><span class="line">				<span class="keyword">if</span> r.left:</span><br><span class="line">					queue.append(r.left)</span><br><span class="line">				<span class="keyword">if</span> r.right:</span><br><span class="line">					queue.append(r.right)</span><br><span class="line">			<span class="comment"># 将临时list加入最终返回结果中</span></span><br><span class="line">			res.append(tmp)</span><br><span class="line">		<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>时间复杂度： O(n)</p>
<p>空间复杂度：O(n)</p>
<p>这类题有模板，请牢记：</p>
<p><img src="./131.png" alt="Alt text"></p>
<p>由于需要level，因此这里需要使用模板2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="comment">#不能删！！因为加入的可能是None，也就是左or右孩子为空也加入了</span></span><br><span class="line">                <span class="comment">#还有，也处理了本身root就是空的情况</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                queue.append(cur.left)</span><br><span class="line">                queue.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> level:</span><br><span class="line">                res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>如果想和上一个代码统一，可以改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">  </span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> level:</span><br><span class="line">                res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>只是把list换成了deque，别的代码是一样的。</p>
<p>DFS解法暂时不看了。</p>
<p>课后习题<br><img src="./128.png" alt="Alt text"><br>直接再上题的基础上，最后逆序返回res，即res[::-1]就好了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">  </span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> level:</span><br><span class="line">                res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>


<p><img src="./129.png" alt="Alt text"></p>
<p>还是基于之前的代码，将根节点所在层视为第0层，判断当前层是奇数层还是偶数层，偶数层则从左往右，奇数层则从右往左。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        cnt=<span class="number">0</span><span class="comment">#层的奇偶，偶数：从左往右；奇数：从右往左(逆序即可)，根节点所在层为第0层</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur=queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> level:</span><br><span class="line">                <span class="keyword">if</span> cnt%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                    res.append(level)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(level[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><img src="./130.png" alt="Alt text"></p>
<p>层序遍历，还是基于上述代码，只需要获取每一层的最一个结点值就好了(我怎么一开始就没想到。。。)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> level:</span><br><span class="line">                res.append(level[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="6-5（好难哦）"><a href="#6-5（好难哦）" class="headerlink" title="6-5（好难哦）"></a>6-5（好难哦）</h2><p>队列。</p>
<p>(无权)图的BFS。</p>
<p><img src="./132.png" alt="Alt text"></p>
<p><img src="./133.png" alt="Alt text"></p>
<p><img src="./134.png" alt="Alt text"></p>
<p>评论区Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        deq=deque()</span><br><span class="line">        visited=<span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        deq.append((n,<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> deq:</span><br><span class="line">            number,step=deq.popleft()</span><br><span class="line">            targets=[number-i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">int</span>(number**<span class="number">0.5</span>)+<span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">for</span> target <span class="keyword">in</span> targets:</span><br><span class="line">                <span class="comment">#由于只遍历到(number**0.5)，因此target不可能为负数，因此下面这个判断可省略</span></span><br><span class="line">                <span class="comment">#if target&lt;0:</span></span><br><span class="line">                <span class="comment">#    break</span></span><br><span class="line">                <span class="keyword">if</span> target==<span class="number">0</span>:<span class="keyword">return</span> step+<span class="number">1</span></span><br><span class="line">                <span class="comment">#这个if相当于剪枝</span></span><br><span class="line">                <span class="keyword">if</span> target <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    deq.append((target,step+<span class="number">1</span>))</span><br><span class="line">                    visited.add(target)</span><br></pre></td></tr></table></figure>
<p>图示很清楚了：</p>
<p><img src="./135.png" alt="Alt text"></p>
<p>看代码勉强看得懂，自己还真想不到，还得多练啊！</p>
<p>Note：</p>
<ul>
<li><p>对于无权图-&gt;可以BFS，就像本题</p>
</li>
<li><p>对于有权图-&gt;迪杰斯塔拉，遇到再说吧</p>
</li>
</ul>
<p>课后习题<br><img src="./136.png" alt="Alt text"></p>
<p><img src="./137.png" alt="Alt text"></p>
<p><img src="./138.png" alt="Alt text"></p>
<p><img src="./139.png" alt="Alt text"></p>
<p>不想做，都是困难题。。。</p>
<h2 id="6-6，6-7"><a href="#6-6，6-7" class="headerlink" title="6-6，6-7"></a>6-6，6-7</h2><p>优先队列：底层是堆</p>
<p><img src="./140.png" alt="Alt text"></p>
<p>用优先队列解题：<br><img src="./141.png" alt="Alt text"><br><img src="./142.png" alt="Alt text"></p>
<p><img src="./144.png" alt="Alt text"><br><img src="./143.png" alt="Alt text"></p>
<p><img src="./147.png" alt="Alt text"></p>
<p>评论区Python版本，使用heapq库，维护一个长度为k的小根堆：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#时间复杂度：O(nlogk)</span></span><br><span class="line"><span class="comment">#空间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self,nums, k</span>):</span></span><br><span class="line">        <span class="comment">#要统计元素出现频率</span></span><br><span class="line">        map_ = &#123;&#125; <span class="comment">#nums[i]:对应出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            map_[nums[i]] = map_.get(nums[i], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(map_)</span><br><span class="line">        <span class="comment">#对频率排序</span></span><br><span class="line">        <span class="comment">#定义一个小顶堆，大小为k</span></span><br><span class="line">        pri_que = [] <span class="comment">#小顶堆     </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#用固定大小为k的小顶堆，扫描所有频率的数值</span></span><br><span class="line">        <span class="keyword">for</span> key, freq <span class="keyword">in</span> map_.items():</span><br><span class="line">            heapq.heappush(pri_que, (freq, key))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(pri_que) &gt; k: <span class="comment">#如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">                heapq.heappop(pri_que)<span class="comment">#出现次数最少的出队(优先级最高~~)</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒叙来输出到数组#用不到额</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            result.append( heapq.heappop(pri_que)[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><img src="./145.png" alt="Alt text"></p>
<p>课后习题<br><img src="./146.png" alt="Alt text"></p>
<p><img src="./148.png" alt="Alt text"></p>
<p>评论区Python使用优先队列的解法，赞！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lists)==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lists)==<span class="number">1</span>: <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">        head=ListNode() </span><br><span class="line">        h = head</span><br><span class="line">        que = []</span><br><span class="line">        <span class="comment"># 初始化que</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">            <span class="keyword">if</span> lists[i]:</span><br><span class="line">                heapq.heappush(que, (lists[i].val,i))</span><br><span class="line">        <span class="comment"># 逐次弹出最小的 加入新元素</span></span><br><span class="line">        <span class="keyword">while</span> que :</span><br><span class="line">            <span class="comment"># 加入最小的</span></span><br><span class="line">            val_min, ind_min = heapq.heappop(que)</span><br><span class="line">            h.<span class="built_in">next</span> = ListNode(val_min)</span><br><span class="line">            h=h.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 被添加元素所在链表后移</span></span><br><span class="line">            lists[ind_min] = lists[ind_min].<span class="built_in">next</span></span><br><span class="line">            <span class="comment">#若被添加元素所在链表还不为空，就继续把它的剩余部分加入优先队列</span></span><br><span class="line">            <span class="keyword">if</span> lists[ind_min]: </span><br><span class="line">                heapq.heappush(que, (lists[ind_min].val, ind_min))</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>还有一种同时可以应对无序场景，此时将全部元素加入优先队列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists <span class="keyword">or</span> <span class="built_in">len</span>(lists) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="comment"># 首先 for 嵌套 while 就是将所有元素都取出放入堆中</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                heapq.heappush(heap, node.val)</span><br><span class="line">                node = node.<span class="built_in">next</span></span><br><span class="line">        dummy = ListNode(<span class="literal">None</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="comment"># 依次将堆中的元素取出(因为是小顶堆，所以每次出来的都是目前堆中值最小的元素），然后重新构建一个列表返回</span></span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            temp_node = ListNode(heappop(heap))</span><br><span class="line">            cur.<span class="built_in">next</span> = temp_node</span><br><span class="line">            cur = temp_node</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>还有一种暴力法，直接去除全部元素，排序，加入链表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists <span class="keyword">or</span> <span class="built_in">len</span>(lists) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        all_vals = []</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> l:</span><br><span class="line">                all_vals.append(l.val)</span><br><span class="line">                l = l.<span class="built_in">next</span></span><br><span class="line">        all_vals.sort()</span><br><span class="line">        dummy = ListNode(<span class="literal">None</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> all_vals:</span><br><span class="line">            temp_node = ListNode(i)</span><br><span class="line">            cur.<span class="built_in">next</span> = temp_node</span><br><span class="line">            cur = temp_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h1 id="第七章：递归"><a href="#第七章：递归" class="headerlink" title="第七章：递归"></a>第七章：递归</h1><h2 id="7-1"><a href="#7-1" class="headerlink" title="7-1"></a>7-1</h2><p><img src="./149.png" alt="Alt text"></p>
<p><img src="./150.png" alt="Alt text"></p>
<p><img src="./151.png" alt="Alt text"></p>
<p><img src="./152.png" alt="Alt text"></p>
<p><img src="./153.png" alt="Alt text"></p>
<p>Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_maxdepth=self.maxDepth(root.left)</span><br><span class="line">        right_maxdepth=self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(left_maxdepth,right_maxdepth)</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。</p>
<p>空间复杂度：O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p>
<p>也可以用BFS，直接统计最大深度.</p>
<p>我根据之前的二叉树BFS代码改的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 获取当前队列的长度，这个长度相当于 当前这一层的节点个数</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                r = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> r.left:</span><br><span class="line">                    queue.append(r.left)</span><br><span class="line">                <span class="keyword">if</span> r.right:</span><br><span class="line">                    queue.append(r.right)</span><br><span class="line">            res+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。</p>
<p>空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</p>
<p>课后习题<br><img src="./154.png" alt="Alt text"></p>
<p>我的解法：</p>
<p>在上一题中，求的是根结点到叶子节点的最大深度，如果根结点有一个子树为空，那么改子树的最大深度是0，是最小的，此时结果就依赖于另外一个非空子树的最大深度，该深度肯定大于0的。</p>
<p>而这里求的是根结点到叶子最小的深度，此时如果根结点的某一个子树为空，那么如果和上题代码一样，只是把max改成min，那么为空的子树得到的结果是0，但非空的子树是有叶子结点的，此时用min的话就错误的以为是空子树得到的0了，然而非空子树的对应结果才是正确的。</p>
<p>因此需要改一下代码，判断左右子树是否为空，3种情况分别对症下药：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">            left_mindepth=self.minDepth(root.left)</span><br><span class="line">            right_min_depth=self.minDepth(root.right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">min</span>(left_mindepth,right_min_depth)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> root.left:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+self.minDepth(root.right)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+self.minDepth(root.left)</span><br></pre></td></tr></table></figure>

<p>评论区还有BFS的方案：利用BFS实现二叉树的层序遍历，第一个遇到的叶子结点就是树的最小深度。</p>
<p>我根据之前的二叉树BFS代码改的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 获取当前队列的长度，这个长度相当于 当前这一层的节点个数</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                r = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment">#第一个访问到的叶子结点所在层数就是答案~</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> r.left <span class="keyword">and</span> <span class="keyword">not</span> r.right:</span><br><span class="line">                    <span class="keyword">return</span> res+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> r.left:</span><br><span class="line">                    queue.append(r.left)</span><br><span class="line">                <span class="keyword">if</span> r.right:</span><br><span class="line">                    queue.append(r.right)</span><br><span class="line">            res+=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="7-2"><a href="#7-2" class="headerlink" title="7-2"></a>7-2</h2><p><img src="./155.png" alt="Alt text"></p>
<p><img src="./156.png" alt="Alt text"></p>
<p>我改成Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line"></span><br><span class="line">        root.left,root.right=root.right,root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>或者多加一句判断，但我不知道这是否多余，不知道能不能起到什么作用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment">#emm，这句是否多余呢？</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line"></span><br><span class="line">        root.left,root.right=root.right,root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)，其中 N 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。</p>
<p>空间复杂度：O(N)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(log⁡N)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。</p>
<p>也可以用二叉树的BFS：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="comment">#以下两种写法都可以</span></span><br><span class="line">            <span class="comment">#return</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 获取当前队列的长度，这个长度相当于 当前这一层的节点个数</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                r = queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                r.left,r.right=r.right,r.left<span class="comment">#swap</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> r.left:</span><br><span class="line">                    queue.append(r.left)</span><br><span class="line">                <span class="keyword">if</span> r.right:</span><br><span class="line">                    queue.append(r.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>课后习题<br><img src="./157.png" alt="Alt text"><br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>DFS：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> p) <span class="keyword">and</span> (<span class="keyword">not</span> q):<span class="comment">#全空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> (<span class="keyword">not</span> p) <span class="keyword">or</span> (<span class="keyword">not</span> q):<span class="comment">#只有一个为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#都不为空</span></span><br><span class="line">        <span class="keyword">elif</span> p.val !=q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br></pre></td></tr></table></figure>

<p>我写的BFS：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment">#都为空--&gt;相同</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment">#只有一个为空--&gt;不相同</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#用两个队列分别存储两棵树的BFS结果</span></span><br><span class="line">        queue1 = [p]</span><br><span class="line">        queue2=[q]</span><br><span class="line">        <span class="keyword">while</span> queue1 <span class="keyword">and</span> queue2:<span class="comment"># 用and 或 or都可以，只写while queue1或者while queue2也可以~</span></span><br><span class="line">            <span class="comment"># 获取当前队列的长度，这个长度相当于 当前这一层的节点个数</span></span><br><span class="line">            size1 = <span class="built_in">len</span>(queue1)</span><br><span class="line">            size2 = <span class="built_in">len</span>(queue2)</span><br><span class="line">            <span class="comment">#同一层的结点个数不同--&gt;不相同</span></span><br><span class="line">            <span class="keyword">if</span> size1!=size2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size1):</span><br><span class="line">                r1 = queue1.pop(<span class="number">0</span>)</span><br><span class="line">                r2=queue2.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment">#只有一个为空--&gt;不相同</span></span><br><span class="line">                <span class="keyword">if</span> (r1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> r2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">or</span> (r2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> r1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment">#都为空--&gt;当前结点相同，继续出队下一个结点做判断</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> r1 <span class="keyword">and</span> <span class="keyword">not</span> r2:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">#都不为空--&gt;结构相同，则比较值</span></span><br><span class="line">                <span class="keyword">if</span> r1 <span class="keyword">and</span> r2 <span class="keyword">and</span> (r1.val!=r2.val):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">                queue1.append(r1.left)</span><br><span class="line">                queue1.append(r1.right)</span><br><span class="line"></span><br><span class="line">                queue2.append(r2.left)</span><br><span class="line">                queue2.append(r2.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>官方题解先判断值是都相同，并且没有将None结点入队：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        queue1 = collections.deque([p])</span><br><span class="line">        queue2 = collections.deque([q])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue1 <span class="keyword">and</span> queue2:</span><br><span class="line">            node1 = queue1.popleft()</span><br><span class="line">            node2 = queue2.popleft()</span><br><span class="line">            <span class="keyword">if</span> node1.val != node2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            left1, right1 = node1.left, node1.right</span><br><span class="line">            left2, right2 = node2.left, node2.right</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> left1) ^ (<span class="keyword">not</span> left2):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> right1) ^ (<span class="keyword">not</span> right2):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> left1:</span><br><span class="line">                queue1.append(left1)</span><br><span class="line">            <span class="keyword">if</span> right1:</span><br><span class="line">                queue1.append(right1)</span><br><span class="line">            <span class="keyword">if</span> left2:</span><br><span class="line">                queue2.append(left2)</span><br><span class="line">            <span class="keyword">if</span> right2:</span><br><span class="line">                queue2.append(right2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> queue1 <span class="keyword">and</span> <span class="keyword">not</span> queue2</span><br></pre></td></tr></table></figure>

<p><img src="./158.png" alt="Alt text"><br>DFS:</p>
<p>官方：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment">#我自己加了个判断条件，貌似快了跟多</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">p,q</span>):</span></span><br><span class="line">            <span class="comment">#树为空--&gt;对称</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment">#此时只有左子树或右子树不为空--&gt;不对称</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> p) <span class="keyword">or</span>  (<span class="keyword">not</span> q):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> p.val ==q.val <span class="keyword">and</span> check(p.left,q.right) <span class="keyword">and</span> check(p.right,q.left)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> check(root,root)</span><br></pre></td></tr></table></figure>
<p>评论区BFS解法(tql…)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">		<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">		:type root: TreeNode</span></span><br><span class="line"><span class="string">		:rtype: bool</span></span><br><span class="line"><span class="string">		&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#空树 or 树只有一个结点而无左右孩子--&gt;对称</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> <span class="keyword">not</span> (root.left <span class="keyword">or</span> root.right):</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">		<span class="comment"># 用队列保存节点	</span></span><br><span class="line">		queue = [root.left,root.right]</span><br><span class="line">		<span class="keyword">while</span> queue:</span><br><span class="line">			<span class="comment"># 从队列中取出两个节点，再比较这两个节点</span></span><br><span class="line">			left = queue.pop(<span class="number">0</span>)</span><br><span class="line">			right = queue.pop(<span class="number">0</span>)</span><br><span class="line">			<span class="comment"># 两个节点都为空--&gt;继续循环，出队新的两个元素</span></span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">or</span> right):</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 两者只有一个为空--&gt;不对称</span></span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">and</span> right):</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 此时两者都不为空，但值不同--&gt;不对称</span></span><br><span class="line">			<span class="keyword">if</span> left.val!=right.val:</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">			<span class="comment"># 将左节点的左孩子， 右节点的右孩子放入队列</span></span><br><span class="line">			queue.append(left.left)</span><br><span class="line">			queue.append(right.right)</span><br><span class="line">			<span class="comment"># 将左节点的右孩子，右节点的左孩子放入队列</span></span><br><span class="line">			queue.append(left.right)</span><br><span class="line">			queue.append(right.left)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><img src="./160.png" alt="Alt text"><br>DFS:</p>
<p>我写了一半多吧，最后忘了写递归判断左右子树，于是参考了下题解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment">#空树--&gt;是平衡二叉树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cal_depth</span>(<span class="params">p</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(cal_depth(p.left),cal_depth(p.right))</span><br><span class="line">        </span><br><span class="line">        left_depth=cal_depth(root.left)</span><br><span class="line">        right_depth=cal_depth(root.right)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(left_depth-right_depth)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure>
<p><img src="./161.png" alt="Alt text"></p>
<p>思路是构造一个获取当前节点最大深度的方法 depth(root) ，通过比较此子树的左右子树的最大高度差abs(depth(root.left) - depth(root.right))，来判断此子树是否是二叉平衡树。若树的所有子树都平衡时，此树才平衡。</p>
<p>从官方那里了解到，这种方法叫做<strong>自顶向下的递归</strong>:</p>
<p>类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。</p>
<p>既然有自顶向下的递归，那就有<strong>自底向上</strong>的递归：</p>
<p>自顶向下递归，对于同一个节点，函数 cal_depth会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数 cal_depth只会被调用一次。</p>
<p>具体的思路是对二叉树做后序遍历，从底至顶返回子树最大高度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</p>
<p>大佬的代码：</p>
<p><img src="./162.png" alt="Alt text"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.recur(root) != -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#左子树深度</span></span><br><span class="line">        left = self.recur(root.left)</span><br><span class="line">        <span class="keyword">if</span> left == -<span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">#右子树深度</span></span><br><span class="line">        right = self.recur(root.right)</span><br><span class="line">        <span class="keyword">if</span> right == -<span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">abs</span>(left - right) &lt; <span class="number">2</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p><img src="./159.png" alt="Alt text"></p>
<p>这题我上来就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+self.countNodes(root.left)+self.countNodes(root.right)</span><br></pre></td></tr></table></figure>
<p>此时的时间/空间复杂度都是O(n).</p>
<p>如何优化呢？</p>
<p>题目中的树是完全二叉树，所以可以利用完全二叉树的性质来优化时间复杂度。</p>
<p><img src="./163.png" alt="Alt text"></p>
<p><img src="./164.png" alt="Alt text"></p>
<p>可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。</p>
<p>大佬的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment">#利用：根结点的深度为1，满二叉树的结点数公式：2^满二叉树数深度-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = root.left</span><br><span class="line">        right = root.right</span><br><span class="line"></span><br><span class="line">        rightHeight = <span class="number">0</span></span><br><span class="line">        leftHeight=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#以下求树的深度用到了完全二叉树的性质</span></span><br><span class="line">        <span class="keyword">while</span> left: <span class="comment">#求左子树深度</span></span><br><span class="line">            left = left.left</span><br><span class="line">            leftHeight += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right: <span class="comment">#求右子树深度</span></span><br><span class="line">            right = right.right</span><br><span class="line">            rightHeight += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(leftHeight,rightHeight)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        2 1</span></span><br><span class="line"><span class="string">        1 1</span></span><br><span class="line"><span class="string">        1 0</span></span><br><span class="line"><span class="string">        0 0</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#如果左右子树的深度相等，则说明以该结点为根的子树是一棵满二叉树</span></span><br><span class="line">        <span class="comment">#此时直接用2^树深度-1求解子树结点个数即可</span></span><br><span class="line">        <span class="keyword">if</span> leftHeight == rightHeight:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;dd&#x27;</span>,leftHeight)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span>**(leftHeight+<span class="number">1</span>)) - <span class="number">1</span> <span class="comment">#加1是因为这里的height是子树的深度，而我们需要得到有根结点的树的深度，所以深度加1</span></span><br><span class="line">        <span class="keyword">return</span> self.countNodes(root.left) + self.countNodes(root.right) + <span class="number">1</span>       </span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn * logn)，比O(n)快很多~</p>
<p>空间复杂度：O(logn)</p>
<p>我只能膜拜了，大佬太强了~~</p>
<h2 id="7-3"><a href="#7-3" class="headerlink" title="7-3"></a>7-3</h2><p>注意递归终止条件。</p>
<p><img src="./165.png" alt="Alt text"></p>
<p><img src="./166.png" alt="Alt text"></p>
<p>Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment">#root为空--&gt;找不到</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#root是叶子结点--&gt;判断root.val是否等于targetSum</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> root.val==targetSum</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left,targetSum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right,targetSum-root.val)</span><br></pre></td></tr></table></figure>

<p>评论区BFS解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        que = collections.deque()</span><br><span class="line">        que.append((root, root.val))</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            <span class="comment">#结点，结点值(从根结点一路向下累加的值)</span></span><br><span class="line">            node, cusum = que.popleft()</span><br><span class="line">            <span class="comment">#如果是叶子节点，并且这个叶子结点的值等于sum--&gt;找到啦</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> cusum == <span class="built_in">sum</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                que.append((node.left, cusum + node.left.val))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                que.append((node.right, cusum+ node.right.val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>上面的队列也可以替换成栈，此时不再是BFS了，因为结点访问顺序变了，但代码一模一样：<br><img src="./168.png" alt="Alt text"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root, <span class="built_in">sum</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type sum: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack = []</span><br><span class="line">        stack.append((root, root.val))</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, path = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> path == <span class="built_in">sum</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, path + node.left.val))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, path + node.right.val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>还有回溯法，等学完下一章回溯法再来看：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-de-si-chong-jie-fa-dfs-hui-su-bfs-/">https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-de-si-chong-jie-fa-dfs-hui-su-bfs-/</a></p>
<p>课后习题</p>
<p><img src="./167.png" alt="Alt text"><br>如果左节点不为空，且左节点没有左右孩子，那么这个节点就是左叶子</p>
<p>我一开始写成了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="comment">#root为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    leftNode=root.left</span><br><span class="line">    <span class="comment">#root的左孩子是叶子结点</span></span><br><span class="line">    <span class="keyword">if</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> leftNode.left <span class="keyword">and</span> <span class="keyword">not</span> leftNode.right:</span><br><span class="line">        <span class="keyword">return</span> leftNode.val</span><br><span class="line">    <span class="keyword">return</span> self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)</span><br></pre></td></tr></table></figure>
<p>这是不对的！</p>
<p>当遍历到的root的左孩子是叶子结点时，应该暂时将其保存起来，在最后累计返回</p>
<p>看了大佬的题解后修改的正确代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment">#root为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftNode=root.left</span><br><span class="line">        val=<span class="number">0</span><span class="comment">#存储root的左孩子的值，默认leftNode不是左孩子，此时值为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#如果root的左孩子leftNode是叶子结点，就更新val</span></span><br><span class="line">        <span class="keyword">if</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> leftNode.left <span class="keyword">and</span> <span class="keyword">not</span> leftNode.right:</span><br><span class="line">            val=leftNode.val</span><br><span class="line">        <span class="keyword">return</span> val+self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)</span><br></pre></td></tr></table></figure>
<p>或者下面这样写语义更清楚：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment">#root为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        leftNode=root.left<span class="comment">#root的左孩子</span></span><br><span class="line">        <span class="comment">#如果root的左孩子leftNode是叶子结点</span></span><br><span class="line">        <span class="keyword">if</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> leftNode.left <span class="keyword">and</span> <span class="keyword">not</span> leftNode.right:</span><br><span class="line">            val=leftNode.val<span class="comment">#存储root的左孩子（是个叶子结点）的值</span></span><br><span class="line">            <span class="keyword">return</span> val+self.sumOfLeftLeaves(root.right)<span class="comment">#左孩子已经处理好了，只需递归处理右孩子</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)<span class="comment">#递归处理左右孩子</span></span><br></pre></td></tr></table></figure>

<p>有了上面的思考过程，我自己写出了下面的BFS代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment">#root为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        queue=[root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            r=queue.pop(<span class="number">0</span>)</span><br><span class="line">            leftNode=r.left</span><br><span class="line">            <span class="comment">#当前访问的结点r的左孩子是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> leftNode.left <span class="keyword">and</span> <span class="keyword">not</span> leftNode.right:</span><br><span class="line">                res+=leftNode.val</span><br><span class="line">            <span class="keyword">if</span> r.left:</span><br><span class="line">                queue.append(r.left)</span><br><span class="line">            <span class="keyword">if</span> r.right:</span><br><span class="line">                queue.append(r.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="7-4"><a href="#7-4" class="headerlink" title="7-4"></a>7-4</h2><p><img src="./169.png" alt="Alt text"></p>
<p><img src="./170.png" alt="Alt text"></p>
<p>Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="comment">#空结点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res=[]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#如果root是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            res.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        left_paths=self.binaryTreePaths(root.left)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> left_paths:</span><br><span class="line">            res.append((<span class="built_in">str</span>(root.val)+<span class="string">&#x27;-&gt;&#x27;</span>+s))</span><br><span class="line"></span><br><span class="line">        right_paths=self.binaryTreePaths(root.right)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> right_paths:</span><br><span class="line">            res.append(<span class="built_in">str</span>(root.val)+<span class="string">&#x27;-&gt;&#x27;</span>+s)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>牛蛙牛蛙，我想不到~~</p>
<p>走一遍就能理解了，注意left_path中的每一个元素都是形如’1-&gt;2’的字符串：这种字符串<strong>从下往上</strong>，一点一点变长（刚开始只有叶子结点，后来加入叶子节点的父结点，直到往上走到根结点）。</p>
<p>评论区大佬的BFS：先写叶子结点，从后往前拼接字符串得到路径（和递归方法思路一致）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root</span>):</span>	</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># res是最终结果集，queue中存放的是封装的[节点,临时路径]    </span></span><br><span class="line">        res = []</span><br><span class="line">        queue = [[root,<span class="string">&quot;&quot;</span>]]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node,tmp = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果当前节点是叶子节点，将其拼装后放入最终结果集中    </span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">and</span> <span class="keyword">not</span> (node.left <span class="keyword">or</span> node.right):</span><br><span class="line">                res.append(tmp+<span class="built_in">str</span>(node.val))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果当前节点不是叶子节点，将其左子树和新路径放入队列中    </span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append( [node.left,tmp+<span class="built_in">str</span>(node.val)+<span class="string">&quot;-&gt;&quot;</span>] )</span><br><span class="line">            <span class="comment"># 如果当前节点不是叶子节点，将其右子树和新路径放入队列中    </span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append( [node.right,tmp+<span class="built_in">str</span>(node.val)+<span class="string">&quot;-&gt;&quot;</span>] )</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>好像两个cotinue不加也行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root</span>):</span>	</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># res是最终结果集，queue中存放的是封装的[节点,临时路径]    </span></span><br><span class="line">        res = []</span><br><span class="line">        queue = [[root,<span class="string">&quot;&quot;</span>]]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node,tmp = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 如果当前节点是叶子节点，将其拼装后放入最终结果集中    </span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">and</span> <span class="keyword">not</span> (node.left <span class="keyword">or</span> node.right):</span><br><span class="line">                res.append(tmp+<span class="built_in">str</span>(node.val))</span><br><span class="line">            <span class="comment"># 如果当前节点不是叶子节点，将其左子树和新路径放入队列中    </span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append( [node.left,tmp+<span class="built_in">str</span>(node.val)+<span class="string">&quot;-&gt;&quot;</span>] )</span><br><span class="line">            <span class="comment"># 如果当前节点不是叶子节点，将其右子树和新路径放入队列中    </span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append( [node.right,tmp+<span class="built_in">str</span>(node.val)+<span class="string">&quot;-&gt;&quot;</span>] )</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<p>也可以用两个队列，一个存结点，一个存从根结点到该结点的路径（和上面方法不同，这里结果从根结点开始，从左到右变长）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root</span>):</span>	</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># res是最终路径结果集  </span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment">#一个node和一个path对应~</span></span><br><span class="line">        node_queue = [root]</span><br><span class="line">        path_queue=[<span class="built_in">str</span>(root.val)]</span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            node = node_queue.pop(<span class="number">0</span>)</span><br><span class="line">            path=path_queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 如果当前节点是叶子节点，将其拼装后放入最终结果集中    </span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (node.left <span class="keyword">or</span> node.right):</span><br><span class="line">                res.append(path)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                node_queue.append(node.left)</span><br><span class="line">                path_queue.append(path+<span class="string">&#x27;-&gt;&#x27;</span>+<span class="built_in">str</span>(node.left.val)) </span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node_queue.append(node.right)</span><br><span class="line">                path_queue.append(path+<span class="string">&#x27;-&gt;&#x27;</span>+<span class="built_in">str</span>(node.right.val))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>课后习题<br><img src="./171.png" alt="Alt text"></p>
<p>有了前面的铺垫，这题我自己独立做出来了：遍历从根节点出发的所有路径，存到res列表，然后返回res中所有满足和为targetSum的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">root,targetSum</span>):</span></span><br><span class="line">            res=[]</span><br><span class="line">            <span class="comment">#root是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (root.left <span class="keyword">or</span> root.right):</span><br><span class="line">                res.append([root.val])</span><br><span class="line">            <span class="comment">#root不是叶子结点,有左孩子</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                left_paths=solve(root.left,targetSum)</span><br><span class="line">                <span class="keyword">if</span> left_paths:</span><br><span class="line">                    <span class="keyword">for</span> s <span class="keyword">in</span> left_paths:</span><br><span class="line">                        res.append(s+[root.val])</span><br><span class="line">                        </span><br><span class="line">            <span class="comment">#root不是叶子结点，有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                right_paths=solve(root.right,targetSum)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(right_paths)!=<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">for</span> s <span class="keyword">in</span> right_paths:</span><br><span class="line">                        res.append(s+[root.val])     </span><br><span class="line">            <span class="keyword">return</span> res           </span><br><span class="line">        res=solve(root,targetSum)</span><br><span class="line">        <span class="keyword">return</span> [i[::-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res <span class="keyword">if</span> <span class="built_in">sum</span>(i)==targetSum]</span><br></pre></td></tr></table></figure>

<p>因为没有用到targetSum，所以可以写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">root</span>):</span></span><br><span class="line">            res=[]</span><br><span class="line">            <span class="comment">#root是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (root.left <span class="keyword">or</span> root.right):</span><br><span class="line">                res.append([root.val])</span><br><span class="line">            <span class="comment">#root不是叶子结点,有左孩子</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                left_paths=solve(root.left)</span><br><span class="line">                <span class="keyword">if</span> left_paths:</span><br><span class="line">                    <span class="keyword">for</span> s <span class="keyword">in</span> left_paths:</span><br><span class="line">                        res.append(s+[root.val])</span><br><span class="line">                        </span><br><span class="line">            <span class="comment">#root不是叶子结点，有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                right_paths=solve(root.right)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(right_paths)!=<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">for</span> s <span class="keyword">in</span> right_paths:</span><br><span class="line">                        res.append(s+[root.val])     </span><br><span class="line">            <span class="keyword">return</span> res           </span><br><span class="line">        res=solve(root)</span><br><span class="line">        <span class="keyword">return</span> [i[::-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res <span class="keyword">if</span> <span class="built_in">sum</span>(i)==targetSum]</span><br></pre></td></tr></table></figure>

<p>当然，如果想和前面的题统一，可以及时return：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            res=[]</span><br><span class="line">            <span class="comment">#root是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (root.left <span class="keyword">or</span> root.right):</span><br><span class="line">                res.append([root.val])</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">            <span class="comment">#root不是叶子结点,有左孩子</span></span><br><span class="line">            left_paths=solve(root.left)</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> left_paths:</span><br><span class="line">                res.append(s+[root.val])</span><br><span class="line">                        </span><br><span class="line">            <span class="comment">#root不是叶子结点，有右孩子</span></span><br><span class="line">            right_paths=solve(root.right)</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> right_paths:</span><br><span class="line">                res.append(s+[root.val])  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res           </span><br><span class="line">        res=solve(root)</span><br><span class="line">        <span class="keyword">return</span> [i[::-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res <span class="keyword">if</span> <span class="built_in">sum</span>(i)==targetSum]</span><br></pre></td></tr></table></figure>

<p>但是，上面的方法在递归时没有用到TargetSum，而是在求得全部从根结点到叶子节点的路径后再做判断的，那能不能在递归时就确定最终的结果呢？</p>
<p>可以!</p>
<p>只需要加个判断：叶子节点的值是否等于当前递归的targetSum，更改后代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">root,targetSum</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            res=[]</span><br><span class="line">            <span class="comment">#root是叶子结点,并且这个叶子节点的值等于当前递归的targetSum</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (root.left <span class="keyword">or</span> root.right) <span class="keyword">and</span> root.val==targetSum:</span><br><span class="line">                res.append([root.val])</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">            <span class="comment">#root不是叶子结点,有左孩子</span></span><br><span class="line">            left_paths=solve(root.left,targetSum-root.val)</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> left_paths:</span><br><span class="line">                res.append(s+[root.val])</span><br><span class="line">                        </span><br><span class="line">            <span class="comment">#root不是叶子结点，有右孩子</span></span><br><span class="line">            right_paths=solve(root.right,targetSum-root.val)</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> right_paths:</span><br><span class="line">                res.append(s+[root.val])  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res           </span><br><span class="line">        res=solve(root,targetSum)</span><br><span class="line">        <span class="keyword">return</span> [i[::-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure>

<p>我根据之前的题目，也写出了BFS：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        res=[]</span><br><span class="line">        node_queue=[root]<span class="comment">#当前结点</span></span><br><span class="line">        path_queue=[[root.val]]<span class="comment">#从根结点到当前结点的路径</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            cur_node=node_queue.pop(<span class="number">0</span>)</span><br><span class="line">            cur_path=path_queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment">#如果当前结点是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (cur_node.left <span class="keyword">or</span> cur_node.right):</span><br><span class="line">                res.append(cur_path)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#不是叶子结点,有左孩子</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                node_queue.append(cur_node.left)</span><br><span class="line">                path_queue.append(cur_path+[cur_node.left.val])</span><br><span class="line">            <span class="comment">#不是叶子结点，有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                node_queue.append(cur_node.right)</span><br><span class="line">                path_queue.append(cur_path+[cur_node.right.val])</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> res <span class="keyword">if</span> <span class="built_in">sum</span>(i)==targetSum]</span><br></pre></td></tr></table></figure>
<p>没错，这也是求出来了所有路径，最后判断的路径和是否等于targetSum的。</p>
<p>借鉴了之前两个队列的方法，从上往下找。</p>
<p>但上面的方法仍然没有用到targetSum。</p>
<p>可以再加一个队列，存储从根结点到当前结点的累加值，如果当前结点是叶子结点，并且从根结点到当前叶子结点的累加值等于targetSum，就找到了一条路径。</p>
<p>我写的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        res=[]</span><br><span class="line">        node_queue=[root]<span class="comment">#当前结点</span></span><br><span class="line">        path_queue=[[root.val]]<span class="comment">#从根结点到当前结点的路径</span></span><br><span class="line">        dist_queue=[root.val]<span class="comment">#从根结点到当前结点的累加值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            cur_node=node_queue.pop(<span class="number">0</span>)</span><br><span class="line">            cur_path=path_queue.pop(<span class="number">0</span>)</span><br><span class="line">            cur_dist=dist_queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment">#如果当前结点是叶子结点,且从根结点到当前结点的累加值等于targetSum</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (cur_node.left <span class="keyword">or</span> cur_node.right) <span class="keyword">and</span> cur_dist==targetSum:</span><br><span class="line">                res.append(cur_path)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#不是叶子结点,有左孩子</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                node_queue.append(cur_node.left)</span><br><span class="line">                path_queue.append(cur_path+[cur_node.left.val])</span><br><span class="line">                dist_queue.append(cur_dist+cur_node.left.val)</span><br><span class="line">            <span class="comment">#不是叶子结点，有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                node_queue.append(cur_node.right)</span><br><span class="line">                path_queue.append(cur_path+[cur_node.right.val])</span><br><span class="line">                dist_queue.append(cur_dist+cur_node.right.val)</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure>

<p><img src="./172.png" alt="Alt text"></p>
<p>直接在之前代码最后处理下数字转字符串再转数字即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            res=[]</span><br><span class="line">            <span class="comment">#root是叶子结点,并且这个叶子节点的值等于当前递归的targetSum</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (root.left <span class="keyword">or</span> root.right):</span><br><span class="line">                res.append([root.val])</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">            <span class="comment">#root不是叶子结点,有左孩子</span></span><br><span class="line">            left_paths=solve(root.left)</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> left_paths:</span><br><span class="line">                res.append(s+[root.val])</span><br><span class="line">                        </span><br><span class="line">            <span class="comment">#root不是叶子结点，有右孩子</span></span><br><span class="line">            right_paths=solve(root.right)</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> right_paths:</span><br><span class="line">                res.append(s+[root.val])  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res           </span><br><span class="line">        res=solve(root)</span><br><span class="line">        <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> res:</span><br><span class="line">            path=path[::-<span class="number">1</span>]</span><br><span class="line">            path=[<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> path]</span><br><span class="line">            <span class="built_in">sum</span>+=<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(path))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>

<p>BFS解法一样，也是做个后处理就AC了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res=[]</span><br><span class="line">        node_queue=[root]<span class="comment">#当前结点</span></span><br><span class="line">        path_queue=[[root.val]]<span class="comment">#从根结点到当前结点的路径</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            cur_node=node_queue.pop(<span class="number">0</span>)</span><br><span class="line">            cur_path=path_queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment">#如果当前结点是叶子结点,且从根结点到当前结点的累加值等于targetSum</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (cur_node.left <span class="keyword">or</span> cur_node.right):</span><br><span class="line">                res.append(cur_path)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#不是叶子结点,有左孩子</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                node_queue.append(cur_node.left)</span><br><span class="line">                path_queue.append(cur_path+[cur_node.left.val])</span><br><span class="line">     </span><br><span class="line">            <span class="comment">#不是叶子结点，有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                node_queue.append(cur_node.right)</span><br><span class="line">                path_queue.append(cur_path+[cur_node.right.val])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#只需加个后处理即可</span></span><br><span class="line">        <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> res:</span><br><span class="line">            path=[<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> path]</span><br><span class="line">            <span class="built_in">sum</span>+=<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(path))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>

<p>以上做法取巧使用了Python的字符串转数字功能，那如果不能这样做呢？</p>
<p>看官方题解的DFS:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root: TreeNode, prevTotal: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            total = prevTotal * <span class="number">10</span> + root.val</span><br><span class="line">            <span class="comment">#如果是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> total</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> dfs(root.left, total) + dfs(root.right, total)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。</p>
<p>空间复杂度：O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)。</p>
<p>我根据上面的官方DFS代码，写出了下面的BFS代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        node_queue=[root]<span class="comment">#存储结点</span></span><br><span class="line">        pre_queue=[<span class="number">0</span>]<span class="comment">#存储从根节点到当前结点的父节点的数字和</span></span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            r=node_queue.pop(<span class="number">0</span>)</span><br><span class="line">            pre=pre_queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#计算根结点到当前结点的数字和</span></span><br><span class="line">            total=pre*<span class="number">10</span>+r.val</span><br><span class="line">            <span class="comment">#如果是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (r.left <span class="keyword">or</span> r.right):</span><br><span class="line">                res+=total</span><br><span class="line">            <span class="comment">#如果不是叶子结点，有左孩子</span></span><br><span class="line">            <span class="keyword">if</span> r.left:</span><br><span class="line">                node_queue.append(r.left)</span><br><span class="line">                pre_queue.append(total)</span><br><span class="line">            <span class="comment">#如果不是叶子结点，有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> r.right:</span><br><span class="line">                node_queue.append(r.right)</span><br><span class="line">                pre_queue.append(total)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>我的<code>pre_queue</code> 存储的是从根结点到当前结点的父节点的对应数字和，看了下官方的BFS解法，<code>pre_queue</code>存的是从根结点到当前结点的对应数字和.</p>
<p>于是我改了一下上面的BFS代码，让pre_queue存从根结点到当前结点的对应数字和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        node_queue=[root]<span class="comment">#存储结点</span></span><br><span class="line">        pre_queue=[root.val]<span class="comment">#存储从根节点到当前结点的数字和</span></span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            r=node_queue.pop(<span class="number">0</span>)</span><br><span class="line">            total=pre_queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#如果是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (r.left <span class="keyword">or</span> r.right):</span><br><span class="line">                res+=total</span><br><span class="line">            <span class="comment">#如果不是叶子结点，有左孩子</span></span><br><span class="line">            <span class="keyword">if</span> r.left:</span><br><span class="line">                node_queue.append(r.left)</span><br><span class="line">                pre_queue.append(total*<span class="number">10</span>+r.left.val)</span><br><span class="line">            <span class="comment">#如果不是叶子结点，有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> r.right:</span><br><span class="line">                node_queue.append(r.right)</span><br><span class="line">                pre_queue.append(total*<span class="number">10</span>+r.right.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>哪种方法都可以的~~</p>
<p>时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。</p>
<p>空间复杂度：O(n)，其中 nnn 是二叉树的节点个数。空间复杂度主要取决于队列，每个队列中的元素个数不会超过 n。</p>
<h2 id="7-5"><a href="#7-5" class="headerlink" title="7-5"></a>7-5</h2><p>更复杂的递归：<br><img src="./173.png" alt="Alt text"></p>
<p><img src="./174.png" alt="Alt text"></p>
<p><img src="./175.png" alt="Alt text"></p>
<p>改写成Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#该函数寻找以node为根结点，且包含node的路径，路径和为num</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findPath</span>(<span class="params">node,num</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            res=<span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> node.val==num:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            res+=findPath(node.left,num-node.val)</span><br><span class="line">            res+=findPath(node.right,num-node.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#寻找以root为根结点，且包含root的路径，路径和为targetSum</span></span><br><span class="line">        res=findPath(root,targetSum)</span><br><span class="line">        <span class="comment">#寻找不包含root的路径，路径和为targetSum</span></span><br><span class="line">        res+=self.pathSum(root.left,targetSum)</span><br><span class="line">        res+=self.pathSum(root.right,targetSum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="7-6"><a href="#7-6" class="headerlink" title="7-6"></a>7-6</h2><p>二分搜索树</p>
<p><img src="./176.png" alt="Alt text"></p>
<p><img src="./177.png" alt="Alt text"></p>
<p>所有节点的值都是唯一的。</p>
<p> p, q 为不同节点且均存在于给定的二叉搜索树中。</p>
<p>利用了二分搜索树的性质:</p>
<pre><code>如果root.val都比p,q大，代表要往左边走
如果root.val都比p,q小，代表要往右边走
如果一个在左一个在右，代表得到结果
</code></pre>
<p><img src="./178.png" alt="Alt text"></p>
<p>我改写成Python版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="comment">#p和q都在左子树中</span></span><br><span class="line">        <span class="keyword">if</span> p.val&lt;root.val <span class="keyword">and</span> q.val&lt;root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        <span class="comment">#p和q都在右子树中</span></span><br><span class="line">        <span class="keyword">if</span> p.val&gt;root.val <span class="keyword">and</span> q.val&gt;root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="comment">#p和q有可能一左一右，或者其一就是root，这些情况下，它们的公共祖先就是root</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>课后习题<br><img src="./183.png" alt="Alt text"><br>和上题相比，这里的树是普通的二叉树了。</p>
<p><img src="./184.png" alt="Alt text"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: TreeNode, p: TreeNode, q: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="keyword">return</span> <span class="comment"># 1.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right <span class="comment"># 3.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left <span class="comment"># 4.</span></span><br><span class="line">        <span class="keyword">return</span> root <span class="comment"># 2. if left and right</span></span><br></pre></td></tr></table></figure>
<p>没太懂。。。</p>
<p><img src="./179.png" alt="Alt text"></p>
<p>中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p>
<p>有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</p>
<p>很容易懂的一个方法：判断中序遍历结果是否有序(从小到大，不重复，leetcode要求二叉搜索树中不含有重复元素)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        arr=[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            dfs(root.left)</span><br><span class="line">            arr.append(root.val)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line"></span><br><span class="line">        n=<span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> arr[i]&lt;=arr[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>上面的方法是先把中序遍历的结果存起来，再进行判断，也可以同时进行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        cur_max = -<span class="built_in">float</span>(<span class="string">&quot;INF&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_isValidBST</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> cur_max </span><br><span class="line">            <span class="comment"># 规律: BST的中序遍历节点数值是从小到大. </span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            is_left_valid = _isValidBST(root.left)</span><br><span class="line">            <span class="keyword">if</span> cur_max &lt; root.val: </span><br><span class="line">                cur_max = root.val</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            is_right_valid = _isValidBST(root.right)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> is_left_valid <span class="keyword">and</span> is_right_valid</span><br><span class="line">        <span class="keyword">return</span> _isValidBST(root)</span><br></pre></td></tr></table></figure>

<p>也可以写成一个方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    cur_max = -<span class="built_in">float</span>(<span class="string">&quot;INF&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment"># 规律: BST的中序遍历节点数值是从小到大.             </span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        is_left_valid = self.isValidBST(root.left)</span><br><span class="line">        <span class="keyword">if</span> self.cur_max &lt; root.val: </span><br><span class="line">            self.cur_max = root.val</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        is_right_valid = self.isValidBST(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> is_left_valid <span class="keyword">and</span> is_right_valid</span><br></pre></td></tr></table></figure>
<p>陷阱：不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了。</p>
<p>也可以写成非递归形式的中序遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        p = root</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            p = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> pre <span class="keyword">and</span> p.val &lt;= pre.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            pre = p</span><br><span class="line">            p = p.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<p><img src="./180.png" alt="Alt text"></p>
<p>大佬的代码，能看懂：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: TreeNode, key: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root  <span class="comment">#第一种情况：没找到删除的节点，遍历到空节点直接返回了</span></span><br><span class="line">        <span class="keyword">if</span> root.val == key:  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:  <span class="comment">#第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">                <span class="keyword">del</span> root</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> root.right:  <span class="comment">#第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">                tmp = root</span><br><span class="line">                root = root.right</span><br><span class="line">                <span class="keyword">del</span> tmp</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:  <span class="comment">#第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">                tmp = root</span><br><span class="line">                root = root.left</span><br><span class="line">                <span class="keyword">del</span> tmp</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment">#第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">                v = root.right</span><br><span class="line">                <span class="keyword">while</span> v.left:</span><br><span class="line">                    v = v.left</span><br><span class="line">                v.left = root.left</span><br><span class="line">                tmp = root</span><br><span class="line">                root = root.right</span><br><span class="line">                <span class="keyword">del</span> tmp</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; key: root.left = self.deleteNode(root.left,key)  <span class="comment">#左递归</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key: root.right = self.deleteNode(root.right,key)  <span class="comment">#右递归</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>


<p><img src="./181.png" alt="Alt text"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">left,right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            mid=(right+left)//<span class="number">2</span></span><br><span class="line">            root=TreeNode(nums[mid])</span><br><span class="line">            root.left=bfs(left,mid-<span class="number">1</span>)</span><br><span class="line">            root.right=bfs(mid+<span class="number">1</span>,right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> bfs(<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="./182.png" alt="Alt text"><br>我直接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder_bfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            inorder_bfs(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            inorder_bfs(root.right)</span><br><span class="line">        inorder_bfs(root)</span><br><span class="line">        <span class="keyword">return</span> res[k-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>官方也是，同时也给出了迭代的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stack = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> k:</span><br><span class="line">                <span class="keyword">return</span> root.val</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure>



<h1 id="第八章：递归与回溯"><a href="#第八章：递归与回溯" class="headerlink" title="第八章：递归与回溯"></a>第八章：递归与回溯</h1><h2 id="8-1"><a href="#8-1" class="headerlink" title="8-1"></a>8-1</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="./185.png" alt="Alt text"></p>
<p><img src="./186.png" alt="Alt text"></p>
<p>这是一个树形问题。</p>
<p><img src="./187.png" alt="Alt text"></p>
<p>官方题解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        phoneMap = &#123;</span><br><span class="line">            <span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">            <span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">            <span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">            <span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">index: <span class="built_in">int</span></span>):</span></span><br><span class="line">            <span class="comment">#找到一个结果</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(digits):</span><br><span class="line">                combinations.append(<span class="string">&quot;&quot;</span>.join(combination))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            digit = digits[index]</span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> phoneMap[digit]:</span><br><span class="line">                <span class="comment">#选择</span></span><br><span class="line">                combination.append(letter)</span><br><span class="line">                <span class="comment">#回溯</span></span><br><span class="line">                backtrack(index + <span class="number">1</span>)</span><br><span class="line">                <span class="comment">#撤销选择</span></span><br><span class="line">                combination.pop()</span><br><span class="line"></span><br><span class="line">        combination = <span class="built_in">list</span>()</span><br><span class="line">        combinations = <span class="built_in">list</span>()</span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> combinations</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        phoneMap = &#123;</span><br><span class="line">            <span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">            <span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">            <span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">            <span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">digits,index: <span class="built_in">int</span></span>):</span></span><br><span class="line">            <span class="comment">#找到一个结果</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(digits):</span><br><span class="line">                combinations.append(<span class="string">&quot;&quot;</span>.join(combination))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            digit = digits[index]</span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> phoneMap[digit]:</span><br><span class="line">                <span class="comment">#选择</span></span><br><span class="line">                combination.append(letter)</span><br><span class="line">                <span class="comment">#回溯</span></span><br><span class="line">                backtrack(digits,index + <span class="number">1</span>)</span><br><span class="line">                <span class="comment">#撤销选择</span></span><br><span class="line">                combination.pop()</span><br><span class="line"></span><br><span class="line">        combination = <span class="built_in">list</span>()</span><br><span class="line">        combinations = <span class="built_in">list</span>()</span><br><span class="line">        backtrack(digits,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> combinations</span><br></pre></td></tr></table></figure>

<p>这里回溯函数传不传digits都可以~</p>
<p>评论区更容易理解的解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="comment">#数字对应的英文字母列表</span></span><br><span class="line">        word_list = [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>]</span><br><span class="line">        <span class="comment">#如果是空字符串直接返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment">#保存结果列表</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment">#输入的digits的长度，作为回溯函数返回的判断条件</span></span><br><span class="line">        length = <span class="built_in">len</span>(digits)</span><br><span class="line">        <span class="comment">#回溯函数（path当前路径，默认为&quot;&quot;）</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back_track</span>(<span class="params">digits, index, path</span>):</span></span><br><span class="line">            <span class="comment">#如果目前path的长度和digits的长度相等，说明已经遍历完一趟，返回结果列表</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == length:</span><br><span class="line">                <span class="comment">#加入result列表</span></span><br><span class="line">                result.append(path)</span><br><span class="line">                <span class="comment">#返回</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment">#遍历当前索引的数字对应的英文列表</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> word_list[<span class="built_in">int</span>(digits[index])]:</span><br><span class="line">                <span class="comment">#路径加上当前字母</span></span><br><span class="line">                path = path + word</span><br><span class="line">                <span class="comment">#递归下一个数字对应的英文列表</span></span><br><span class="line">                back_track(digits, index + <span class="number">1</span>, path)</span><br><span class="line">                <span class="comment">#撤销当前字母</span></span><br><span class="line">                path = path[:-<span class="number">1</span>]</span><br><span class="line">        back_track(digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>不传path也可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="comment">#数字对应的英文字母列表</span></span><br><span class="line">        word_list = [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>]</span><br><span class="line">        <span class="comment">#如果是空字符串直接返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment">#保存结果列表</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment">#输入的digits的长度，作为回溯函数返回的判断条件</span></span><br><span class="line">        length = <span class="built_in">len</span>(digits)</span><br><span class="line">        <span class="comment">#回溯函数（path当前路径，默认为&quot;&quot;）</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back_track</span>(<span class="params">digits, index</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> path</span><br><span class="line">            <span class="comment">#如果目前path的长度和digits的长度相等，说明已经遍历完一趟，返回结果列表</span></span><br><span class="line">            <span class="keyword">if</span> index == length:</span><br><span class="line">                <span class="comment">#加入result列表</span></span><br><span class="line">                result.append(path)</span><br><span class="line">                <span class="comment">#返回</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment">#遍历当前索引的数字对应的英文列表</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> word_list[<span class="built_in">int</span>(digits[index])]:</span><br><span class="line">                <span class="comment">#路径加上当前字母</span></span><br><span class="line">                path = path + word</span><br><span class="line">                <span class="comment">#递归下一个数字对应的英文列表</span></span><br><span class="line">                back_track(digits, index + <span class="number">1</span>)</span><br><span class="line">                <span class="comment">#撤销当前字母</span></span><br><span class="line">                path = path[:-<span class="number">1</span>]</span><br><span class="line">        path=<span class="string">&quot;&quot;</span></span><br><span class="line">        back_track(digits, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>课后习题：<br><img src="./188.png" alt="Alt text"></p>
<p><img src="./190.png" alt="Alt text"></p>
<p>有点难</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        SEG_COUNT = <span class="number">4</span></span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        segments = [<span class="number">0</span>] * SEG_COUNT<span class="comment">#[0,0,0,0]</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">segId: <span class="built_in">int</span>, segStart: <span class="built_in">int</span></span>):</span></span><br><span class="line">            <span class="comment"># 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class="line">            <span class="keyword">if</span> segId == SEG_COUNT:</span><br><span class="line">                <span class="keyword">if</span> segStart == <span class="built_in">len</span>(s):</span><br><span class="line">                    ipAddr = <span class="string">&quot;.&quot;</span>.join(<span class="built_in">str</span>(seg) <span class="keyword">for</span> seg <span class="keyword">in</span> segments)</span><br><span class="line">                    ans.append(ipAddr)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class="line">            <span class="keyword">if</span> segStart == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class="line">            <span class="keyword">if</span> s[segStart] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                segments[segId] = <span class="number">0</span></span><br><span class="line">                dfs(segId + <span class="number">1</span>, segStart + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 一般情况，枚举每一种可能性并递归</span></span><br><span class="line">            addr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> segEnd <span class="keyword">in</span> <span class="built_in">range</span>(segStart, <span class="built_in">len</span>(s)):</span><br><span class="line">                addr = addr * <span class="number">10</span> + (<span class="built_in">ord</span>(s[segEnd]) - <span class="built_in">ord</span>(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt; addr &lt;= <span class="number">255</span>:</span><br><span class="line">                    segments[segId] = addr</span><br><span class="line">                    dfs(segId + <span class="number">1</span>, segEnd + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>来个更详细的注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        SEG_COUNT = <span class="number">4</span></span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        segments = [<span class="number">0</span>] * SEG_COUNT<span class="comment">#[0,0,0,0]</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">segId: <span class="built_in">int</span>, segStart: <span class="built_in">int</span></span>):</span></span><br><span class="line">            <span class="comment"># 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class="line">            <span class="keyword">if</span> segId == SEG_COUNT:</span><br><span class="line">                <span class="keyword">if</span> segStart == <span class="built_in">len</span>(s):</span><br><span class="line">                    ipAddr = <span class="string">&quot;.&quot;</span>.join(<span class="built_in">str</span>(seg) <span class="keyword">for</span> seg <span class="keyword">in</span> segments)</span><br><span class="line">                    ans.append(ipAddr)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class="line">            <span class="keyword">if</span> segStart == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 如果还没有遍历完字符串就已经找到 4 段 IP 地址，那么提前回溯</span></span><br><span class="line">            <span class="keyword">if</span> segId==SEG_COUNT:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class="line">            <span class="keyword">if</span> s[segStart] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                segments[segId] = <span class="number">0</span></span><br><span class="line">                dfs(segId + <span class="number">1</span>, segStart + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 一般情况，枚举每一种可能性并递归</span></span><br><span class="line">            addr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> segEnd <span class="keyword">in</span> <span class="built_in">range</span>(segStart, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment">#addr = addr * 10 + (ord(s[segEnd]) - ord(&quot;0&quot;))</span></span><br><span class="line">                addr=addr*<span class="number">10</span>+<span class="built_in">int</span>(s[segEnd])<span class="comment">#更易懂~</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt; addr &lt;= <span class="number">255</span>:<span class="comment">#等于0的情况在上面已经单独处理了</span></span><br><span class="line">                    <span class="comment">#加入当前数字了</span></span><br><span class="line">                    segments[segId] = addr</span><br><span class="line">                    <span class="comment">#回溯吧</span></span><br><span class="line">                    dfs(segId + <span class="number">1</span>, segEnd + <span class="number">1</span>)</span><br><span class="line">                    <span class="comment">#撤销的过程：对于之前的问题，都是直接撤销，&quot;撤销&quot;等价于出栈或pop字符串最后一位，</span></span><br><span class="line">                    <span class="comment">#但是这里是切割问题，&quot;撤销&quot;等价于右移切割点，也就是for做的,更具体的，addr会变回回溯前的值。</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>我想改成用list，但死活不通过<code>&quot;010010&quot;</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        SEG_COUNT = <span class="number">4</span></span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        segments = <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">segStart: <span class="built_in">int</span></span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> segments</span><br><span class="line">            <span class="built_in">print</span>(segStart,segments)</span><br><span class="line">            <span class="comment"># 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(segments) == SEG_COUNT <span class="keyword">and</span> segStart == <span class="built_in">len</span>(s):</span><br><span class="line">                ipAddr = <span class="string">&quot;.&quot;</span>.join(<span class="built_in">str</span>(seg) <span class="keyword">for</span> seg <span class="keyword">in</span> segments)</span><br><span class="line">                ans.append(ipAddr)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class="line">            <span class="keyword">if</span> segStart == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;a:&#x27;</span>,segStart)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 如果还没有遍历完字符串就已经找到 4 段 IP 地址，那么提前回溯</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(segments)==SEG_COUNT:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;b:&#x27;</span>,segStart)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class="line">            <span class="keyword">if</span> s[segStart] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                <span class="comment">#print(&#x27;00000&#x27;)</span></span><br><span class="line">                segments.append(<span class="number">0</span>)</span><br><span class="line">                dfs(segStart + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 一般情况，枚举每一种可能性并递归</span></span><br><span class="line">            addr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> segEnd <span class="keyword">in</span> <span class="built_in">range</span>(segStart, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment">#addr = addr * 10 + (ord(s[segEnd]) - ord(&quot;0&quot;))</span></span><br><span class="line">                addr=addr*<span class="number">10</span>+<span class="built_in">int</span>(s[segEnd])<span class="comment">#更易懂~</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt; addr &lt;= <span class="number">255</span>:<span class="comment">#等于0的情况在上面已经单独处理了</span></span><br><span class="line">                    <span class="comment">#加入当前数字</span></span><br><span class="line">                    segments.append(addr)</span><br><span class="line">                    <span class="comment">#回溯</span></span><br><span class="line">                    dfs(segEnd + <span class="number">1</span>)</span><br><span class="line">                    <span class="comment">#撤销加入当前数字</span></span><br><span class="line">                    segments.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>可能是for那里的addr有个累加的过程，单纯的pop会导致之前累加的结果丢失？？？</p>
<p><img src="./189.png" alt="Alt text"></p>
<p><img src="./191.png" alt="Alt text"></p>
<p>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        path = []  <span class="comment">#放已经回文的子串</span></span><br><span class="line">        <span class="comment"># 双指针法判断是否是回文串</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">s</span>):</span></span><br><span class="line">            n = <span class="built_in">len</span>(s)</span><br><span class="line">            i, j = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j: </span><br><span class="line">                <span class="keyword">if</span> s[i] != s[j]:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">s, startIndex</span>):</span></span><br><span class="line">            <span class="keyword">if</span> startIndex == <span class="built_in">len</span>(s): <span class="comment"># 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span></span><br><span class="line">                res.append(path[:])<span class="comment">#拷贝一份当前副本，因为之后path还会变的</span></span><br><span class="line">                <span class="keyword">return</span>  </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(s)):</span><br><span class="line">                p = s[startIndex:i+<span class="number">1</span>] <span class="comment"># 获取[startIndex,i+1]在s中的子串</span></span><br><span class="line">                <span class="keyword">if</span> isPalindrome(p): <span class="comment"># 是回文子串</span></span><br><span class="line">                    path.append(p)</span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">continue</span> <span class="comment">#不是回文，跳过</span></span><br><span class="line">                backtrack(s, i + <span class="number">1</span>)</span><br><span class="line">                path.pop() <span class="comment">#回溯过程，弹出本次已经填在path的子串</span></span><br><span class="line">        backtrack(s, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这种题还是有些难的，目前自己很难写出来，但代码基本都是套模板，之后还要多品味~</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://www.cdnjson.com/images/2021/11/21/1_VJNqt2qR5keOZ_ukx8fmwA.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/12/%E8%B7%A8%E8%80%83%E5%B0%8F%E7%99%BD%E5%AD%A6%E5%88%B7%E9%A2%98(%E4%B8%8B)/"><img class="prev-cover" src="https://www.cdnjson.com/images/2021/11/21/1_VJNqt2qR5keOZ_ukx8fmwA.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">跨考小白学刷题(下)</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/09/Spark%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-Python%E7%89%88%E6%9C%AC/"><img class="next-cover" src="https://www.cdnjson.com/images/2021/11/18/11.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spark编程基础-Python版本</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://www.cdnjson.com/images/2021/11/27/_20210211193948.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">雨落诗山山亦奇</div><div class="author-info__description">昨夜星辰昨夜风</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">136</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">机器爱学习</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">第一章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1"><span class="toc-number">1.1.</span> <span class="toc-text">1-1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4"><span class="toc-number">1.2.</span> <span class="toc-text">1-4</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="toc-number">2.</span> <span class="toc-text">第二章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1"><span class="toc-number">2.1.</span> <span class="toc-text">2-1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2"><span class="toc-number">2.2.</span> <span class="toc-text">2-2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3"><span class="toc-number">2.3.</span> <span class="toc-text">2-3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4"><span class="toc-number">2.4.</span> <span class="toc-text">2-4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6"><span class="toc-number">2.5.</span> <span class="toc-text">2-6</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%EF%BC%9A%E4%BB%8E%E6%95%B0%E7%BB%84%E5%BC%80%E5%A7%8B"><span class="toc-number">3.</span> <span class="toc-text">第三章 ：从数组开始</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1"><span class="toc-number">3.1.</span> <span class="toc-text">3-1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2"><span class="toc-number">3.2.</span> <span class="toc-text">3-2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3"><span class="toc-number">3.3.</span> <span class="toc-text">3-3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4"><span class="toc-number">3.4.</span> <span class="toc-text">3-4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5"><span class="toc-number">3.5.</span> <span class="toc-text">3-5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6"><span class="toc-number">3.6.</span> <span class="toc-text">3-6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7"><span class="toc-number">3.7.</span> <span class="toc-text">3-7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8"><span class="toc-number">3.8.</span> <span class="toc-text">3-8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E6%80%BB%E7%BB%93"><span class="toc-number">3.9.</span> <span class="toc-text">本章总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-11-25%E6%9B%B4%E6%96%B0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%A8%A1%E6%9D%BF-13%E9%81%93%E9%A2%98"><span class="toc-number">3.10.</span> <span class="toc-text">2021&#x2F;11&#x2F;25更新: 滑动窗口模板(13道题)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-I"><span class="toc-number">3.10.1.</span> <span class="toc-text">643. 子数组最大平均数 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">3.10.2.</span> <span class="toc-text">3. 无重复字符的最长子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#159-%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">3.10.3.</span> <span class="toc-text">159. 至多包含两个不同字符的最长子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">3.10.4.</span> <span class="toc-text">209. 长度最小的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1695-%E5%88%A0%E9%99%A4%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="toc-number">3.10.5.</span> <span class="toc-text">1695. 删除子数组的最大得分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">3.10.6.</span> <span class="toc-text">438. 找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">3.10.7.</span> <span class="toc-text">567. 字符串的排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#487-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0-II"><span class="toc-number">3.10.8.</span> <span class="toc-text">487. 最大连续1的个数 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0-III"><span class="toc-number">3.10.9.</span> <span class="toc-text">1004. 最大连续1的个数 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1208-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89"><span class="toc-number">3.10.10.</span> <span class="toc-text">1208. 尽可能使字符串相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF"><span class="toc-number">3.10.11.</span> <span class="toc-text">1052. 爱生气的书店老板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1423-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0"><span class="toc-number">3.10.12.</span> <span class="toc-text">1423. 可获得的最大点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1151-%E6%9C%80%E5%B0%91%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0%E6%9D%A5%E7%BB%84%E5%90%88%E6%89%80%E6%9C%89%E7%9A%84-1"><span class="toc-number">3.10.13.</span> <span class="toc-text">1151. 最少交换次数来组合所有的 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%A8%A1%E6%9D%BF%E8%A7%A3%E7%AC%AC219%E9%A2%98%EF%BC%9A219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II"><span class="toc-number">3.10.14.</span> <span class="toc-text">用模板解第219题：219. 存在重复元素 II</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">第四章：查找问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1set"><span class="toc-number">4.1.</span> <span class="toc-text">4-1set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-map-dict"><span class="toc-number">4.2.</span> <span class="toc-text">4-2 map(dict)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3"><span class="toc-number">4.3.</span> <span class="toc-text">4-3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4"><span class="toc-number">4.4.</span> <span class="toc-text">4-4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5"><span class="toc-number">4.5.</span> <span class="toc-text">4-5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6"><span class="toc-number">4.6.</span> <span class="toc-text">4-6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7"><span class="toc-number">4.7.</span> <span class="toc-text">4-7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8"><span class="toc-number">4.8.</span> <span class="toc-text">4-8</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E9%93%BE%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">第五章：链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1"><span class="toc-number">5.1.</span> <span class="toc-text">5-1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2"><span class="toc-number">5.2.</span> <span class="toc-text">5-2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3"><span class="toc-number">5.3.</span> <span class="toc-text">5-3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4"><span class="toc-number">5.4.</span> <span class="toc-text">5-4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5"><span class="toc-number">5.5.</span> <span class="toc-text">5-5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6"><span class="toc-number">5.6.</span> <span class="toc-text">5-6</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">第六章、栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1"><span class="toc-number">6.1.</span> <span class="toc-text">6-1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2"><span class="toc-number">6.2.</span> <span class="toc-text">6-2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3"><span class="toc-number">6.3.</span> <span class="toc-text">6-3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4"><span class="toc-number">6.4.</span> <span class="toc-text">6-4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5%EF%BC%88%E5%A5%BD%E9%9A%BE%E5%93%A6%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">6-5（好难哦）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6%EF%BC%8C6-7"><span class="toc-number">6.6.</span> <span class="toc-text">6-6，6-7</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E9%80%92%E5%BD%92"><span class="toc-number">7.</span> <span class="toc-text">第七章：递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1"><span class="toc-number">7.1.</span> <span class="toc-text">7-1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2"><span class="toc-number">7.2.</span> <span class="toc-text">7-2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3"><span class="toc-number">7.3.</span> <span class="toc-text">7-3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4"><span class="toc-number">7.4.</span> <span class="toc-text">7-4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5"><span class="toc-number">7.5.</span> <span class="toc-text">7-5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6"><span class="toc-number">7.6.</span> <span class="toc-text">7-6</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF"><span class="toc-number">8.</span> <span class="toc-text">第八章：递归与回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1"><span class="toc-number">8.1.</span> <span class="toc-text">8-1</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/ToothSeg%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" title="ToothSeg项目总结"><img src="/img/tag1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ToothSeg项目总结"/></a><div class="content"><a class="title" href="/2021/12/03/ToothSeg%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" title="ToothSeg项目总结">ToothSeg项目总结</a><time datetime="2021-12-03T15:09:30.000Z" title="发表于 2021-12-03 23:09:30">2021-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/DeepLab%E7%B3%BB%E5%88%97%E8%A7%A3%E8%AF%BB/" title="DeepLab系列解读"><img src="/img/tag1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DeepLab系列解读"/></a><div class="content"><a class="title" href="/2021/12/03/DeepLab%E7%B3%BB%E5%88%97%E8%A7%A3%E8%AF%BB/" title="DeepLab系列解读">DeepLab系列解读</a><time datetime="2021-12-03T05:45:10.000Z" title="发表于 2021-12-03 13:45:10">2021-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/01/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E9%83%A8%E7%BD%B2%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/" title="如何在网页上部署深度学习模型?"><img src="https://www.cdnjson.com/images/2021/12/01/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何在网页上部署深度学习模型?"/></a><div class="content"><a class="title" href="/2021/12/01/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E9%83%A8%E7%BD%B2%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/" title="如何在网页上部署深度学习模型?">如何在网页上部署深度学习模型?</a><time datetime="2021-12-01T05:29:51.000Z" title="发表于 2021-12-01 13:29:51">2021-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/30/%E7%BB%8F%E5%85%B8%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%BD%91%E7%BB%9C-UNet/" title="经典语义分割网络:UNet"><img src="https://www.cdnjson.com/images/2021/12/01/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="经典语义分割网络:UNet"/></a><div class="content"><a class="title" href="/2021/11/30/%E7%BB%8F%E5%85%B8%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%BD%91%E7%BB%9C-UNet/" title="经典语义分割网络:UNet">经典语义分割网络:UNet</a><time datetime="2021-11-30T07:15:38.000Z" title="发表于 2021-11-30 15:15:38">2021-11-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/28/%E7%BB%8F%E5%85%B8%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%BD%91%E7%BB%9C-FCN-1/" title="经典语义分割网络:FCN"><img src="https://www.cdnjson.com/images/2021/11/28/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="经典语义分割网络:FCN"/></a><div class="content"><a class="title" href="/2021/11/28/%E7%BB%8F%E5%85%B8%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%BD%91%E7%BB%9C-FCN-1/" title="经典语义分割网络:FCN">经典语义分割网络:FCN</a><time datetime="2021-11-28T10:57:04.000Z" title="发表于 2021-11-28 18:57:04">2021-11-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://www.cdnjson.com/images/2021/11/21/1_VJNqt2qR5keOZ_ukx8fmwA.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 雨落诗山山亦奇</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
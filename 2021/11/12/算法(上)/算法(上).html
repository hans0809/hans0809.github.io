<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1-1"></a>1-1</h2><blockquote>
<p>对一组数据进行排序时，要考虑这组数据有什么样的特征。</p>
</blockquote>
<p>包含大量重复元素-&gt;三路快排</p>
<p>近乎有序-&gt;插入排序</p>
<p>取值范围有限-&gt;计数排序</p>
<p>要求稳定排序-&gt;归并排序</p>
<p>使用链表存储-&gt; 归并排序</p>
<p>数据量很大-&gt;外部排序</p>
<h2 id="1-4"><a href="#1-4" class="headerlink" title="1-4"></a>1-4</h2><blockquote>
<p>当没有思路时</p>
</blockquote>
<p>尝试简单测试用例</p>
<p>暴力法</p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2-1"></a>2-1</h2><p>O(f(n))表示算法执行的上界</p>
<p><img src="./1.png" alt="Alt text"></p>
<p>最后一项，nlog(n)是数组全部元素比较的次数，s指的是确定两个字符串的字典序需要O(s).</p>
<p>因此，最终的时间复杂度是：O(nslog(s)+snlog(n))</p>
<h2 id="2-2"><a href="#2-2" class="headerlink" title="2-2"></a>2-2</h2><p><img src="./2.png" alt="Alt text"></p>
<p>第一个，只需要ret和i</p>
<p>第二个，递归深度为n</p>
<h2 id="2-3"><a href="#2-3" class="headerlink" title="2-3"></a>2-3</h2><p><img src="./3.png" alt="Alt text"></p>
<p><img src="./4.png" alt="Alt text"></p>
<p><img src="./5.png" alt="Alt text"></p>
<p><img src="./6.png" alt="Alt text"></p>
<p><img src="./7.png" alt="Alt text"></p>
<p><img src="./8.png" alt="Alt text"></p>
<p><img src="./9.png" alt="Alt text"></p>
<p><img src="./10.png" alt="Alt text"><br>reverse函数的时间复杂度是O(m/2)=O(m)，其中m指的是s的长度，又由于s的长度和while中执行次数是一样的(每执行一次，s多一位)，因此也是s的长度也是logn，从而整体的时间复杂度是O(2logn)=O(logn).</p>
<p><img src="./11.png" alt="Alt text"></p>
<p>可见，log的底并不重要。</p>
<p><img src="./12.png" alt="Alt text"><br>第一重循环log(n)次，因此整体时间复杂度是O(nlogn).</p>
<p><img src="./13.png" alt="Alt text"></p>
<h2 id="2-4"><a href="#2-4" class="headerlink" title="2-4"></a>2-4</h2><p><img src="./14.png" alt="Alt text"></p>
<p><img src="./15.png" alt="Alt text"></p>
<p><img src="./16.png" alt="Alt text"></p>
<h2 id="2-6"><a href="#2-6" class="headerlink" title="2-6"></a>2-6</h2><p>动态数组</p>
<p>添加/删除一个元素的均摊复杂度是O(1)</p>
<p>添加元素<br><img src="./17.png" alt="Alt text"></p>
<p>但删除元素时可能出现复杂度震荡，此时位于数组长度的一半位置<br><img src="./18.png" alt="Alt text"></p>
<p>解决：<br><img src="./19.png" alt="Alt text"></p>
<h1 id="第三章-：从数组开始"><a href="#第三章-：从数组开始" class="headerlink" title="第三章 ：从数组开始"></a>第三章 ：从数组开始</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3-1"></a>3-1</h2><p>二分查找的代码<br><img src="./20.png" alt="Alt text"></p>
<h2 id="3-2"><a href="#3-2" class="headerlink" title="3-2"></a>3-2</h2><p>二分查找的另一种代码<br><img src="./21.png" alt="Alt text"></p>
<h2 id="3-3"><a href="#3-3" class="headerlink" title="3-3"></a>3-3</h2><p>问题：Move Zeros<br><img src="./22.png" alt="Alt text"></p>
<p>解法1：用一个新的数组按顺序存储nums中的非零元素，然后将这个数组中的元素覆盖在nums，nums后续位置全部置0：<br><img src="./23.png" alt="Alt text"></p>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h2 id="3-4"><a href="#3-4" class="headerlink" title="3-4"></a>3-4</h2><p>优化上一节的问题。</p>
<p>解法2：不使用额外数组，直接覆盖<br><img src="./24.png" alt="Alt text"><br>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<p>解法3：将覆盖改为交换<br><img src="./25.png" alt="Alt text"><br>时间复杂度：O(n)<br>空间复杂度：O(1)<br>解法4：当整个数组全部非零时，解法3需要自己和自己做交换，可以改进<br><img src="./26.png" alt="Alt text"><br>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<p>课后习题：<br><img src="./27.png" alt="Alt text"></p>
<p>不需要考虑数组中超出新长度后面的元素。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p><strong>解法1</strong>：两个指针一前一后向右走</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span>
        i,j=<span class="number">0</span>,<span class="number">0</span>
        <span class="keyword">while</span> j&lt;len(nums):
            <span class="keyword">if</span> nums[j]!=val:
                nums[i]=nums[j]
                i+=<span class="number">1</span>
            j+=<span class="number">1</span>
        <span class="keyword">return</span> i</code></pre>
<p>时间复杂度：O(n)，其中 n 为序列的长度。我们只需要遍历该序列至多两次。</p>
<p>空间复杂度：O(1)。我们只需要常数的空间保存若干变量。</p>
<p><strong>解法2</strong>：两个指针一个向右走，一个向左走</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span>
        i,j=<span class="number">0</span>,len(nums)<span class="number">-1</span>
        <span class="keyword">while</span> i&lt;=j:
            <span class="keyword">if</span> nums[i]==val:
                nums[i]=nums[j]
                j-=<span class="number">1</span>
            <span class="keyword">else</span>:
                i+=<span class="number">1</span>
        <span class="keyword">return</span> i</code></pre>
<p>时间复杂度：O(n)，其中 n 为序列的长度。我们只需要遍历该序列至多一次。</p>
<p>空间复杂度：O(1)。我们只需要常数的空间保存若干变量。</p>
<p><strong>我的解法</strong>：基于解法2，加入了判断j位置元素是否为val(内部while)，保证只做一次赋值操作。</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span>
        i,j=<span class="number">0</span>,len(nums)<span class="number">-1</span>
        <span class="keyword">while</span> i&lt;=j:<span class="comment">#j后面全是为val的</span>
            <span class="keyword">if</span> nums[i]==val:<span class="comment">#该处理了</span>
                <span class="keyword">if</span> nums[j]!=val:
                    nums[i]=nums[j]
                    j-=<span class="number">1</span>
                    i+=<span class="number">1</span><span class="comment">#不加也能过，但是加了可以少判断一次</span>
                <span class="keyword">else</span>:
                    <span class="keyword">while</span> i&lt;=j <span class="keyword">and</span> nums[j]==val:
                        j-=<span class="number">1</span>
            <span class="keyword">else</span>:
                i+=<span class="number">1</span>
        <span class="keyword">return</span> i</code></pre>
<p>时间复杂度：O(n方？)，其中 n 为序列的长度。我们只需要遍历该序列至多一次。</p>
<p>空间复杂度：O(1)。我们只需要常数的空间保存若干变量。</p>
<p><img src="./28.png" alt="Alt text"><br>不需要考虑数组中超出新长度后面的元素。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>注意<strong>有序</strong>这个条件！</p>
<p><strong>我的解法：</strong>使用双指针，慢指针i以及慢指针i之前的元素都是不重复的，快指针j用于判断当前遍历到的元素是否重复（使用last指向当前慢指针维护的最右边的一个元素）</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span>
        n=len(nums)
        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="comment">#不加这个判断也能AC</span>
            <span class="keyword">return</span> <span class="number">0</span>
        i=<span class="number">0</span><span class="comment">#i以及i之前的元素都不重复</span>
        j=<span class="number">1</span><span class="comment">#j遍历</span>
        <span class="keyword">while</span> j&lt;n:
            last=nums[i]
            <span class="keyword">if</span> nums[j]!=nums[i]:
                i+=<span class="number">1</span>
                j+=<span class="number">1</span>
            <span class="keyword">else</span>:
                j+=<span class="number">1</span>
                <span class="keyword">if</span> j&lt;n <span class="keyword">and</span> nums[j]!=last:
                    nums[i+<span class="number">1</span>]=nums[j]
                    i+=<span class="number">1</span>
        <span class="keyword">return</span> i+<span class="number">1</span></code></pre>
<p><strong>官方代码</strong>：快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。不需要考虑0，因为当数组的长度大于 0时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素。</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> nums:
            <span class="keyword">return</span> <span class="number">0</span>

        n = len(nums)
        fast = slow = <span class="number">1</span>
        <span class="keyword">while</span> fast &lt; n:
            <span class="comment">#if nums[fast] != nums[slow - 1],这句和下面这句效果一样，但这样写能够和下一题官方题解统一起来，所以按照这句来理解比较好。因为slow维护当前处理好的序列，指向当前待处理元素的位置。</span>
            <span class="keyword">if</span> nums[fast] != nums[fast - <span class="number">1</span>]:<span class="comment">#新的元素出现</span>
                nums[slow] = nums[fast]
                slow += <span class="number">1</span>
            fast += <span class="number">1</span>

        <span class="keyword">return</span> slow</code></pre>
<p>时间复杂度：O(n)，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。</p>
<p>空间复杂度：O(1)。只需要使用常数的额外空间。</p>
<p><img src="./29.png" alt="Alt text"><br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>因为空间复杂度要求O(1)，所以不能哈希了。</p>
<p><strong>官方解法</strong></p>
<p>和上一题差不多，但没有Python的，我根据其它语言改写的Python版本</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span>
        i,j=<span class="number">2</span>,<span class="number">2</span><span class="comment">#i指向下一个待补充的位置，j遍历</span>
        n=len(nums)
        <span class="keyword">while</span> j&lt;n:
            <span class="keyword">if</span> nums[j]!=nums[i<span class="number">-2</span>]:<span class="comment">#必须是i-2！！！</span>
                nums[i]=nums[j]
                i+=<span class="number">1</span>
            j+=<span class="number">1</span>
        <span class="keyword">return</span> i</code></pre>
<p><strong>第三方题解通用解法</strong>：拓展到了最多保留重复的k个数。</p>
<p>由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留</p>
<p>对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span>
        <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(k)</span>:</span>
            u = <span class="number">0</span><span class="comment">#u指向当前待处理元素位置</span>
            <span class="keyword">for</span> x <span class="keyword">in</span> nums:
                <span class="keyword">if</span> u &lt; k <span class="keyword">or</span> nums[u - k] != x:
                    nums[u] = x
                    u += <span class="number">1</span>
            <span class="keyword">return</span> u
        <span class="keyword">return</span> solve(<span class="number">2</span>)</code></pre>
<p>以上两题思路是一样的：<strong>把所有不重复元素进行保留 可以通过双指针来实现 (该思维框架可以总结成模板运用到很多类似题)：即定义两个指针left和right，right从左到右把所有元素扫一遍，将不重复k次的元素赋给left的下一位</strong>。</p>
<h2 id="3-5"><a href="#3-5" class="headerlink" title="3-5"></a>3-5</h2><p><img src="./30.png" alt="Alt text"></p>
<p>计数排序：<br><img src="./31.png" alt="Alt text"></p>
<p>3路快排：<br><img src="./32.png" alt="Alt text"></p>
<p><img src="./33.png" alt="Alt text"></p>
<p>课后习题：<br><img src="./34.png" alt="Alt text"><br>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n</p>
<p>可以直接合并然后暴力排序，也可以开辟一个新数组，但是这样空间复杂度都是O(m+n).</p>
<p>数组有序！可以用双指针，此时空间复杂度为O(1)</p>
<p>如果直接合并到数组 nums1中，nums1中的元素可能会在取出之前被覆盖。那么如何直接避免覆盖 nums1中的元素呢？观察可知，nums1的后半部分是空的，可以直接覆盖而不会影响结果。因此可以指针设置为从后向前遍历，每次取两者之中的较大者放进 nums1的最后面。</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span>
        <span class="string">"""</span>
<span class="string">        Do not return anything, modify nums1 in-place instead.</span>
<span class="string">        """</span>
        i,j=m<span class="number">-1</span>,n<span class="number">-1</span><span class="comment">#遍历</span>
        tail=m+n<span class="number">-1</span><span class="comment">#tail后面是处理完的有序序列，不包括tail</span>
        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="number">0</span>:
            <span class="comment">#nums1处理完了</span>
            <span class="keyword">if</span> i==<span class="number">-1</span>:
                nums1[tail]=nums2[j]
                j-=<span class="number">1</span>

            <span class="comment">#nums2处理完了</span>
            <span class="keyword">elif</span> j==<span class="number">-1</span>:
                nums1[tail]=nums1[i]
                i-=<span class="number">1</span>

            <span class="keyword">elif</span> nums1[i] &gt; nums2[j]:
                nums1[tail]=nums1[i]
                i-=<span class="number">1</span>
            <span class="keyword">else</span>:
                nums1[tail]=nums2[j]
                j-=<span class="number">1</span>
            tail-=<span class="number">1</span></code></pre>
<p><img src="./35.png" alt="Alt text"></p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p><strong>方法1</strong>：基于快速排序，改为快速选择。</p>
<p><img src="./36.png" alt="Alt text"></p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self,nums,left,right)</span>:</span>
        pivot=right
        key=nums[pivot]
        <span class="keyword">while</span> left &lt; right:
            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left]&lt;=key:
                left+=<span class="number">1</span>
            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right]&gt;=key:
                right-=<span class="number">1</span>
            <span class="comment">#到这里，nums[left]&gt;pivot，nums[right]&lt;pivot，所以接下来就需要交换一下这两者</span>
            nums[left],nums[right]=nums[right],nums[left]
        nums[left],nums[pivot]=key,nums[left]<span class="comment">#必须是交换才可以！！！！</span>
        <span class="keyword">return</span> left

    <span class="comment">#普通快排，这里用不到 ，只是回顾一下</span>
    <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(self,nums, left, right)</span>:</span>
        <span class="keyword">if</span> left &lt; right:
            index = self.partition(nums, left, right)
            self.quicksort(nums, left, index<span class="number">-1</span>)
            self.quicksort(nums, index+<span class="number">1</span>, right)

    <span class="comment">#改编自quicksort</span>
    <span class="function"><span class="keyword">def</span> <span class="title">topk_split</span><span class="params">(self,nums, k, left, right)</span>:</span>
        <span class="comment">#寻找到第k个数停止递归，使得nums数组中index左边是前k个小的数，index右边是后面n-k个大的数</span>
        <span class="keyword">if</span> (left&lt;right):
            index = self.partition(nums, left, right)
            print(index)
            <span class="keyword">if</span> index==k:
                print(<span class="string">'找到'</span>,index)
                <span class="keyword">return</span> 
            <span class="keyword">elif</span> index &lt; k:
                self.topk_split(nums, k, index+<span class="number">1</span>, right)
            <span class="keyword">else</span>:
                self.topk_split(nums, k, left, index<span class="number">-1</span>)

    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k: int)</span> -&gt; int:</span>
        left,right=<span class="number">0</span>,len(nums)<span class="number">-1</span>

        <span class="comment">#self.quicksort(nums,left,right)</span>
        self.topk_split(nums,len(nums)-k,left,right)

        <span class="keyword">return</span> nums[len(nums)-k]</code></pre>
<p>如果pivot取值为left，则需要调换一下两个while的顺序：</p>
<pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self,nums,left,right)</span>:</span>
    pivot=left
    key=nums[pivot]
    <span class="keyword">while</span> left &lt; right:
        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right]&gt;=key:
            right-=<span class="number">1</span>
        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left]&lt;=key:
            left+=<span class="number">1</span>

        <span class="comment">#到这里，nums[left]&gt;key，nums[right]&lt;key，所以接下来就需要交换一下这两者</span>
        nums[left],nums[right]=nums[right],nums[left]
    nums[left],nums[pivot]=key,nums[left]<span class="comment">#必须是交换才可以！！！！</span>
    <span class="keyword">return</span> left</code></pre>
<p><strong>方法2：</strong>堆排序</p>
<p>调包：</p>
<pre><code class="python"><span class="keyword">import</span> heapq
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span>
        maxHeap = []
        <span class="keyword">for</span> x <span class="keyword">in</span> nums:
            heapq.heappush(maxHeap, -x)
        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k - <span class="number">1</span>):
            heapq.heappop(maxHeap)
        <span class="keyword">return</span> -maxHeap[<span class="number">0</span>]</code></pre>
<p>手写堆：</p>
<p>先复习一下堆：</p>
<p><img src="./37.png" alt="Alt text"></p>
<p>堆是完全二叉树</p>
<p><img src="./38.png" alt="Alt text"><br><img src="./39.png" alt="Alt text"></p>
<p>原地堆排序代码</p>
<pre><code class="python"><span class="comment">#原地堆排序</span>
<span class="comment">#最后一个非叶子节点的索引是(n-1)/2,(n-2)/2 ？都可以吧，前者多了一次不通过的判断</span>

<span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(arr,n)</span>:</span>
    <span class="comment">#建堆</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range((n<span class="number">-2</span>)//<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>):
        shiftdown(arr,n,i)
    print(arr)<span class="comment">#[999, 9, 10, 8, 5, 1, 1, 2]</span>

    <span class="comment">#原地堆排序</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):
        arr[<span class="number">0</span>],arr[i]=arr[i],arr[<span class="number">0</span>]
        shiftdown(arr,i,<span class="number">0</span>)
    print(arr)<span class="comment">#[1, 1, 2, 5, 8, 9, 10, 999]</span>

<span class="function"><span class="keyword">def</span> <span class="title">shiftdown</span><span class="params">(arr,n,k)</span>:</span>
    print(k)
    <span class="keyword">while</span> <span class="number">2</span>*k+<span class="number">1</span>&lt;n:
        j=<span class="number">2</span>*k+<span class="number">1</span>
        <span class="keyword">if</span> j+<span class="number">1</span>&lt;n <span class="keyword">and</span> arr[j+<span class="number">1</span>]&gt;arr[j]:
            j+=<span class="number">1</span>
        <span class="keyword">if</span> arr[k]&gt;=arr[j]:
            <span class="keyword">break</span>
        arr[k],arr[j]=arr[j],arr[k]
        k=j


<span class="comment">#测试栗子</span>
arr=[<span class="number">4</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">999</span>,<span class="number">8</span>]
n=<span class="number">9</span>
heapSort(arr,n)
print(arr)<span class="comment">#[1, 1, 2, 5, 8, 9, 999,3]</span></code></pre>
<p>先构建堆:  从最后一个非叶子节点开始，从下往上、从右到左依次进行比较</p>
<p>那么，如何确定最后一个非叶子节点的下标？</p>
<p>假设给定的序列长度为n，则最后一个孩子节点的下标为n-1，设其父节点下标为p，分两种情况讨论：</p>
<p>最终节点为左孩子节点，则有n-1=2*p+1，即p=(n-2)/2</p>
<p>最终节点为右孩子节点，则有n-1=2*p+2，即p=(n-3)/2 </p>
<p>根据地板除向下取整的特性，我们选择p=(n-2)//2就都能满足这两种情况。</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="comment">#原地堆排序</span>
    <span class="comment">#最后一个非叶子节点的索引是(n-1)/2,(n-2)/2 ？都可以吧，前者多了一次不通过的判断</span>
    <span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(self,arr,n)</span>:</span>
        <span class="comment">#建堆，后续叶子节点已经是满足堆的定义了</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range((n<span class="number">-2</span>)//<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>):
            self.shiftdown(arr,n,i)
        <span class="comment">#print(arr)#[999, 10, 9, 8, 2, 5, 1, 1, 4]</span>
        <span class="comment">#原地堆排序</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):
            arr[<span class="number">0</span>],arr[i]=arr[i],arr[<span class="number">0</span>]
            self.shiftdown(arr,i,<span class="number">0</span>)
        <span class="comment">#print(arr)#[1, 1, 2, 4, 5, 8, 9, 10, 999]</span>



    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span>
        n = len(nums)
        <span class="comment">#建堆</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range((n<span class="number">-2</span>)//<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>):
            self.shiftdown(nums,n,i)
        <span class="comment">#求解</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,n-k,<span class="number">-1</span>):
            nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]
            self.shiftdown(nums,i,<span class="number">0</span>)
        <span class="keyword">return</span> nums[<span class="number">0</span>]<span class="comment">#经过k-1次操作，此时堆顶就是第k大的数</span>


    <span class="function"><span class="keyword">def</span> <span class="title">shiftdown</span><span class="params">(self,arr,n,k)</span>:</span>
        <span class="comment">#print(k)</span>
        <span class="keyword">while</span> <span class="number">2</span>*k+<span class="number">1</span>&lt;n:
            j=<span class="number">2</span>*k+<span class="number">1</span>
            <span class="keyword">if</span> j+<span class="number">1</span>&lt;n <span class="keyword">and</span> arr[j+<span class="number">1</span>]&gt;arr[j]:
                j+=<span class="number">1</span>
            <span class="keyword">if</span> arr[k]&gt;=arr[j]:
                <span class="keyword">break</span>
            arr[k],arr[j]=arr[j],arr[k]
            k=j</code></pre>
<h2 id="3-6"><a href="#3-6" class="headerlink" title="3-6"></a>3-6</h2><p><img src="./40.png" alt="Alt text"><br>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length.</p>
<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>
<p><img src="./41.png" alt="Alt text"></p>
<p><strong>二分</strong>的时间复杂度是O(nlogn)</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers: List[int], target: int)</span> -&gt; List[int]:</span>
        n = len(numbers)
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
            low, high = i + <span class="number">1</span>, n - <span class="number">1</span>
            <span class="keyword">while</span> low &lt;= high:
                mid = (low + high) // <span class="number">2</span>
                <span class="keyword">if</span> numbers[mid] == target - numbers[i]:
                    <span class="keyword">return</span> [i + <span class="number">1</span>, mid + <span class="number">1</span>]
                <span class="keyword">elif</span> numbers[mid] &gt; target - numbers[i]:
                    high = mid - <span class="number">1</span>
                <span class="keyword">else</span>:
                    low = mid + <span class="number">1</span>

        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</code></pre>
<p><strong>对撞指针法</strong>：<br><img src="./42.png" alt="Alt text"></p>
<p>时间复杂度：O(n)，其中 n 是数组的长度。两个指针移动的总次数最多为 n 次。</p>
<p>空间复杂度：O(1)。</p>
<p>课后习题：</p>
<p><img src="./43.png" alt="Alt text"><br>我的解法，和官方解法3相同，使用对撞指针，空间复杂度O(1)，时间复杂度O(字符串长度)：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> s:
            <span class="keyword">return</span> <span class="literal">True</span>
        <span class="function"><span class="keyword">def</span> <span class="title">check_valid</span><span class="params">(c)</span>:</span>
            <span class="keyword">if</span> c.isdigit() <span class="keyword">or</span> c.isalpha():
                <span class="keyword">return</span> <span class="literal">True</span>
            <span class="keyword">else</span>:
                <span class="keyword">return</span> <span class="literal">False</span>

        n=len(s)
        i,j=<span class="number">0</span>,n<span class="number">-1</span>
        <span class="keyword">while</span> i&lt;j:
            <span class="keyword">while</span> <span class="keyword">not</span> check_valid(s[i]) <span class="keyword">and</span> i&lt;j:
                i+=<span class="number">1</span>
            <span class="keyword">while</span> <span class="keyword">not</span> check_valid(s[j]) <span class="keyword">and</span> i&lt;j:
                j-=<span class="number">1</span>
            t1,t2=s[i],s[j]
            <span class="keyword">if</span> t1.isalpha():
                t1=t1.lower()
            <span class="keyword">if</span> t2.isalpha():
                t2=t2.lower()
            <span class="keyword">if</span> i&lt;j <span class="keyword">and</span> t1!=t2:
                <span class="keyword">return</span> <span class="literal">False</span>
            i+=<span class="number">1</span>
            j-=<span class="number">1</span>
        <span class="keyword">return</span> <span class="literal">True</span></code></pre>
<p><img src="./44.png" alt="Alt text"><br>直接对撞。</p>
<p><img src="./45.png" alt="Alt text"><br>我的解法：对撞指针：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s: str)</span> -&gt; str:</span>
        n=len(s)
        lis=[<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>]
        slis=[i  <span class="keyword">for</span> i <span class="keyword">in</span> s]
        i=<span class="number">0</span>
        j=n<span class="number">-1</span>
        <span class="keyword">while</span> i&lt;j:
            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> lis:
                i+=<span class="number">1</span>
            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> lis:
                j-=<span class="number">1</span>
            slis[i],slis[j]=slis[j],slis[i]
            i+=<span class="number">1</span>
            j-=<span class="number">1</span>
        <span class="keyword">return</span> <span class="string">''</span>.join(slis)</code></pre>
<p><img src="./46.png" alt="Alt text"></p>
<p>还是对撞指针，理论证明略</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span>
        n=len(height)
        i,j=<span class="number">0</span>,n<span class="number">-1</span>
        maxArea=<span class="number">0</span>
        <span class="keyword">while</span> i&lt;j:
            area=min(height[i],height[j])*(j-i)
            <span class="keyword">if</span> area&gt;maxArea:
                maxArea=area
            <span class="keyword">if</span> height[i]&lt;height[j]:
                i+=<span class="number">1</span>
            <span class="keyword">else</span>:
                j-=<span class="number">1</span>
        <span class="keyword">return</span> maxArea</code></pre>
<h2 id="3-7"><a href="#3-7" class="headerlink" title="3-7"></a>3-7</h2><p>双索引技术：<strong>滑动窗口</strong></p>
<p>滑动窗口算法可以用以解决数组/字符串的子元素问题，它可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。</p>
<p><img src="./47.png" alt="Alt text"></p>
<p><img src="./48.png" alt="Alt text"></p>
<p>暴力解法可以优化求和操作，使得时间复杂度变成O(n^2)，官方代码如下：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> nums:
            <span class="keyword">return</span> <span class="number">0</span>

        n = len(nums)
        ans = n + <span class="number">1</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
            total = <span class="number">0</span>
            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):
                total += nums[j]
                <span class="keyword">if</span> total &gt;= s:
                    ans = min(ans, j - i + <span class="number">1</span>)
                    <span class="keyword">break</span>

        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans
</code></pre>
<p><strong>滑动窗口：</strong></p>
<p>注意到<strong>连续</strong>的条件</p>
<p><img src="./49.png" alt="Alt text"><br>我改写成了Python版本的：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> nums:
            <span class="keyword">return</span> <span class="number">0</span>

        n = len(nums)
        res = n + <span class="number">1</span>
        i,j = <span class="number">0</span>, <span class="number">-1</span><span class="comment">#j从0开始会报错</span>
        sum = <span class="number">0</span>
        <span class="keyword">while</span> i &lt; n:
            <span class="keyword">if</span> j+<span class="number">1</span>&lt;n <span class="keyword">and</span> sum&lt;s:
                sum+=nums[j+<span class="number">1</span>]
                j+=<span class="number">1</span>
            <span class="keyword">else</span>:
                sum-=nums[i]
                i+=<span class="number">1</span>
            <span class="keyword">if</span> sum&gt;=s:
                res=min(res,j-i+<span class="number">1</span>)

        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> res == n + <span class="number">1</span> <span class="keyword">else</span> res</code></pre>
<p>官方提供的Python版本</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> nums:
            <span class="keyword">return</span> <span class="number">0</span>

        n = len(nums)
        ans = n + <span class="number">1</span>
        start, end = <span class="number">0</span>, <span class="number">0</span>
        total = <span class="number">0</span>
        <span class="keyword">while</span> end &lt; n:
            total += nums[end]
            <span class="keyword">while</span> total &gt;= s:
                ans = min(ans, end - start + <span class="number">1</span>)
                total -= nums[start]
                start += <span class="number">1</span>
            end += <span class="number">1</span>

        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</code></pre>
<h2 id="3-8"><a href="#3-8" class="headerlink" title="3-8"></a>3-8</h2><p>还是滑动窗口的栗子<br><img src="./50.png" alt="Alt text"></p>
<p><img src="./51.png" alt="Alt text"></p>
<p>对应的Python版本代码（改自上述C++代码以及官方代码）：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span>
        <span class="comment"># 哈希集合，记录每个字符是否出现过</span>
        occ = set()
        n = len(s)
        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span>
        i,rk, ans =<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>
        <span class="keyword">while</span> i&lt;n:
            <span class="keyword">if</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:
                <span class="comment"># 不断地移动右指针</span>
                occ.add(s[rk + <span class="number">1</span>])
                rk += <span class="number">1</span>
            <span class="keyword">else</span>:
                <span class="comment"># 左指针向右移动一格，移除一个字符</span>
                occ.remove(s[i])
                i+=<span class="number">1</span>

            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span>
            ans = max(ans, rk - i + <span class="number">1</span>)
        <span class="keyword">return</span> ans</code></pre>
<p>官方提供的代码（不顺）：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span>
        <span class="comment"># 哈希集合，记录每个字符是否出现过</span>
        occ = set()
        n = len(s)
        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span>
        rk, ans = <span class="number">-1</span>, <span class="number">0</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
            <span class="keyword">if</span> i != <span class="number">0</span>:
                <span class="comment"># 左指针向右移动一格，移除一个字符</span>
                occ.remove(s[i - <span class="number">1</span>])
            <span class="keyword">while</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:
                <span class="comment"># 不断地移动右指针</span>
                occ.add(s[rk + <span class="number">1</span>])
                rk += <span class="number">1</span>
            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span>
            ans = max(ans, rk - i + <span class="number">1</span>)
        <span class="keyword">return</span> ans</code></pre>
<p>课后习题：<br><img src="./52.png" alt="Alt text"></p>
<p>什么情况下会想到滑动窗口法：</p>
<p>任何题目如果没有思路其实都可以想一下暴力解法。这道题暴力解法思路简单：</p>
<pre><code>遍历任意i，j，使得i和j之间的子串长度，等于p串的长度。该子串称之为x。该步复杂度为O（n）。
判断x是否与p是异位词。是的话，则把i加入答案中。该步复杂度为O（n）。</code></pre><p>暴力法的复杂度为O（n^2）。显然不高效。</p>
<p>评论区<strong>滑动窗口+空间换时间</strong>的答案：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> -&gt; List[int]:</span>
        n, m, res = len(s), len(p), []
        <span class="keyword">if</span> n &lt; m: <span class="keyword">return</span> res
        p_cnt = [<span class="number">0</span>] * <span class="number">26</span>
        s_cnt = [<span class="number">0</span>] * <span class="number">26</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):
            p_cnt[ord(p[i]) - ord(<span class="string">'a'</span>)] += <span class="number">1</span>
            s_cnt[ord(s[i]) - ord(<span class="string">'a'</span>)] += <span class="number">1</span>
        <span class="keyword">if</span> s_cnt == p_cnt:
            res.append(<span class="number">0</span>)

        <span class="keyword">for</span> i <span class="keyword">in</span> range(m, n):
            s_cnt[ord(s[i - m]) - ord(<span class="string">'a'</span>)] -= <span class="number">1</span>
            s_cnt[ord(s[i]) - ord(<span class="string">'a'</span>)] += <span class="number">1</span>
            <span class="keyword">if</span> s_cnt == p_cnt:
                res.append(i - m + <span class="number">1</span>)
        <span class="keyword">return</span> res</code></pre>
<p>时间复杂度：O(n)，for循环有O(n)，数组的长度是常数，所以数组的比较也是常数级别的，那最终的时间复杂度就是O(n)</p>
<p>空间复杂度：O(1)，需要常数级别的额外空间</p>
<p>评论区<strong>滑动窗口+双指针</strong>解法（还没看懂，不想看了）：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> -&gt; List[int]:</span>
        n, m, res = len(s), len(p), []
        <span class="keyword">if</span> n &lt; m: <span class="keyword">return</span> res
        p_cnt = [<span class="number">0</span>] * <span class="number">26</span>
        s_cnt = [<span class="number">0</span>] * <span class="number">26</span>

        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):
            p_cnt[ord(p[i]) - ord(<span class="string">'a'</span>)] += <span class="number">1</span>

        left = <span class="number">0</span>
        <span class="keyword">for</span> right <span class="keyword">in</span> range(n):
            cur_right = ord(s[right]) - ord(<span class="string">'a'</span>)
            s_cnt[cur_right] += <span class="number">1</span>
            <span class="keyword">while</span> s_cnt[cur_right] &gt; p_cnt[cur_right]:
                cur_left = ord(s[left]) - ord(<span class="string">'a'</span>)
                s_cnt[cur_left] -= <span class="number">1</span>
                left += <span class="number">1</span>
            <span class="keyword">if</span> right - left + <span class="number">1</span> == m:
                res.append(left)
        <span class="keyword">return</span> res</code></pre>
<p><img src="./53.png" alt="Alt text"></p>
<h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><p>滑动窗口不怎么会，之后还得看。</p>
<h1 id="第四章：查找问题"><a href="#第四章：查找问题" class="headerlink" title="第四章：查找问题"></a>第四章：查找问题</h1><h2 id="4-1set"><a href="#4-1set" class="headerlink" title="4-1set"></a>4-1set</h2><p><img src="./54.png" alt="Alt text"><br>我的解法，使用set</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>
        set1=set(nums1)
        record=set()<span class="comment">#记录结果</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:
            <span class="keyword">if</span> i <span class="keyword">in</span> set1:
                record.add(i)
        <span class="keyword">return</span> list(record)</code></pre>
<h2 id="4-2-map-dict"><a href="#4-2-map-dict" class="headerlink" title="4-2 map(dict)"></a>4-2 map(dict)</h2><p><img src="./55.png" alt="Alt text"><br>我的解法，使用dict</p>
<p>在Python中，字典是通过散列表（哈希表）实现的</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span>
        s1,s2=nums1,nums2
        <span class="comment">#保证s1长度大于等于s2长度</span>
        <span class="keyword">if</span> len(nums1)&lt;len(nums2):
            s1=nums2
            s2=nums1
        dic={}
        <span class="keyword">for</span> item <span class="keyword">in</span> s1:
            <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> dic:
                dic[item]=<span class="number">1</span>
            <span class="keyword">else</span>:
                dic[item]+=<span class="number">1</span>

        res=[]
        <span class="keyword">for</span> item <span class="keyword">in</span> s2:
            <span class="keyword">if</span> item <span class="keyword">in</span> dic.keys() <span class="keyword">and</span> dic[item]&gt;<span class="number">0</span>:
                res.append(item)
                dic[item]-=<span class="number">1</span>
        <span class="keyword">return</span> res</code></pre>
<h2 id="4-3"><a href="#4-3" class="headerlink" title="4-3"></a>4-3</h2><p><img src="./56.png" alt="Alt text"><br>哈希表很牛，但元素是无序的。</p>
<p>因此，二分搜索树可以解决类似下面的有序问题，而哈希表不能：<br><img src="./57.png" alt="Alt text"></p>
<p><img src="./58.png" alt="Alt text"></p>
<p>课后习题：<br><img src="./59.png" alt="Alt text"><br>我的解法，使用dict</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span>
        s1,s2=s,t
        <span class="keyword">if</span> len(s1)!=len(s2):
            <span class="keyword">return</span> <span class="literal">False</span>
        dic={}
        <span class="keyword">for</span> item <span class="keyword">in</span> s1:
            <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> dic:
                dic[item]=<span class="number">1</span>
            <span class="keyword">else</span>:
                dic[item]+=<span class="number">1</span>

        <span class="keyword">for</span> item <span class="keyword">in</span> s2:
            <span class="keyword">if</span> item <span class="keyword">in</span> dic <span class="keyword">and</span> dic[item]&gt;<span class="number">0</span>:
                dic[item]-=<span class="number">1</span>
            <span class="keyword">else</span>:
                <span class="keyword">return</span> <span class="literal">False</span>
        <span class="keyword">return</span> <span class="literal">True</span></code></pre>
<p><img src="./60.png" alt="Alt text"></p>
<p><img src="./61.png" alt="Alt text"></p>
<p><strong>解法1：哈希表</strong><br>思想：如果出现重复，则陷入循环</p>
<p>第 1 部分我们按照题目的要求做数位分离，求平方和。</p>
<p>第 2 部分可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。</p>
<pre><code>如果它不在哈希集合中，我们应该添加它。
如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。</code></pre><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(n)</span>:</span>
        total_sum = <span class="number">0</span>
        <span class="keyword">while</span> n &gt; <span class="number">0</span>:
            n, digit = divmod(n, <span class="number">10</span>)
            total_sum += digit ** <span class="number">2</span>
        <span class="keyword">return</span> total_sum

    seen = set()
    <span class="comment">#n!=1，说明还没不能确定n是快乐数，否则</span>
    <span class="comment">#n not in seen ，说明还没有进入无限循环，否则进入了无限循环(此时n不等于1)</span>
    <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:
        seen.add(n)
        n = get_next(n)

    <span class="keyword">return</span> n == <span class="number">1</span></code></pre>
<p>或者这样写</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span>

        <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(n)</span>:</span>
            total_sum = <span class="number">0</span>
            <span class="keyword">while</span> n &gt; <span class="number">0</span>:
                n, digit = divmod(n, <span class="number">10</span>)
                total_sum += digit ** <span class="number">2</span>
            <span class="keyword">return</span> total_sum

        seen = set()
        <span class="comment">#n not in seen ，说明还没有进入无限循环，否则进入了无限循环(此时n不等于1)</span>
        <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:
            <span class="keyword">if</span> n==<span class="number">1</span>:
                <span class="keyword">return</span> <span class="literal">True</span>
            seen.add(n)
            n = get_next(n)

        <span class="keyword">return</span> <span class="literal">False</span><span class="comment">#此时n in seen，出现不为1的重复数字</span></code></pre>
<p><strong>解法2：快慢指针</strong>：</p>
<p>意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的慢的称为 “乌龟”，跑得快的称为 “兔子”。</p>
<p>我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 getNext(n) 函数的嵌套调用）。</p>
<p><strong>如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。</strong></p>
<p><strong>如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。</strong></p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span>  
        <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(number)</span>:</span>
            total_sum = <span class="number">0</span>
            <span class="keyword">while</span> number &gt; <span class="number">0</span>:
                number, digit = divmod(number, <span class="number">10</span>)
                total_sum += digit ** <span class="number">2</span>
            <span class="keyword">return</span> total_sum

        slow_runner = n
        fast_runner = get_next(n)
        <span class="comment">#如果满足第一个条件，则不是环，则是快乐数；</span>
        <span class="comment">#如果满足第二个条件，则有环，则不是快乐数</span>
        <span class="comment">#两个条件必满足其一</span>
        <span class="keyword">while</span> fast_runner != <span class="number">1</span> <span class="keyword">and</span> slow_runner != fast_runner:
            slow_runner = get_next(slow_runner)<span class="comment">#走一步</span>
            fast_runner = get_next(get_next(fast_runner))<span class="comment">#走两步</span>
        <span class="keyword">return</span> fast_runner == <span class="number">1</span></code></pre>
<p><img src="./62.png" alt="Alt text"><br>你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。    </p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span><span class="params">(self, pattern: str, s: str)</span> -&gt; bool:</span>
        ch2word={}
        word2ch={}

        words=s.split(<span class="string">' '</span>)

        <span class="keyword">if</span> len(words) !=len(pattern):
            <span class="keyword">return</span> <span class="literal">False</span>



        <span class="keyword">for</span> ch,word <span class="keyword">in</span> zip(pattern,words):
            <span class="comment">#当前word是word2ch的key，但是对应value不是当前ch</span>
            <span class="comment">#or 当前ch是ch2word的key，但是对应value不是当前word</span>
            <span class="keyword">if</span> (word <span class="keyword">in</span> word2ch <span class="keyword">and</span> word2ch[word] !=ch) <span class="keyword">or</span> (ch <span class="keyword">in</span> ch2word <span class="keyword">and</span> ch2word[ch]!=word):
                <span class="keyword">return</span> <span class="literal">False</span>

            ch2word[ch]=word
            word2ch[word]=ch
        <span class="keyword">return</span> <span class="literal">True</span></code></pre>
<p><img src="./63.png" alt="Alt text"></p>
<p>可以假设 s 和 t 长度相同。</p>
<p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<p>使用哈希表，此时和上一题一样的代码：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span>
        s2t,t2s={},{}
        <span class="keyword">for</span> i ,j  <span class="keyword">in</span> zip(s,t):
            <span class="keyword">if</span> (i <span class="keyword">in</span> s2t <span class="keyword">and</span> s2t[i]!=j) <span class="keyword">or</span> (j <span class="keyword">in</span> t2s <span class="keyword">and</span> t2s[j]!=i):
                <span class="keyword">return</span> <span class="literal">False</span>
            s2t[i]=j
            t2s[j]=i
        <span class="keyword">return</span> <span class="literal">True</span></code></pre>
<p>以上两道题一样的，只是第一题多做了个split.</p>
<p><strong>对于第二个题，还有一种思路</strong>：</p>
<p>之前，我们判断 s 和 t 是否一一对应，通过对两个方向分别考虑来解决的。</p>
<p>这里的话，我们找一个第三方来解决，即，按照字母出现的顺序，把两个字符串都映射到另一个集合中。</p>
<p>举个现实生活中的例子，一个人说中文，一个人说法语，怎么判断他们说的是一个意思呢？把中文翻译成英语，把法语也翻译成英语，然后看最后的英语是否相同即可。</p>
<pre><code>将第一个出现的字母映射成 1，第二个出现的字母映射成 2

对于 egg
e -&gt; 1
g -&gt; 2
也就是将 egg 的 e 换成 1, g 换成 2, 就变成了 122

对于 add
a -&gt; 1
d -&gt; 2
也就是将 add 的 a 换成 1, d 换成 2, 就变成了 122

egg -&gt; 122, add -&gt; 122
都变成了 122，所以两个字符串异构。</code></pre><p>代码的话，只需要将两个字符串分别翻译成第三种类型即可，比如翻译成数字串</p>
<p>我们也可以用两个 map 分别记录两个字符串每个字母的映射。<strong>将所有字母初始都映射到 0</strong>。记录过程中，如果发现了当前映射不一致，就可以立即返回 false 了。</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span><span class="params">(self, s, t)</span>:</span>
        n=len(s)
        s_dic={}
        t_dic={}
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
            <span class="comment">#当前的映射值是否相同</span>
            <span class="keyword">if</span> s_dic.get(s[i],<span class="number">0</span>)!=t_dic.get(t[i],<span class="number">0</span>):
                <span class="keyword">return</span> <span class="literal">False</span>
            <span class="comment">#此时相等（都出现过 or 都没出现过）</span>
            <span class="comment">#若都没出现过，则加入字典里，否则什么都不做</span>
            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> s_dic:
                s_dic[s[i]]=i+<span class="number">1</span>
                t_dic[t[i]]=i+<span class="number">1</span>

        <span class="keyword">return</span> <span class="literal">True</span></code></pre>
<p>这种思想其实可以直调用Python的index：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span><span class="params">(self, s, t)</span>:</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):
            <span class="keyword">if</span> s.index(s[i]) != t.index(t[i]):

                <span class="keyword">return</span> <span class="literal">False</span>
        <span class="keyword">return</span> <span class="literal">True</span>
</code></pre>
<p><img src="./64.png" alt="Alt text"><br>我的解法：哈希表(字典排序)：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">frequencySort</span><span class="params">(self, s: str)</span> -&gt; str:</span>
        dic={}
        <span class="comment">#将每个字符的出现频次存入哈希表</span>
        <span class="keyword">for</span> le <span class="keyword">in</span> s:
            <span class="keyword">if</span> le <span class="keyword">not</span> <span class="keyword">in</span> dic:
                dic[le]=<span class="number">1</span>
            <span class="keyword">else</span>:
                dic[le]+=<span class="number">1</span>

        lis=sorted(dic.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="literal">True</span>)

        res=[]

        <span class="keyword">for</span> k,v <span class="keyword">in</span> lis:
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(v):
                res.append(k)

        <span class="keyword">return</span> <span class="string">''</span>.join(res)</code></pre>
<p>时间复杂度：O(n+klog⁡k)</p>
<p>O(n + k log k)，其中 n 是字符串 s 的长度，k是字符串 s 包含的不同字符的个数</p>
<p>遍历字符串统计每个字符出现的频率需要 O(n)的时间。<br>将字符按照出现频率排序需要 O(klogk) 的时间。<br>生成排序后的字符串，需要遍历 k 个不同字符，需要 O(k)的时间，拼接字符串需要 O(n)的时间。</p>
<p>空间复杂度：O(n+k)，其中 n 是字符串 s 的长度，k 是字符串 s 包含的不同字符的个数。空间复杂度主要取决于哈希表、列表和生成的排序后的字符串。</p>
<h2 id="4-4"><a href="#4-4" class="headerlink" title="4-4"></a>4-4</h2><p><img src="./65.png" alt="Alt text"></p>
<p><img src="./66.png" alt="Alt text"></p>
<p>官方Python版本：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span>
        hashtable = dict()
        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):
            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:
                <span class="keyword">return</span> [hashtable[target - num], i]
            hashtable[nums[i]] = i
        <span class="keyword">return</span> []</code></pre>
<p>课后习题：<br><img src="./67.png" alt="Alt text"><br>注意：答案中不可以包含重复的三元组。</p>
<p><strong>官方题解</strong>：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span>
        n = len(nums)
        nums.sort()
        ans = list()

        <span class="comment"># 枚举 a</span>
        <span class="keyword">for</span> first <span class="keyword">in</span> range(n):
            <span class="comment"># 需要和上一次枚举的数不相同</span>
            <span class="keyword">if</span> first &gt; <span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first - <span class="number">1</span>]:
                <span class="keyword">continue</span>
            <span class="comment"># c 对应的指针初始指向数组的最右端</span>
            third = n - <span class="number">1</span>
            target = -nums[first]
            <span class="comment"># 枚举 b</span>
            <span class="keyword">for</span> second <span class="keyword">in</span> range(first + <span class="number">1</span>, n):
                <span class="comment"># 需要和上一次枚举的数不相同</span>
                <span class="keyword">if</span> second &gt; first + <span class="number">1</span> <span class="keyword">and</span> nums[second] == nums[second - <span class="number">1</span>]:
                    <span class="keyword">continue</span>
                <span class="comment"># 需要保证 b 的指针在 c 的指针的左侧</span>
                <span class="keyword">while</span> second &lt; third <span class="keyword">and</span> nums[second] + nums[third] &gt; target:
                    third -= <span class="number">1</span>
                <span class="comment"># 如果指针重合，随着 b 后续的增加</span>
                <span class="comment"># 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span>
                <span class="keyword">if</span> second == third:
                    <span class="keyword">break</span>
                <span class="keyword">if</span> nums[second] + nums[third] == target:
                    ans.append([nums[first], nums[second], nums[third]])

        <span class="keyword">return</span> ans</code></pre>
<p><strong>评论区比较易懂的代码</strong>：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span>

        n=len(nums)
        res=[]
        <span class="keyword">if</span>(<span class="keyword">not</span> nums <span class="keyword">or</span> n&lt;<span class="number">3</span>):
            <span class="keyword">return</span> []
        nums.sort()
        res=[]
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>):
                <span class="keyword">return</span> res
            <span class="comment">#结果不能重复</span>
            <span class="comment">#之所以只比较相邻，是因为数组已经做了排序</span>
            <span class="keyword">if</span>(i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]):
                <span class="keyword">continue</span>
            L=i+<span class="number">1</span>
            R=n<span class="number">-1</span>
            <span class="keyword">while</span>(L&lt;R):
                <span class="keyword">if</span>(nums[i]+nums[L]+nums[R]==<span class="number">0</span>):
                    res.append([nums[i],nums[L],nums[R]])
                    <span class="keyword">while</span>(L&lt;R <span class="keyword">and</span> nums[L]==nums[L+<span class="number">1</span>]):
                        L=L+<span class="number">1</span>
                    <span class="keyword">while</span>(L&lt;R <span class="keyword">and</span> nums[R]==nums[R<span class="number">-1</span>]):
                        R=R<span class="number">-1</span>
                    L=L+<span class="number">1</span>
                    R=R<span class="number">-1</span>
                <span class="keyword">elif</span>(nums[i]+nums[L]+nums[R]&gt;<span class="number">0</span>):
                    R=R<span class="number">-1</span>
                <span class="keyword">else</span>:
                    L=L+<span class="number">1</span>
        <span class="keyword">return</span> res</code></pre>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p>
<p><img src="./68.png" alt="Alt text"><br>和上题一样，官方貌似参考了上题中的评论区解法</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span>
        quadruplets = list()
        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> len(nums) &lt; <span class="number">4</span>:
            <span class="keyword">return</span> quadruplets

        nums.sort()
        length = len(nums)
        <span class="keyword">for</span> i <span class="keyword">in</span> range(length - <span class="number">3</span>):
            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:
                <span class="keyword">continue</span>
            <span class="keyword">if</span> nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target:
                <span class="keyword">break</span>
            <span class="keyword">if</span> nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target:
                <span class="keyword">continue</span>
            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, length - <span class="number">2</span>):
                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:
                    <span class="keyword">continue</span>
                <span class="keyword">if</span> nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target:
                    <span class="keyword">break</span>
                <span class="keyword">if</span> nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target:
                    <span class="keyword">continue</span>
                left, right = j + <span class="number">1</span>, length - <span class="number">1</span>
                <span class="keyword">while</span> left &lt; right:
                    total = nums[i] + nums[j] + nums[left] + nums[right]
                    <span class="keyword">if</span> total == target:
                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])
                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:
                            left += <span class="number">1</span>
                        left += <span class="number">1</span>
                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:
                            right -= <span class="number">1</span>
                        right -= <span class="number">1</span>
                    <span class="keyword">elif</span> total &lt; target:
                        left += <span class="number">1</span>
                    <span class="keyword">else</span>:
                        right -= <span class="number">1</span>

        <span class="keyword">return</span> quadruplets</code></pre>
<p><img src="./69.png" alt="Alt text"><br>我的解法：双指针，在上面题代码上修改得到</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span>

        n=len(nums)

        nums.sort()
        print(<span class="string">'nums'</span>,nums)

        res=abs(target+<span class="number">10000</span>)

        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
            L=i+<span class="number">1</span>
            R=n<span class="number">-1</span>
            <span class="keyword">while</span>(L&lt;R):
                <span class="keyword">if</span>(abs(nums[i]+nums[L]+nums[R]-target)&lt;res):
                    ret=nums[i]+nums[L]+nums[R]<span class="comment">#三数之和</span>
                    res=abs(ret-target)
                <span class="comment">#因为有序</span>
                <span class="keyword">if</span> nums[i]+nums[L]+nums[R]&lt;target:
                    L=L+<span class="number">1</span>
                <span class="keyword">else</span>:
                    R=R<span class="number">-1</span>
        <span class="keyword">return</span> ret</code></pre>
<p>也可以这样，三数之和等于target时就直接返回，可以kuai一点点</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span>

        n=len(nums)

        nums.sort()
        print(<span class="string">'nums'</span>,nums)

        res=abs(target+<span class="number">10000</span>)

        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
            L=i+<span class="number">1</span>
            R=n<span class="number">-1</span>
            <span class="keyword">while</span>(L&lt;R):
                <span class="keyword">if</span>(abs(nums[i]+nums[L]+nums[R]-target)&lt;res):
                    ret=nums[i]+nums[L]+nums[R]<span class="comment">#三数之和</span>
                    res=abs(ret-target)
                <span class="comment">#因为有序</span>
                <span class="keyword">if</span> nums[i]+nums[L]+nums[R]&lt;target:
                    L=L+<span class="number">1</span>
                <span class="keyword">elif</span> nums[i]+nums[L]+nums[R]&gt;target:
                    R=R<span class="number">-1</span>
                <span class="keyword">else</span>:
                    <span class="keyword">return</span> nums[i]+nums[L]+nums[R]
        <span class="keyword">return</span> ret</code></pre>
<h2 id="4-5"><a href="#4-5" class="headerlink" title="4-5"></a>4-5</h2><p><img src="./70.png" alt="Alt text"></p>
<p><img src="./71.png" alt="Alt text"></p>
<p><img src="./72.png" alt="Alt text"></p>
<p>我写的Python版本答案：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span><span class="params">(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int])</span> -&gt; int:</span>
        dic=dict()
        <span class="keyword">for</span> a <span class="keyword">in</span> nums3:
            <span class="keyword">for</span> b <span class="keyword">in</span> nums4:
                <span class="keyword">if</span> a+b <span class="keyword">not</span> <span class="keyword">in</span> dic:
                    dic[a+b]=<span class="number">1</span>
                <span class="keyword">else</span>:
                    dic[a+b]+=<span class="number">1</span>

        cnt=<span class="number">0</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums1)):
            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums2)):
                <span class="keyword">if</span> (-nums1[i]-nums2[j]) <span class="keyword">in</span> dic:
                    cnt+=dic[-nums1[i]-nums2[j]]
        <span class="keyword">return</span> cnt</code></pre>
<p>官方代码更简洁，思想一样：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span><span class="params">(self, A: List[int], B: List[int], C: List[int], D: List[int])</span> -&gt; int:</span>
        countAB = collections.Counter(u + v <span class="keyword">for</span> u <span class="keyword">in</span> A <span class="keyword">for</span> v <span class="keyword">in</span> B)
        ans = <span class="number">0</span>
        <span class="keyword">for</span> u <span class="keyword">in</span> C:
            <span class="keyword">for</span> v <span class="keyword">in</span> D:
                <span class="keyword">if</span> -u - v <span class="keyword">in</span> countAB:
                    ans += countAB[-u - v]
        <span class="keyword">return</span> ans</code></pre>
<p>课后习题<br><img src="./73.png" alt="Alt text"><br>strs[i] 仅包含小写字母。</p>
<p>思路：组成这种词的不同字母个数是一样的，因此可以以此为key，value是包含了同一类Anagrams的list，最后返回value即可。</p>
<p>官方代码：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span>
        mp = collections.defaultdict(list)

        <span class="keyword">for</span> st <span class="keyword">in</span> strs:
            counts = [<span class="number">0</span>] * <span class="number">26</span>
            <span class="keyword">for</span> ch <span class="keyword">in</span> st:
                counts[ord(ch) - ord(<span class="string">"a"</span>)] += <span class="number">1</span>
            <span class="comment"># 需要将 list 转换成 tuple 才能进行哈希,list is not hashable!</span>
            mp[tuple(counts)].append(st)
        print(mp)
        <span class="keyword">return</span> list(mp.values())</code></pre>
<h2 id="4-6"><a href="#4-6" class="headerlink" title="4-6"></a>4-6</h2><p><img src="./74.png" alt="Alt text"></p>
<p><img src="./75.png" alt="Alt text"></p>
<p><img src="./76.png" alt="Alt text"></p>
<p>后面的if可省略：<br><img src="./77.png" alt="Alt text"></p>
<p>解释一下：</p>
<p>哈希表的key是其余每一个点与第i个点（<strong>枢纽点</strong>）之间的距离，value是与第i个点之间的距离是当前key的点的个数。</p>
<p>那么，如果某个key对应的value=m，即对应m个这样的点，那么满足题意得点对组合总共有m*(m-1)个。</p>
<p>我改写的Python代码：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">numberOfBoomerangs</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span>

        n=len(points)
        res=<span class="number">0</span>
        <span class="function"><span class="keyword">def</span> <span class="title">cal_dist</span><span class="params">(i,j)</span>:</span>
            <span class="keyword">return</span> (points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>])**<span class="number">2</span>+(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>])**<span class="number">2</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
            dic=dict()
            <span class="keyword">for</span>  j <span class="keyword">in</span> range(n):
                <span class="keyword">if</span> j!=i:<span class="comment">#可不要</span>
                    dis=cal_dist(i,j)
                    <span class="keyword">if</span> dis <span class="keyword">not</span> <span class="keyword">in</span> dic:
                        dic[dis]=<span class="number">1</span>
                    <span class="keyword">else</span>:
                        dic[dis]+=<span class="number">1</span>
            <span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():
                <span class="keyword">if</span> v&gt;=<span class="number">2</span>:
                    res+=v*(v<span class="number">-1</span>)
        <span class="keyword">return</span> res</code></pre>
<p>时间复杂度：O(n^2)，其中 n 是数组长度</p>
<p>空间复杂度：O(n)</p>
<p>同样的思路，官方使用了defaultdict，使得代码更简单：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">numberOfBoomerangs</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span>
        ans = <span class="number">0</span>
        <span class="keyword">for</span> p <span class="keyword">in</span> points:
            cnt = defaultdict(int)
            <span class="keyword">for</span> q <span class="keyword">in</span> points:
                dis = (p[<span class="number">0</span>] - q[<span class="number">0</span>]) * (p[<span class="number">0</span>] - q[<span class="number">0</span>]) + (p[<span class="number">1</span>] - q[<span class="number">1</span>]) * (p[<span class="number">1</span>] - q[<span class="number">1</span>])
                cnt[dis] += <span class="number">1</span>
            <span class="keyword">for</span> m <span class="keyword">in</span> cnt.values():
                ans += m * (m - <span class="number">1</span>)
        <span class="keyword">return</span> ans</code></pre>
<p>课后习题<br><img src="./78.png" alt="Alt text"><br>points 中的所有点互不相同。</p>
<p><a href="https://leetcode-cn.com/problems/max-points-on-a-line/solution/tong-ge-lai-shua-ti-la-liang-chong-si-lu-94gy/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-points-on-a-line/solution/tong-ge-lai-shua-ti-la-liang-chong-si-lu-94gy/</a></p>
<p><a href="https://leetcode-cn.com/problems/max-points-on-a-line/solution/python-shi-yong-cheng-fa-bi-mian-jing-du-ml2d/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-points-on-a-line/solution/python-shi-yong-cheng-fa-bi-mian-jing-du-ml2d/</a></p>
<p>两两之差用乘法判断在不在一条直线上。(但是需要o(n^3)暴力判断)</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span>
        <span class="comment"># 三点在一条直线上时,斜率相等</span>
        <span class="comment"># y2 - y1 = k * (x2 - x1), y3 - y2 = k * (x3 - x2)</span>
        <span class="comment"># (y2 - y1) * (x3 - x2) = (y3 - y2) * (x2 - x1)</span>

        explored = set()
        ans = <span class="number">1</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(points)):
            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(points)):
                curr = <span class="number">2</span>
                dx,dy = points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>],points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>]
                <span class="keyword">for</span> k <span class="keyword">in</span> range(j+<span class="number">1</span>, len(points)):
                    <span class="keyword">if</span> (i,j) <span class="keyword">in</span> explored <span class="keyword">or</span> (i,k) <span class="keyword">in</span> explored <span class="keyword">or</span> (j,k) <span class="keyword">in</span> explored:
                        <span class="keyword">continue</span>
                    <span class="keyword">if</span> dy * (points[k][<span class="number">0</span>] - points[j][<span class="number">0</span>]) == (points[k][<span class="number">1</span>] - points[j][<span class="number">1</span>]) * dx:
                        curr += <span class="number">1</span>
                        explored.add((j,k))
                        explored.add((i,k))
                ans = max(ans, curr)
        <span class="keyword">return</span> ans</code></pre>
<p>使用哈希表统计同一kx+b的个数可以少一层循环。(需要使用辗转相除法避免除法精度问题)</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span>
        <span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(m, n)</span>:</span>
            <span class="keyword">return</span> m <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">else</span> gcd(n, m%n)

        <span class="function"><span class="keyword">def</span> <span class="title">getslope</span><span class="params">(p1, p2)</span>:</span>
            dx = p1[<span class="number">0</span>] - p2[<span class="number">0</span>]
            dy = p1[<span class="number">1</span>] - p2[<span class="number">1</span>]

            <span class="keyword">if</span> dx == <span class="number">0</span>: <span class="keyword">return</span> (p1[<span class="number">0</span>], <span class="number">0</span>)
            <span class="keyword">if</span> dy == <span class="number">0</span>: <span class="keyword">return</span> (<span class="number">0</span>, p1[<span class="number">1</span>])

            d = gcd(dx, dy)
            <span class="keyword">return</span> (dx//d, dy//d)

        res = <span class="number">0</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(points)):
            d = defaultdict(<span class="keyword">lambda</span>:<span class="number">0</span>)
            same, maxi = <span class="number">1</span>, <span class="number">0</span>
            p1 = points[i]
            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(points)):
                p2 = points[j]
                <span class="keyword">if</span> p1 == p2:
                    same += <span class="number">1</span>
                <span class="keyword">else</span>:
                    slope = getslope(p1, p2)
                    d[slope] += <span class="number">1</span>
                    maxi = max(maxi, d[slope])
            res = max(res, same + maxi)

        <span class="keyword">return</span> res</code></pre>
<p>因为直线总是以经过外层循环的点，所以取一个斜率即可(一个点和一个斜率确定一条直线)</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span>
        <span class="function"><span class="keyword">def</span> <span class="title">hdiv</span><span class="params">(dividend, divisor, accuracy)</span>:</span>
            <span class="string">'''</span>
<span class="string">            功能: 完成高精度的除法</span>
<span class="string">            参数:</span>
<span class="string">                dividend: 被除数</span>
<span class="string">                divisor: 除数</span>
<span class="string">                accuracy: 除法精度</span>
<span class="string">            返回: 计算结果(字符串)</span>
<span class="string">            '''</span>
            <span class="comment"># 定义存储结果的字符串</span>
            res = <span class="string">''</span>

            <span class="comment"># 定义保存正负数的变量</span>
            isNegative = <span class="literal">False</span>

            <span class="comment"># 确定正负号</span>
            <span class="keyword">if</span> dividend &lt; <span class="number">0</span> <span class="keyword">and</span> divisor &gt; <span class="number">0</span>:
                dividend = abs(dividend)
                isNegative = <span class="literal">True</span>
            <span class="keyword">elif</span> divisor &lt; <span class="number">0</span> <span class="keyword">and</span> dividend &gt; <span class="number">0</span>:
                divisor = abs(divisor)
                isNegative = <span class="literal">True</span>

            <span class="comment"># 在结果添加正负号</span>
            <span class="keyword">if</span> isNegative:
                res += <span class="string">'-'</span>

            <span class="comment"># 计算整数部分</span>
            integer = round(dividend // divisor)

            <span class="comment"># 将结果添加入结果</span>
            res += str(integer) + <span class="string">'.'</span>

            <span class="comment"># 计算余数</span>
            remainder = dividend % divisor

            <span class="comment"># 计算小数部分</span>
            <span class="keyword">for</span> i <span class="keyword">in</span> range(accuracy):
                dividend = remainder * <span class="number">10</span>
                res += str(round(dividend // divisor))
                remainder = dividend % divisor

            <span class="keyword">return</span> res

        <span class="comment"># k = (y2 - y1) / (x2 - x1), b = y - k * x</span>
        ans = <span class="number">1</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(points)):
            d = Counter()
            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(points)):
                <span class="keyword">if</span> <span class="keyword">not</span> points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]:
                    k = inf
                <span class="keyword">else</span>:
                    k = hdiv(points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>],points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>],<span class="number">10</span>)
                d[k] += <span class="number">1</span>
            <span class="keyword">if</span> d:
                ans = max(ans, max(d.values()) + <span class="number">1</span>)
        <span class="keyword">return</span> ans</code></pre>
<p>不用gcd得代码也能过：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span>
        ans = <span class="number">1</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(points) - <span class="number">1</span>):
            curr = Counter()
            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(points)):
                dx, dy = points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>], points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>]
                curr[dy / dx <span class="keyword">if</span> dx <span class="keyword">else</span> inf] += <span class="number">1</span>
            ans = max(ans, max(curr.values()) + <span class="number">1</span>)
        <span class="keyword">return</span> ans</code></pre>
<p>hard，这题以后再看吧~</p>
<h2 id="4-7"><a href="#4-7" class="headerlink" title="4-7"></a>4-7</h2><p><img src="./79.png" alt="Alt text"></p>
<p>固定长度的滑动窗口+哈希表</p>
<p><del>维护滑动窗口的长度为k+1：</del></p>
<p><del>比如k=3，那么i为0，j为3，满足j-i&lt;=k，这样，i和j总共包含了k+1=4个元素（最多，因为i、和j还可以靠近些）</del></p>
<p><del>窗口再大的话，j-i就可能不满足小于等于k了</del></p>
<p>nonono，是k~</p>
<p>滑动窗口长度为k，对于新到来的的元素，它的下标和滑动窗口中最前面元素的下标恰好是k。</p>
<p><img src="./80.png" alt="Alt text"></p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span>
        record=set()<span class="comment">#长度最多为k的哈希表</span>
        n=len(nums)
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> record:
                <span class="keyword">return</span> <span class="literal">True</span>
            record.add(nums[i])

            <span class="keyword">if</span> len(record)==k+<span class="number">1</span>:<span class="comment">#长度大于k了</span>
                record.remove(nums[i-k])<span class="comment">#删除最左边的元素，对应下标是i-k，画个图就清楚了</span>

        <span class="keyword">return</span> <span class="literal">False</span></code></pre>
<p>维护一个哈希表，里面始终最多包含 k 个元素，当出现重复值时则说明在 k 距离内存在重复元素（数组=[2,1,0,4,2]，画个图就知道为什么是维度哈希表长度最多为k了，同样最左边元素下标是i-k也可以看出来，画图吧）</p>
<p>每次遍历一个元素则将其加入哈希表中，如果哈希表的大小大于 k，则移除最前面的数字</p>
<p>时间复杂度：O(nlogn)，n为数组长度,set底层是二叉树，查找一次花费logn</p>
<p>空间复杂度：O(k)</p>
<p>课后习题<br><img src="./81.png" alt="Alt text"></p>
<p>本节题目的简化版本，我写的Python代码如下：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span>
        record=set()
        n=len(nums)
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> record:
                <span class="keyword">return</span> <span class="literal">True</span>
            record.add(nums[i])
        <span class="keyword">return</span> <span class="literal">False</span></code></pre>
<p>也可以排序，贴个官方代码：</p>
<pre><code class="cpp"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span>
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{
        sort(nums.begin(), nums.end());
        <span class="keyword">int</span> n = nums.size();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {
            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) {
                <span class="keyword">return</span> <span class="literal">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
};</code></pre>
<h2 id="4-8"><a href="#4-8" class="headerlink" title="4-8"></a>4-8</h2><p><img src="./82.png" alt="Alt text"></p>
<p>直接在上一题的代码上稍加改动即可，具体的，改一下判断条件。</p>
<p>如何实现这一新的判断条件？看官方题解：<br><img src="./85.png" alt="Alt text"></p>
<p><img src="./84.png" alt="Alt text"></p>
<p><img src="./83.png" alt="Alt text"></p>
<p>改写成Python代码，注意Python自带的set是无序的，因此要使用有序的set：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(self, nums: List[int], k: int, t: int)</span> -&gt; bool:</span>
        <span class="comment">#record=set()#长度最多为k的哈希表</span>
        <span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedSet
        record=SortedSet()<span class="comment">#有序集合</span>


        n=len(nums)
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):

            <span class="comment">#lis=[x for x in record if x&gt;=nums[i]-t]</span>
            <span class="comment">#if len(lis)&gt;0:</span>
            <span class="comment">#    temp=min(lis)</span>
            <span class="comment">#else:</span>
            <span class="comment">#    temp=None</span>
            <span class="comment">#print(temp)</span>

            <span class="comment">##查找第一个大于等于num-t的数的位置</span>
            index = record.bisect_left(nums[i] - t)

            <span class="keyword">if</span> index&lt;len(record)  <span class="keyword">and</span> record[index]&lt;=nums[i]+t:
                <span class="keyword">return</span> <span class="literal">True</span>

            record.add(nums[i])

            <span class="keyword">if</span> len(record)==k+<span class="number">1</span>:<span class="comment">#长度大于k了</span>
                record.remove(nums[i-k])<span class="comment">#删除最左边的元素，对应下标是i-k，画个图就清楚了</span>

        <span class="keyword">return</span> <span class="literal">False</span></code></pre>
<h1 id="第五章：链表"><a href="#第五章：链表" class="headerlink" title="第五章：链表"></a>第五章：链表</h1><h2 id="5-1"><a href="#5-1" class="headerlink" title="5-1"></a>5-1</h2><p><img src="./86.png" alt="Alt text"></p>
<p><img src="./87.png" alt="Alt text"></p>
<p>我写的Python版本：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span>
        pre=<span class="literal">None</span>
        cur=head

        <span class="keyword">while</span> cur:
            next=cur.next

            cur.next=pre

            pre=cur
            cur=next
        <span class="keyword">return</span> pre</code></pre>
<p>课后习题<br><img src="./88.png" alt="Alt text"><br>m&lt;= n</p>
<p><strong>方法1：</strong></p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, left: int, right: int)</span> -&gt; ListNode:</span>

        <span class="comment">## 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span>
        dummy_node = ListNode(<span class="number">-1</span>)
        dummy_node.next = head


        <span class="comment">#找到第left个节点的前驱节点a和第right个节点b</span>
        a=dummy_node
        <span class="keyword">for</span> i <span class="keyword">in</span> range(left<span class="number">-1</span>):
            a=a.next
        b=dummy_node
        <span class="keyword">for</span> i <span class="keyword">in</span> range(right):
            b=b.next

        tou=a.next<span class="comment">#待反转的部分链表的头</span>
        wei=b<span class="comment">##待反转的部分链表的尾</span>
        suc=wei.next<span class="comment">#第right个节点的后继节点</span>
        <span class="comment">#截断得到待反转的链表</span>
        a.next=<span class="literal">None</span>
        wei.next=<span class="literal">None</span>

        <span class="comment">#开始反转</span>
        <span class="function"><span class="keyword">def</span> <span class="title">reverse_linked_list</span><span class="params">(head: ListNode)</span>:</span>
            <span class="comment"># 也可以使用递归反转一个链表</span>
            pre = <span class="literal">None</span>
            cur = head
            <span class="keyword">while</span> cur:
                next = cur.next
                cur.next = pre
                pre = cur
                cur = next
        reverse_linked_list(tou)

        <span class="comment">#最后再连接起来</span>
        a.next=wei
        tou.next=suc

        <span class="keyword">return</span> dummy_node.next</code></pre>
<p>时间复杂度：O(N)，其中 NNN 是链表总节点数。最坏情况下，需要遍历整个链表。</p>
<p>空间复杂度：O(1)。只使用到常数个变量。</p>
<p>关于加了个头节点的解释：</p>
<p><img src="./89.png" alt="Alt text"></p>
<p><img src="./90.png" alt="Alt text"></p>
<p><strong>方法2：一次遍历「穿针引线」反转链表（头插法）</strong></p>
<p>方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 O(N)，但遍历了链表 2 次，可不可以只遍历一次呢？答案是可以的。</p>
<p>整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置.<br><img src="./91.png" alt="Alt text"></p>
<p><img src="./92.png" alt="Alt text"></p>
<p><img src="./93.png" alt="Alt text"><br><img src="./94.png" alt="Alt text"><br><img src="./95.png" alt="Alt text"></p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, left: int, right: int)</span> -&gt; ListNode:</span>
        <span class="comment"># 设置 dummyNode 是这一类问题的一般做法</span>
        dummy_node = ListNode(<span class="number">-1</span>)
        dummy_node.next = head
        pre = dummy_node
        <span class="keyword">for</span> _ <span class="keyword">in</span> range(left - <span class="number">1</span>):
            pre = pre.next

        cur = pre.next
        <span class="keyword">for</span> _ <span class="keyword">in</span> range(right - left):
            next = cur.next
            cur.next = next.next
            next.next = pre.next
            pre.next = next
        <span class="keyword">return</span> dummy_node.next</code></pre>
<h2 id="5-2"><a href="#5-2" class="headerlink" title="5-2"></a>5-2</h2><p>介绍了一些链表的相关操作</p>
<p>课后习题<br><img src="./96.png" alt="Alt text"></p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> head
        p=head
        <span class="keyword">while</span> p.next:
            <span class="keyword">if</span> p.val ==p.next.val:
                p.next=p.next.next
            <span class="keyword">else</span>:
                p=p.next
        <span class="keyword">return</span> head</code></pre>
<p><img src="./97.png" alt="Alt text"><br>你应当 保留 两个分区中每个节点的初始相对位置。</p>
<p>我看了题解后独立写的代码：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span>
        small_dummy=ListNode(<span class="number">101</span>)
        large_dummy=ListNode(<span class="number">101</span>)
        small,large=small_dummy,large_dummy<span class="comment">#工作指针</span>
        <span class="keyword">while</span> head:
            <span class="keyword">if</span> head.val&lt;x:
                small.next=head
                small=small.next
            <span class="keyword">else</span>:
                large.next=head
                large=large.next
            head=head.next
        large.next=<span class="literal">None</span>
        small.next=large_dummy.next

        <span class="keyword">return</span> small_dummy.next</code></pre>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)，因为只生成了两个初始的头结点，之后的操作都是在原链表上进行的。</p>
<p><img src="./98.png" alt="Alt text"><br>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> head

        odd=head<span class="comment">#奇</span>

        evenHead=head.next<span class="comment">#记录，后面连接时用到</span>
        even=evenHead<span class="comment">#偶</span>

        <span class="keyword">while</span> even <span class="keyword">and</span> even.next:
            odd.next=even.next
            odd=odd.next

            even.next=odd.next
            even=even.next

        <span class="comment">#连接</span>
        odd.next=evenHead

        <span class="keyword">return</span> head</code></pre>
<p><img src="./99.png" alt="Alt text"><br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>并且每个节点只能存储 一位 数字。</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span>
        <span class="keyword">if</span> l1 == <span class="literal">None</span>:
            <span class="keyword">return</span> l2
        <span class="keyword">if</span> l2 == <span class="literal">None</span>:
            <span class="keyword">return</span> l1

        dummy=ListNode(<span class="number">0</span>)
        p=dummy
        carry=<span class="number">0</span><span class="comment">#进位</span>

        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:
            p.next=ListNode((l1.val+l2.val+carry)%<span class="number">10</span>)
            carry=(l1.val+l2.val+carry)//<span class="number">10</span><span class="comment">#更新进位，取值为0或者一个0到9的数字</span>
            l1=l1.next
            l2=l2.next
            p=p.next
        <span class="keyword">if</span> l2:
            <span class="keyword">while</span> l2:
                p.next=ListNode((l2.val+carry)%<span class="number">10</span>)
                carry=(l2.val+carry)//<span class="number">10</span><span class="comment">#更新进位，取值为0或者一个0到9的数字                </span>
                l2=l2.next
                p=p.next
        <span class="keyword">if</span> l1:
            <span class="keyword">while</span> l1:
                p.next=ListNode((l1.val+carry)%<span class="number">10</span>)
                carry=(l1.val+carry)//<span class="number">10</span><span class="comment">#更新进位，取值为0或者一个0到9的数字                </span>
                l1=l1.next
                p=p.next

        <span class="keyword">if</span> carry !=<span class="number">0</span>:<span class="comment">#if carry==1</span>
            p.next=ListNode(carry)

        <span class="keyword">return</span> dummy.next</code></pre>
<p><img src="./100.png" alt="Alt text"><br>进阶：如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转()</p>
<p>本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。</p>
<p>我怎么就没想到。。。</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span>
        s1, s2 = [], []
        <span class="keyword">while</span> l1:
            s1.append(l1.val)
            l1 = l1.next
        <span class="keyword">while</span> l2:
            s2.append(l2.val)
            l2 = l2.next
        ans = <span class="literal">None</span>
        carry = <span class="number">0</span>
        <span class="keyword">while</span> s1 <span class="keyword">or</span> s2 <span class="keyword">or</span> carry != <span class="number">0</span>:
            a = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> s1 <span class="keyword">else</span> s1.pop()
            b = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> s2 <span class="keyword">else</span> s2.pop()
            cur = a + b + carry
            carry = cur // <span class="number">10</span>
            cur %= <span class="number">10</span>
            <span class="comment">#头插</span>
            curnode = ListNode(cur)
            curnode.next = ans
            ans = curnode
        <span class="keyword">return</span> ans</code></pre>
<h2 id="5-3"><a href="#5-3" class="headerlink" title="5-3"></a>5-3</h2><p><img src="./101.png" alt="Alt text"></p>
<p>不设虚拟头节点：需要单独对第一个节点进行处理<br><img src="./102.png" alt="Alt text"></p>
<p>设置虚拟头节点：方便，统一<br><img src="./103.png" alt="Alt text"></p>
<p>课后习题<br><img src="./104.png" alt="Alt text"></p>
<p>我写的答案：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span>

        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> head

        dummyHead=ListNode(<span class="number">-1000</span>)
        dummyHead.next=head

        pre=dummyHead
        p=dummyHead.next

        <span class="keyword">while</span> p <span class="keyword">and</span> p.next:
            <span class="keyword">if</span> p.val==p.next.val:
                temp=p.val
                <span class="keyword">while</span> p <span class="keyword">and</span> p.val==temp:
                    p=p.next
                pre.next=p
            <span class="keyword">else</span>:
                pre=p
                p=p.next
        <span class="keyword">return</span> dummyHead.next</code></pre>
<p>时间复杂度：O(n)，其中 n 是链表的长度。</p>
<p>空间复杂度：O(1).</p>
<p><img src="./105.png" alt="Alt text"></p>
<p>我的答案：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> l1:
            <span class="keyword">return</span> l2
        <span class="keyword">if</span> <span class="keyword">not</span> l2:
            <span class="keyword">return</span> l1

        <span class="comment">#两者都不为空</span>
        dummyHead=ListNode()
        p=dummyHead<span class="comment">#新链表的虚拟头节点</span>

        p1,p2=l1,l2<span class="comment">#遍历两个链表</span>

        <span class="keyword">while</span> p1 <span class="keyword">or</span> p2:
            <span class="comment">#l2遍历结束</span>
            <span class="keyword">if</span> <span class="keyword">not</span> p2:
                p.next=p1
                p=p.next

                p1=p1.next
                <span class="keyword">if</span> <span class="keyword">not</span> p1:
                    <span class="keyword">break</span>
            <span class="comment">#l1遍历结束</span>
            <span class="keyword">if</span> <span class="keyword">not</span> p1:
                p.next=p2
                p=p.next

                p2=p2.next

                <span class="keyword">if</span> <span class="keyword">not</span> p2:
                    <span class="keyword">break</span>

            <span class="comment">#l1和l2都还没遍历结束</span>
            <span class="keyword">if</span> p1 <span class="keyword">and</span>  p2:
                <span class="keyword">if</span> p1.val&lt;p2.val:
                    p.next=p1
                    p=p.next

                    p1=p1.next
                <span class="keyword">else</span>:
                    p.next=p2
                    p=p.next

                    p2=p2.next
        <span class="keyword">return</span> dummyHead.next</code></pre>
<p>官方的答案更简洁，更易懂</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span>
        prehead = ListNode(<span class="number">-1</span>)

        prev = prehead
        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:
            <span class="keyword">if</span> l1.val &lt;= l2.val:
                prev.next = l1
                l1 = l1.next
            <span class="keyword">else</span>:
                prev.next = l2
                l2 = l2.next            
            prev = prev.next

        <span class="comment"># 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span>
        prev.next = l1 <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> l2

        <span class="keyword">return</span> prehead.next</code></pre>
<p>时间复杂度：O(n+m)，其中n 和m分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m).</p>
<p>空间复杂度：O(1), 我们只需要常数的空间存放若干变量。</p>
<p>以上是迭代的方法，还可以采用递归的方法，官方题解如下：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span>
        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:
            <span class="keyword">return</span> l2
        <span class="keyword">elif</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:
            <span class="keyword">return</span> l1
        <span class="keyword">elif</span> l1.val &lt; l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            <span class="keyword">return</span> l1
        <span class="keyword">else</span>:
            l2.next = self.mergeTwoLists(l1, l2.next)
            <span class="keyword">return</span> l2</code></pre>
<p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。</p>
<p>空间复杂度：O(n+m)，其中 n 和 m分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m次，因此空间复杂度为 O(n+m)。</p>
<h2 id="5-4"><a href="#5-4" class="headerlink" title="5-4"></a>5-4</h2><p><img src="./106.png" alt="Alt text"></p>
<p><img src="./108.png" alt="Alt text"></p>
<p><img src="./107.png" alt="Alt text"></p>
<p>我改成Python版本：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span>
        dummyHead=ListNode()
        dummyHead.next=head

        p=dummyHead
        <span class="comment">#保证存在两个将要交换位置的元素</span>
        <span class="keyword">while</span> p.next <span class="keyword">and</span> p.next.next:
            node1=p.next
            node2=node1.next
            next=node2.next

            <span class="comment">#开始交换</span>
            p.next=node2
            node2.next=node1
            node1.next=next

            <span class="comment">#走</span>
            p=node1

        <span class="keyword">return</span> dummyHead.next</code></pre>
<p>课后习题</p>
<p><img src="./109.png" alt="Alt text"></p>
<p>参考官方代码+小改动，具体理解结合官方图解就很清晰了：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span>
        <span class="comment">#翻转一个子链表，并且返回新的头与尾</span>
        <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(sub_head,sub_tail)</span>:</span>
            pre=<span class="literal">None</span>
            cur=sub_head

            <span class="comment">#在普通的反转链表中，这里的判断条件是cur不为None</span>
            <span class="comment">#但这里，对于完整的链表，只反转sub_head到sub_tail之间的节点</span>
            <span class="comment">#所以判断条件成了pre!=tail</span>
            <span class="comment">#当然，也可以先保存tail的后继，然后就和之前普通的俩表反转方法一致了，如下：</span>

            <span class="comment">#sub_tail_nex=sub_tail.next</span>
            <span class="comment">#while cur!=sub_tail_nex:</span>

            <span class="keyword">while</span> pre!=tail:
                next=cur.next

                cur.next=pre

                pre=cur
                cur=next
            <span class="keyword">return</span> sub_tail,sub_head<span class="comment">#tail成了头，head成了尾，是谓“链表反转”</span>

        dummyHead=ListNode()
        dummyHead.next=head

        pre=dummyHead

        <span class="keyword">while</span> head:
            tail=pre
            <span class="comment"># 查看剩余部分长度是否大于等于 k</span>
            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):
                tail = tail.next
                <span class="keyword">if</span> <span class="keyword">not</span> tail:
                    <span class="keyword">return</span> dummyHead.next
            nex = tail.next
            head, tail = reverseList(head, tail)

            <span class="comment"># 把子链表重新接回原链表</span>
            pre.next = head
            tail.next = nex

            <span class="comment">#为下一次操作做准备</span>
            pre = tail
            head = tail.next

        <span class="keyword">return</span> dummyHead.next</code></pre>
<p><img src="./110.png" alt="Alt text"></p>
<p>看官方题解：</p>
<p>对于单向链表而言，只有指向后一个节点的指针，因此需要从链表的头节点开始往后遍历链表中的节点，寻找插入位置。</p>
<p><img src="./112.png" alt="Alt text"></p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> head

        dummyHead = ListNode(<span class="number">0</span>)
        dummyHead.next = head
        lastSorted = head
        curr = head.next

        <span class="keyword">while</span> curr:
            <span class="keyword">if</span> lastSorted.val &lt;= curr.val:
                lastSorted = lastSorted.next
            <span class="keyword">else</span>:
                prev = dummyHead
                <span class="keyword">while</span> prev.next.val &lt;= curr.val:
                    prev = prev.next
                lastSorted.next = curr.next
                curr.next = prev.next
                prev.next = curr
            curr = lastSorted.next

        <span class="keyword">return</span> dummyHead.next</code></pre>
<p><img src="./111.png" alt="Alt text"></p>
<p>暂时不想看。</p>
<h2 id="5-5"><a href="#5-5" class="headerlink" title="5-5"></a>5-5</h2><p><img src="./113.png" alt="Alt text"></p>
<p><img src="./114.png" alt="Alt text"></p>
<p>我改成Python版本：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span>
        <span class="string">"""</span>
<span class="string">        :type node: ListNode</span>
<span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span>
<span class="string">        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> node:
            <span class="keyword">return</span> 
        <span class="keyword">if</span> <span class="keyword">not</span> node.next:
            node=<span class="literal">None</span>
            <span class="keyword">return</span> 

        node.val=node.next.val
        node.next=node.next.next</code></pre>
<h2 id="5-6"><a href="#5-6" class="headerlink" title="5-6"></a>5-6</h2><p><img src="./115.png" alt="Alt text"></p>
<p>我写的解法1：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span>
        p=head
        length=<span class="number">0</span><span class="comment">#链表长度</span>
        <span class="keyword">while</span> p:
            length+=<span class="number">1</span>
            p=p.next

        dummyHead=ListNode()
        dummyHead.next=head
        pre=dummyHead<span class="comment">#待删除结点的前驱</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(length-n):
            pre=pre.next
        pre.next=pre.next.next
        <span class="keyword">return</span> dummyHead.next</code></pre>
<p>进阶：你能尝试使用一趟扫描实现吗？<br><img src="./116.png" alt="Alt text"></p>
<p>我根据题解写的代码：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span>
        dummyHead=ListNode()
        dummyHead.next=head

        fast=head
        slow=dummyHead

        <span class="comment">#fast先行2步</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
            fast=fast.next
        <span class="keyword">while</span> fast:
            fast=fast.next
            slow=slow.next

        <span class="comment">#此时slow指向待删除结点的前驱</span>
        slow.next=slow.next.next

        <span class="keyword">return</span> dummyHead.next</code></pre>
<p>课后习题<br><img src="./117.png" alt="Alt text"></p>
<p>本想用上一题的方法，但发现本题的k可能大于链表长度，因此不可行，代码如下：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: Optional[ListNode], k: int)</span> -&gt; Optional[ListNode]:</span>
        <span class="keyword">if</span> k==<span class="number">0</span>:
            <span class="keyword">return</span> head

        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> head

        <span class="comment">#切成两段，前面一段，后面k个一段</span>
        <span class="comment">#然后将前面一段连接在k个一段的后面</span>

        <span class="comment">#因此需要先找到倒数第k个结点的前驱</span>

        dummyHead=ListNode()
        dummyHead.next=head

        slow=dummyHead
        fast=head

        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):
            fast=fast.next

        <span class="keyword">while</span> fast:
            fast=fast.next
            slow=slow.next
        <span class="comment">#此时slow指向后一段的前驱</span>

        part2Head=slow.next
        slow.next=<span class="literal">None</span><span class="comment">#切断</span>

        <span class="comment">#找到后一段的尾巴结点</span>
        p=part2Head
        <span class="keyword">while</span> p.next:
            p=p.next
        p.next=dummyHead.next<span class="comment">#连起来</span>

        <span class="keyword">return</span> part2Head</code></pre>
<p>可以修改一下，k=length(head)%k</p>
<p>AC代码如下：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: Optional[ListNode], k: int)</span> -&gt; Optional[ListNode]:</span>
        <span class="keyword">if</span> k==<span class="number">0</span> :
            <span class="keyword">return</span> head

        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> head

        <span class="comment">#求链表长度</span>
        length=<span class="number">0</span>
        q=head
        <span class="keyword">while</span> q:
            length+=<span class="number">1</span>
            q=q.next

        <span class="keyword">if</span> length==<span class="number">1</span>:
            <span class="keyword">return</span> head

        <span class="comment">#k可能大于length，</span>
        k=k%length

        <span class="comment">#切成两段，前面一段，后面k个一段</span>
        <span class="comment">#然后将前面一段连接在k个一段的后面</span>

        <span class="comment">#因此需要先找到倒数第k个结点的前驱</span>

        dummyHead=ListNode()
        dummyHead.next=head

        slow=dummyHead
        fast=head

        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):
            fast=fast.next

        <span class="keyword">while</span> fast:
            fast=fast.next
            slow=slow.next
        <span class="comment">#此时slow指向后一段的前驱</span>

        part2Head=slow.next
        slow.next=<span class="literal">None</span><span class="comment">#切断</span>

        <span class="comment">#找到后一段的尾巴结点</span>
        p=part2Head

        <span class="comment">#p为空，说明第二段为空，因此不需要做任何操作</span>
        <span class="keyword">if</span> <span class="keyword">not</span> p:
            <span class="keyword">return</span> head

        <span class="keyword">while</span> p.next:
            p=p.next
        p.next=dummyHead.next<span class="comment">#连起来</span>

        <span class="keyword">return</span> part2Head</code></pre>
<p><img src="./118.png" alt="Alt text"><br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>我自己的解法，按部就班来，官方也是这么做的：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head: ListNode)</span> -&gt; <span class="keyword">None</span>:</span>
        <span class="string">"""</span>
<span class="string">        Do not return anything, modify head in-place instead.</span>
<span class="string">        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span>  head.next:
            <span class="keyword">return</span> head

        <span class="comment">#1. 先找到链表的中间结点</span>
        slow=head
        fast=head.next

        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:
            fast=fast.next.next
            slow=slow.next

        <span class="comment">#2. 中点前后切成两段子链表</span>
        part2Head=slow.next
        slow.next=<span class="literal">None</span>

        <span class="comment">#3. 将第二段链表反转</span>
        p=part2Head
        <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(head)</span>:</span>
            pre=<span class="literal">None</span>
            cur=head

            <span class="keyword">while</span> cur:
                next=cur.next

                cur.next=pre

                pre=cur
                cur=next
            <span class="keyword">return</span> pre
        part2Head=reverseList(p)

        <span class="comment">#4. 开一个新的结点，每一次分别从两个子链表中摘取第一个结点</span>
        newHead=ListNode()
        p=newHead
        <span class="comment">#奇数个结点时，第一段会多剩一个结点，直接连过去就好了</span>
        <span class="keyword">while</span> head <span class="keyword">or</span> part2Head:
            <span class="keyword">if</span> head:
                p.next=head
                head=head.next
                p=p.next
            <span class="keyword">if</span> part2Head:
                p.next=part2Head
                part2Head=part2Head.next
                p=p.next

        <span class="keyword">return</span> newHead.next</code></pre>
<p>此外 ，官方还提供了一种做法，不过此时需要开一个列表存储每一个结点，空间复杂度为O(n)：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head: ListNode)</span> -&gt; <span class="keyword">None</span>:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span>

        vec = list()
        node = head
        <span class="keyword">while</span> node:
            vec.append(node)
            node = node.next

        i, j = <span class="number">0</span>, len(vec) - <span class="number">1</span>
        <span class="keyword">while</span> i &lt; j:
            vec[i].next = vec[j]
            i += <span class="number">1</span>
            <span class="keyword">if</span> i == j:
                <span class="keyword">break</span>
            vec[j].next = vec[i]
            j -= <span class="number">1</span>

        vec[i].next = <span class="literal">None</span></code></pre>
<p><img src="./119.png" alt="Alt text"><br>进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p>能啊，和上题几乎一样，我直接写(在上一题的代码上复制+修改)出来了：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span>  head.next:
            <span class="keyword">return</span> <span class="literal">True</span>

        <span class="comment">#1. 找到中间结点</span>
        slow=head
        fast=head.next

        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:
            fast=fast.next.next
            slow=slow.next

        <span class="comment">#2. 以中间结点为切分点，将整个链表切分成两段</span>
        part2Head=slow.next
        slow.next=<span class="literal">None</span>

        <span class="comment">#3. 对后一段链表进行反转</span>
        p=part2Head
        <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(head)</span>:</span>
            pre=<span class="literal">None</span>
            cur=head

            <span class="keyword">while</span> cur:
                next=cur.next

                cur.next=pre

                pre=cur
                cur=next
            <span class="keyword">return</span> pre
        part2Head=reverseList(p)

        <span class="comment">#4. 两段链表逐个元素比较</span>
        <span class="comment">#即使结点个数为奇数也没关系，用and，忽略剩余的一个元素即可</span>
        <span class="keyword">while</span> head <span class="keyword">and</span> part2Head:
            <span class="keyword">if</span> head.val!=part2Head.val:
                <span class="keyword">return</span> <span class="literal">False</span>
            head=head.next
            part2Head=part2Head.next
        <span class="keyword">return</span> <span class="literal">True</span></code></pre>
<p>比较直接的，但空间复杂度为O(n)的做法，是将值存入列表，然后判断lis等不等于lis[::-1]：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span>
        vals = []
        current_node = head
        <span class="keyword">while</span> current_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:
            vals.append(current_node.val)
            current_node = current_node.next
        <span class="keyword">return</span> vals == vals[::<span class="number">-1</span>]</code></pre>
<h1 id="第六章、栈和队列"><a href="#第六章、栈和队列" class="headerlink" title="第六章、栈和队列"></a>第六章、栈和队列</h1><h2 id="6-1"><a href="#6-1" class="headerlink" title="6-1"></a>6-1</h2><p><img src="./120.png" alt="Alt text"></p>
<p>我根据视频解法写的Python版本：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span>
        stack=[]
        <span class="keyword">for</span> ch <span class="keyword">in</span> s:
            <span class="keyword">if</span> ch <span class="keyword">in</span> <span class="string">'({['</span>:
                stack.append(ch)
            <span class="comment">#ch in ')]}'</span>
            <span class="keyword">else</span>:
                <span class="keyword">if</span> ch ==<span class="string">')'</span>:
                    match=<span class="string">'('</span>
                <span class="keyword">elif</span> ch==<span class="string">'}'</span>:
                    match=<span class="string">'{'</span>
                <span class="keyword">elif</span> ch==<span class="string">']'</span>:
                    match=<span class="string">'['</span>

                <span class="comment">#比如'{{}'</span>
                <span class="keyword">if</span> len(stack)==<span class="number">0</span>:
                    <span class="keyword">return</span> <span class="literal">False</span>

                cur=stack.pop()
                <span class="keyword">if</span> cur!=match:
                    <span class="keyword">return</span> <span class="literal">False</span>

        <span class="keyword">if</span> len(stack)!=<span class="number">0</span>:
            <span class="keyword">return</span> <span class="literal">False</span>
        <span class="keyword">return</span> <span class="literal">True</span>           </code></pre>
<p>时间复杂度：O(n)，其中 n 是字符串 s 的长度。</p>
<p>空间复杂度：O(n+∣Σ∣)其中 Σ\SigmaΣ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣=6|。栈中的字符数量为 O(n),而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。</p>
<p>课后习题<br><img src="./121.png" alt="Alt text"></p>
<p>我的解法：</p>
<p>遇到数字就入栈，否则遇到操作数弹出两个元素，执行运损，再把结果入栈。</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens: List[str])</span> -&gt; int:</span>
        stack=[]
        <span class="keyword">for</span> ch <span class="keyword">in</span> tokens:
            <span class="comment">#是数字，则入栈</span>
            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'+-*/'</span>:
                stack.append(int(ch))

            <span class="comment">#是运算符，则取出栈中前两个数字，执行操作，再把操作结果压入栈中</span>
            <span class="keyword">else</span>:
                a=stack.pop()
                b=stack.pop()
                <span class="keyword">if</span> ch==<span class="string">'+'</span>:
                    res=a+b
                <span class="keyword">elif</span> ch==<span class="string">'-'</span>:
                    res=b-a
                <span class="keyword">elif</span> ch==<span class="string">'*'</span>:
                    res=a*b
                <span class="keyword">elif</span> ch==<span class="string">'/'</span>:
                    res=int(b/a)<span class="comment">#注意Python遇到负数除法时会跟题目不一致，因此这里不能直接用b//a</span>
                stack.append(res)

        <span class="keyword">return</span> stack.pop()</code></pre>
<p><img src="./122.png" alt="Alt text"></p>
<p>示例：</p>
<pre><code>示例 1：
输入：path = &quot;/home/&quot;
输出：&quot;/home&quot;
解释：注意，最后一个目录名后面没有斜杠。 

示例 2：
输入：path = &quot;/../&quot;
输出：&quot;/&quot;
解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。

示例 3：
输入：path = &quot;/home//foo/&quot;
输出：&quot;/home/foo&quot;
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。

示例 4：
输入：path = &quot;/a/./b/../../c/&quot;
输出：&quot;/c&quot;</code></pre><p>评论区答案：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path)</span>:</span>
        stack = []
        all_chs=path.split(<span class="string">'/'</span>)
        <span class="keyword">for</span> p <span class="keyword">in</span> all_chs:
            <span class="keyword">if</span> stack <span class="keyword">and</span> p == <span class="string">'..'</span>:
                stack.pop()
            <span class="keyword">elif</span> p <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">" .."</span>:
                stack.append(p)
        <span class="keyword">return</span> <span class="string">'/'</span> + <span class="string">'/'</span>.join(stack)</code></pre>
<p>split妙啊~~</p>
<h2 id="6-2"><a href="#6-2" class="headerlink" title="6-2"></a>6-2</h2><p>栈与递归。</p>
<p>以二叉树的遍历为例：</p>
<p><img src="./123.png" alt="Alt text"></p>
<p>递归需要系统栈。</p>
<p>可以手动栈代替系统栈，将递归转为非递归。</p>
<h2 id="6-3"><a href="#6-3" class="headerlink" title="6-3"></a>6-3</h2><p>非递归实现二叉树遍历。</p>
<p>用栈。</p>
<p><strong>1. 前序遍历</strong></p>
<p>递归：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span>
        res=[]
        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(root)</span>:</span>
            <span class="keyword">if</span> root:
                res.append(root.val)
                f(root.left)
                f(root.right)
        f(root)
        <span class="keyword">return</span> res</code></pre>
<p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p>
<p>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(log⁡n)，最坏情况下树呈现链状，为 O(n)。</p>
<p>非递归：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []

        stack=[root]
        res=[]
        <span class="keyword">while</span> stack:
            node=stack.pop()
            <span class="keyword">if</span> node:
                res.append(node.val)
                <span class="keyword">if</span> node.right:
                    stack.append(node.right)
                <span class="keyword">if</span> node.left:
                    stack.append(node.left)
        <span class="keyword">return</span> res</code></pre>
<p>非递归解法2：模板解法</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span>
        res=[]
        stack=[]

        <span class="keyword">while</span> root:
            res.append(root.val)
            stack.append(root)
            root=root.left

        <span class="keyword">while</span> stack:
            t=stack.pop()
            r=t.right
            <span class="keyword">while</span> r:
                res.append(r.val)
                stack.append(r)
                r=r.left
        <span class="keyword">return</span> res</code></pre>
<p><strong>2. 中序遍历</strong></p>
<p>递归：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span>
        res=[]
        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(root)</span>:</span>
            <span class="keyword">if</span> root:
                f(root.left)
                res.append(root.val)
                f(root.right)
        f(root)
        <span class="keyword">return</span> res</code></pre>
<p>非递归 模板解法：</p>
<p>前序遍历中，入栈前就访问元素</p>
<p>中序遍历中，出栈时才访问元素</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span>
        res=[]
        stack=[]

        <span class="keyword">while</span> root:

            stack.append(root)
            root=root.left

        <span class="keyword">while</span> stack:
            t=stack.pop()
            res.append(t.val)<span class="comment">#访问</span>
            r=t.right
            <span class="keyword">while</span> r:
                stack.append(r)
                r=r.left
        <span class="keyword">return</span> res</code></pre>
<p><strong>3. 后序遍历</strong></p>
<p>递归：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span>
        res=[]
        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(root)</span>:</span>
            <span class="keyword">if</span> root:
                f(root.left)
                f(root.right)
                res.append(root.val)
        f(root)
        <span class="keyword">return</span> res</code></pre>
<p>非递归 模板解法：</p>
<p>前序遍历：根 左 右</p>
<p>后序遍历：左 右 根</p>
<p>后序遍历的逆序：根 右 左</p>
<p>因此，可以直接拿前序遍历的代码，改一下左右子树的访问顺序即可，最后返回结果的逆序，就是后序遍历的结果啦：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span>
        res=[]
        stack=[]

        <span class="keyword">while</span> root:
            res.append(root.val)<span class="comment">#访问</span>
            stack.append(root)
            root=root.right

        <span class="keyword">while</span> stack:
            t=stack.pop()
            r=t.left
            <span class="keyword">while</span> r:
                res.append(r.val)<span class="comment">#访问</span>
                stack.append(r)
                r=r.right
        <span class="keyword">return</span> res[::<span class="number">-1</span>]</code></pre>
<p>总结：前序和中序的区别就在于前者是入栈时访问，而后者是出栈时才访问；后序可借助前序得到，只需更改一下左右结点入栈顺序。</p>
<p>课后习题<br><img src="./124.png" alt="Alt text"></p>
<p><img src="./125.png" alt="Alt text"></p>
<p><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/solution/fu-xue-ming-zhu-xiang-jie-ti-yi-shu-li-d-n4qa/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flatten-nested-list-iterator/solution/fu-xue-ming-zhu-xiang-jie-ti-yi-shu-li-d-n4qa/</a></p>
<p>递归：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nests)</span>:</span>
        <span class="keyword">for</span> nest <span class="keyword">in</span> nests:
            <span class="keyword">if</span> nest.isInteger():
                self.queue.append(nest.getInteger())
            <span class="keyword">else</span>:
                self.dfs(nest.getList())

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nestedList)</span>:</span>
        self.queue = collections.deque()
        self.dfs(nestedList)

    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span>
        <span class="keyword">return</span> self.queue.popleft()

    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span>:</span>
        <span class="keyword">return</span> len(self.queue)</code></pre>
<p>非递归：栈</p>
<p>在递归方法中，我们在遍历时如果遇到一个嵌套的 子list，就立即处理该 子list，直到全部展开；</p>
<p>在迭代方法中，我们不需要全部展开，只需要把 当前list 的所有元素放入 list 中。</p>
<p>算法整体的流程，通过举例说明。假如输入 [1, [2,3]] 。</p>
<pre><code>1. 在构造函数中：栈里面放的应该是 stack = [[2, 3], 1]
2. 在调用 hasNext() 方法时，访问栈顶元素是 1，为 int，那么直接返回 true;
3. 然后调用 next() 方法，弹出栈顶元素 1；
4. 再调用 hasNext() 方法时，访问栈顶元素是 [2,3]，为 list，那么需要摊平，继续放到栈中。
        当前的栈是 stack = [3, 2]
5. 然后调用 next() 方法，弹出栈顶元素 2；
6. 然后调用 next() 方法，弹出栈顶元素 3；
7. 再调用 hasNext() 方法时，栈为空，因此返回 false，迭代器运行结束。</code></pre><p>代码：</p>
<pre><code class="python"><span class="comment"># """</span>
<span class="comment"># This is the interface that allows for creating nested lists.</span>
<span class="comment"># You should not implement it, or speculate about its implementation</span>
<span class="comment"># """</span>
<span class="comment">#class NestedInteger:</span>
<span class="comment">#    def isInteger(self) -&gt; bool:</span>
<span class="comment">#        """</span>
<span class="comment">#        @return True if this NestedInteger holds a single integer, rather than a nested list.</span>
<span class="comment">#        """</span>
<span class="comment">#</span>
<span class="comment">#    def getInteger(self) -&gt; int:</span>
<span class="comment">#        """</span>
<span class="comment">#        @return the single integer that this NestedInteger holds, if it holds a single integer</span>
<span class="comment">#        Return None if this NestedInteger holds a nested list</span>
<span class="comment">#        """</span>
<span class="comment">#</span>
<span class="comment">#    def getList(self) -&gt; [NestedInteger]:</span>
<span class="comment">#        """</span>
<span class="comment">#        @return the nested list that this NestedInteger holds, if it holds a nested list</span>
<span class="comment">#        Return None if this NestedInteger holds a single integer</span>
<span class="comment">#        """</span>

<span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span><span class="params">(object)</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nestedList)</span>:</span>
        self.stack = []
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nestedList) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):
            self.stack.append(nestedList[i])


    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span>
        cur = self.stack.pop()
        <span class="keyword">return</span> cur.getInteger()

    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span>:</span>
        <span class="keyword">while</span> self.stack:
            cur = self.stack[<span class="number">-1</span>]
            <span class="keyword">if</span> cur.isInteger():
                <span class="keyword">return</span> <span class="literal">True</span>
            self.stack.pop()
            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cur.getList()) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):
                self.stack.append(cur.getList()[i])
        <span class="keyword">return</span> <span class="literal">False</span>




<span class="comment"># Your NestedIterator object will be instantiated and called as such:</span>
<span class="comment"># i, v = NestedIterator(nestedList), []</span>
<span class="comment"># while i.hasNext(): v.append(i.next())</span></code></pre>
<h2 id="6-4"><a href="#6-4" class="headerlink" title="6-4"></a>6-4</h2><p>队列。</p>
<p>树的BFS。</p>
<p><img src="./126.png" alt="Alt text"></p>
<p><img src="./127.png" alt="Alt text"></p>
<p>可以DFS也可以BFS，这里用BFS，借助队列先进先出的特性。</p>
<p>评论区答案：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span>
        <span class="string">"""</span>
<span class="string">        :type root: TreeNode</span>
<span class="string">        :rtype: List[List[int]]</span>
<span class="string">        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []
        res = []
        queue = [root]
        <span class="keyword">while</span> queue:
            <span class="comment"># 获取当前队列的长度，这个长度相当于 当前这一层的节点个数</span>
            size = len(queue)
            tmp = []
            <span class="comment"># 将队列中的元素都拿出来(也就是获取这一层的节点)，放到临时list中</span>
            <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span>
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):
                r = queue.pop(<span class="number">0</span>)
                tmp.append(r.val)
                <span class="keyword">if</span> r.left:
                    queue.append(r.left)
                <span class="keyword">if</span> r.right:
                    queue.append(r.right)
            <span class="comment"># 将临时list加入最终返回结果中</span>
            res.append(tmp)
        <span class="keyword">return</span> res</code></pre>
<p>时间复杂度： O(n)</p>
<p>空间复杂度：O(n)</p>
<p>这类题有模板，请牢记：</p>
<p><img src="./131.png" alt="Alt text"></p>
<p>由于需要level，因此这里需要使用模板2：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span>
        <span class="string">"""</span>
<span class="string">        :type root: TreeNode</span>
<span class="string">        :rtype: List[List[int]]</span>
<span class="string">        """</span>
        queue = collections.deque()
        queue.append(root)
        res = []
        <span class="keyword">while</span> queue:
            size = len(queue)
            level = []
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):
                cur = queue.popleft()
                <span class="comment">#不能删！！因为加入的可能是None，也就是左or右孩子为空也加入了</span>
                <span class="comment">#还有，也处理了本身root就是空的情况</span>
                <span class="keyword">if</span> <span class="keyword">not</span> cur:
                    <span class="keyword">continue</span>
                level.append(cur.val)
                queue.append(cur.left)
                queue.append(cur.right)
            <span class="keyword">if</span> level:
                res.append(level)
        <span class="keyword">return</span> res</code></pre>
<p>如果想和上一个代码统一，可以改：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span>
        <span class="string">"""</span>
<span class="string">        :type root: TreeNode</span>
<span class="string">        :rtype: List[List[int]]</span>
<span class="string">        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []

        queue = collections.deque()
        queue.append(root)
        res = []
        <span class="keyword">while</span> queue:
            size = len(queue)
            level = []
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):
                cur = queue.popleft()

                level.append(cur.val)
                <span class="keyword">if</span> cur.left:
                    queue.append(cur.left)
                <span class="keyword">if</span> cur.right:
                    queue.append(cur.right)
            <span class="keyword">if</span> level:
                res.append(level)
        <span class="keyword">return</span> res</code></pre>
<p>只是把list换成了deque，别的代码是一样的。</p>
<p>DFS解法暂时不看了。</p>
<p>课后习题<br><img src="./128.png" alt="Alt text"><br>直接再上题的基础上，最后逆序返回res，即res[::-1]就好了：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []

        queue = collections.deque()
        queue.append(root)
        res = []
        <span class="keyword">while</span> queue:
            size = len(queue)
            level = []
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):
                cur = queue.popleft()

                level.append(cur.val)
                <span class="keyword">if</span> cur.left:
                    queue.append(cur.left)
                <span class="keyword">if</span> cur.right:
                    queue.append(cur.right)
            <span class="keyword">if</span> level:
                res.append(level)
        <span class="keyword">return</span> res[::<span class="number">-1</span>]</code></pre>
<p><img src="./129.png" alt="Alt text"></p>
<p>还是基于之前的代码，将根节点所在层视为第0层，判断当前层是奇数层还是偶数层，偶数层则从左往右，奇数层则从右往左。</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []

        queue = collections.deque()
        queue.append(root)
        res = []
        cnt=<span class="number">0</span><span class="comment">#层的奇偶，偶数：从左往右；奇数：从右往左(逆序即可)，根节点所在层为第0层</span>
        <span class="keyword">while</span> queue:
            size = len(queue)
            level = []
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):
                cur=queue.popleft()
                level.append(cur.val)

                <span class="keyword">if</span> cur.left:
                    queue.append(cur.left)
                <span class="keyword">if</span> cur.right:
                    queue.append(cur.right)

            <span class="keyword">if</span> level:
                <span class="keyword">if</span> cnt%<span class="number">2</span>==<span class="number">0</span>:
                    res.append(level)
                <span class="keyword">else</span>:
                    res.append(level[::<span class="number">-1</span>])

            cnt+=<span class="number">1</span>
        <span class="keyword">return</span> res</code></pre>
<p><img src="./130.png" alt="Alt text"></p>
<p>层序遍历，还是基于上述代码，只需要获取每一层的最一个结点值就好了(我怎么一开始就没想到。。。)</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []

        queue = collections.deque()
        queue.append(root)
        res = []
        <span class="keyword">while</span> queue:
            size = len(queue)
            level = []
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):
                cur = queue.popleft()
                level.append(cur.val)
                <span class="keyword">if</span> cur.left:
                    queue.append(cur.left)
                <span class="keyword">if</span> cur.right:
                    queue.append(cur.right)
            <span class="keyword">if</span> level:
                res.append(level[<span class="number">-1</span>])
        <span class="keyword">return</span> res</code></pre>
<h2 id="6-5（好难哦）"><a href="#6-5（好难哦）" class="headerlink" title="6-5（好难哦）"></a>6-5（好难哦）</h2><p>队列。</p>
<p>(无权)图的BFS。</p>
<p><img src="./132.png" alt="Alt text"></p>
<p><img src="./133.png" alt="Alt text"></p>
<p><img src="./134.png" alt="Alt text"></p>
<p>评论区Python版本：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span>
        <span class="keyword">from</span> collections <span class="keyword">import</span> deque
        deq=deque()
        visited=set()

        deq.append((n,<span class="number">0</span>))
        <span class="keyword">while</span> deq:
            number,step=deq.popleft()
            targets=[number-i*i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,int(number**<span class="number">0.5</span>)+<span class="number">1</span>)]
            <span class="keyword">for</span> target <span class="keyword">in</span> targets:
                <span class="comment">#由于只遍历到(number**0.5)，因此target不可能为负数，因此下面这个判断可省略</span>
                <span class="comment">#if target&lt;0:</span>
                <span class="comment">#    break</span>
                <span class="keyword">if</span> target==<span class="number">0</span>:<span class="keyword">return</span> step+<span class="number">1</span>
                <span class="comment">#这个if相当于剪枝</span>
                <span class="keyword">if</span> target <span class="keyword">not</span> <span class="keyword">in</span> visited:
                    deq.append((target,step+<span class="number">1</span>))
                    visited.add(target)</code></pre>
<p>图示很清楚了：</p>
<p><img src="./135.png" alt="Alt text"></p>
<p>看代码勉强看得懂，自己还真想不到，还得多练啊！</p>
<p>Note：</p>
<ul>
<li><p>对于无权图-&gt;可以BFS，就像本题</p>
</li>
<li><p>对于有权图-&gt;迪杰斯塔拉，遇到再说吧</p>
</li>
</ul>
<p>课后习题<br><img src="./136.png" alt="Alt text"></p>
<p><img src="./137.png" alt="Alt text"></p>
<p><img src="./138.png" alt="Alt text"></p>
<p><img src="./139.png" alt="Alt text"></p>
<p>不想做，都是困难题。。。</p>
<h2 id="6-6，6-7"><a href="#6-6，6-7" class="headerlink" title="6-6，6-7"></a>6-6，6-7</h2><p>优先队列：底层是堆</p>
<p><img src="./140.png" alt="Alt text"></p>
<p>用优先队列解题：<br><img src="./141.png" alt="Alt text"><br><img src="./142.png" alt="Alt text"></p>
<p><img src="./144.png" alt="Alt text"><br><img src="./143.png" alt="Alt text"></p>
<p><img src="./147.png" alt="Alt text"></p>
<p>评论区Python版本，使用heapq库，维护一个长度为k的小根堆：</p>
<pre><code class="python"><span class="comment">#时间复杂度：O(nlogk)</span>
<span class="comment">#空间复杂度：O(n)</span>
<span class="keyword">import</span> heapq
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self,nums, k)</span>:</span>
        <span class="comment">#要统计元素出现频率</span>
        map_ = {} <span class="comment">#nums[i]:对应出现的次数</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):
            map_[nums[i]] = map_.get(nums[i], <span class="number">0</span>) + <span class="number">1</span>
        print(map_)
        <span class="comment">#对频率排序</span>
        <span class="comment">#定义一个小顶堆，大小为k</span>
        pri_que = [] <span class="comment">#小顶堆     </span>

        <span class="comment">#用固定大小为k的小顶堆，扫描所有频率的数值</span>
        <span class="keyword">for</span> key, freq <span class="keyword">in</span> map_.items():
            heapq.heappush(pri_que, (freq, key))

            <span class="keyword">if</span> len(pri_que) &gt; k: <span class="comment">#如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span>
                heapq.heappop(pri_que)<span class="comment">#出现次数最少的出队(优先级最高~~)</span>


        <span class="comment">#找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒叙来输出到数组#用不到额</span>
        result = []
        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):
            result.append( heapq.heappop(pri_que)[<span class="number">1</span>])
        <span class="keyword">return</span> result</code></pre>
<p><img src="./145.png" alt="Alt text"></p>
<p>课后习题<br><img src="./146.png" alt="Alt text"></p>
<p><img src="./148.png" alt="Alt text"></p>
<p>评论区Python使用优先队列的解法，赞！</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span>
        <span class="keyword">if</span> len(lists)==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span>
        <span class="keyword">if</span> len(lists)==<span class="number">1</span>: <span class="keyword">return</span> lists[<span class="number">0</span>]
        head=ListNode() 
        h = head
        que = []
        <span class="comment"># 初始化que</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):
            <span class="keyword">if</span> lists[i]:
                heapq.heappush(que, (lists[i].val,i))
        <span class="comment"># 逐次弹出最小的 加入新元素</span>
        <span class="keyword">while</span> que :
            <span class="comment"># 加入最小的</span>
            val_min, ind_min = heapq.heappop(que)
            h.next = ListNode(val_min)
            h=h.next
            <span class="comment"># 被添加元素所在链表后移</span>
            lists[ind_min] = lists[ind_min].next
            <span class="comment">#若被添加元素所在链表还不为空，就继续把它的剩余部分加入优先队列</span>
            <span class="keyword">if</span> lists[ind_min]: 
                heapq.heappush(que, (lists[ind_min].val, ind_min))
        <span class="keyword">return</span> head.next</code></pre>
<p>还有一种同时可以应对无序场景，此时将全部元素加入优先队列：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> lists <span class="keyword">or</span> len(lists) == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="literal">None</span>
        <span class="keyword">import</span> heapq
        heap = []
        <span class="comment"># 首先 for 嵌套 while 就是将所有元素都取出放入堆中</span>
        <span class="keyword">for</span> node <span class="keyword">in</span> lists:
            <span class="keyword">while</span> node:
                heapq.heappush(heap, node.val)
                node = node.next
        dummy = ListNode(<span class="literal">None</span>)
        cur = dummy
        <span class="comment"># 依次将堆中的元素取出(因为是小顶堆，所以每次出来的都是目前堆中值最小的元素），然后重新构建一个列表返回</span>
        <span class="keyword">while</span> heap:
            temp_node = ListNode(heappop(heap))
            cur.next = temp_node
            cur = temp_node
        <span class="keyword">return</span> dummy.next</code></pre>
<p>还有一种暴力法，直接去除全部元素，排序，加入链表：</p>
<pre><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, val=0, next=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.next = next</span>
<span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode:</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> lists <span class="keyword">or</span> len(lists) == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="literal">None</span>
        <span class="keyword">import</span> heapq
        all_vals = []
        <span class="keyword">for</span> l <span class="keyword">in</span> lists:
            <span class="keyword">while</span> l:
                all_vals.append(l.val)
                l = l.next
        all_vals.sort()
        dummy = ListNode(<span class="literal">None</span>)
        cur = dummy
        <span class="keyword">for</span> i <span class="keyword">in</span> all_vals:
            temp_node = ListNode(i)
            cur.next = temp_node
            cur = temp_node

        <span class="keyword">return</span> dummy.next</code></pre>
<h1 id="第七章：递归"><a href="#第七章：递归" class="headerlink" title="第七章：递归"></a>第七章：递归</h1><h2 id="7-1"><a href="#7-1" class="headerlink" title="7-1"></a>7-1</h2><p><img src="./149.png" alt="Alt text"></p>
<p><img src="./150.png" alt="Alt text"></p>
<p><img src="./151.png" alt="Alt text"></p>
<p><img src="./152.png" alt="Alt text"></p>
<p><img src="./153.png" alt="Alt text"></p>
<p>Python版本：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:
            <span class="keyword">return</span> <span class="number">0</span>
        left_maxdepth=self.maxDepth(root.left)
        right_maxdepth=self.maxDepth(root.right)
        <span class="keyword">return</span> <span class="number">1</span>+max(left_maxdepth,right_maxdepth)</code></pre>
<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。</p>
<p>空间复杂度：O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p>
<p>也可以用BFS，直接统计最大深度.</p>
<p>我根据之前的二叉树BFS代码改的：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="number">0</span>
        res=<span class="number">0</span>
        queue = [root]
        <span class="keyword">while</span> queue:
            <span class="comment"># 获取当前队列的长度，这个长度相当于 当前这一层的节点个数</span>
            size = len(queue)
            <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span>
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):
                r = queue.pop(<span class="number">0</span>)
                <span class="keyword">if</span> r.left:
                    queue.append(r.left)
                <span class="keyword">if</span> r.right:
                    queue.append(r.right)
            res+=<span class="number">1</span>
        <span class="keyword">return</span> res</code></pre>
<p>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。</p>
<p>空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</p>
<p>课后习题<br><img src="./154.png" alt="Alt text"></p>
<p>我的解法：</p>
<p>在上一题中，求的是根结点到叶子节点的最大深度，如果根结点有一个子树为空，那么改子树的最大深度是0，是最小的，此时结果就依赖于另外一个非空子树的最大深度，该深度肯定大于0的。</p>
<p>而这里求的是根结点到叶子最小的深度，此时如果根结点的某一个子树为空，那么如果和上题代码一样，只是把max改成min，那么为空的子树得到的结果是0，但非空的子树是有叶子结点的，此时用min的话就错误的以为是空子树得到的0了，然而非空子树的对应结果才是正确的。</p>
<p>因此需要改一下代码，判断左右子树是否为空，3种情况分别对症下药：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:
            <span class="keyword">return</span> <span class="number">0</span>

        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.right:
            left_mindepth=self.minDepth(root.left)
            right_min_depth=self.minDepth(root.right)
            <span class="keyword">return</span> <span class="number">1</span>+min(left_mindepth,right_min_depth)
        <span class="keyword">elif</span> <span class="keyword">not</span> root.left:
            <span class="keyword">return</span> <span class="number">1</span>+self.minDepth(root.right)
        <span class="keyword">elif</span> <span class="keyword">not</span> root.right:
            <span class="keyword">return</span> <span class="number">1</span>+self.minDepth(root.left)</code></pre>
<p>评论区还有BFS的方案：利用BFS实现二叉树的层序遍历，第一个遇到的叶子结点就是树的最小深度。</p>
<p>我根据之前的二叉树BFS代码改的：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="number">0</span>
        res=<span class="number">0</span>
        queue = [root]
        <span class="keyword">while</span> queue:
            <span class="comment"># 获取当前队列的长度，这个长度相当于 当前这一层的节点个数</span>
            size = len(queue)
            <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span>
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):
                r = queue.pop(<span class="number">0</span>)
                <span class="comment">#第一个访问到的叶子结点所在层数就是答案~</span>
                <span class="keyword">if</span> <span class="keyword">not</span> r.left <span class="keyword">and</span> <span class="keyword">not</span> r.right:
                    <span class="keyword">return</span> res+<span class="number">1</span>
                <span class="keyword">if</span> r.left:
                    queue.append(r.left)
                <span class="keyword">if</span> r.right:
                    queue.append(r.right)
            res+=<span class="number">1</span></code></pre>
<h2 id="7-2"><a href="#7-2" class="headerlink" title="7-2"></a>7-2</h2><p><img src="./155.png" alt="Alt text"></p>
<p><img src="./156.png" alt="Alt text"></p>
<p>我改成Python版本：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> 
        self.invertTree(root.left)
        self.invertTree(root.right)

        root.left,root.right=root.right,root.left
        <span class="keyword">return</span> root</code></pre>
<p>或者多加一句判断，但我不知道这是否多余，不知道能不能起到什么作用：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root :
            <span class="keyword">return</span> 
        <span class="comment">#emm，这句是否多余呢？</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:
            <span class="keyword">return</span> root
        self.invertTree(root.left)
        self.invertTree(root.right)

        root.left,root.right=root.right,root.left
        <span class="keyword">return</span> root</code></pre>
<p>时间复杂度：O(N)，其中 N 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。</p>
<p>空间复杂度：O(N)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(log⁡N)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。</p>
<p>也可以用二叉树的BFS：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="comment">#以下两种写法都可以</span>
            <span class="comment">#return</span>
            <span class="keyword">return</span> root

        queue = [root]
        <span class="keyword">while</span> queue:
            <span class="comment"># 获取当前队列的长度，这个长度相当于 当前这一层的节点个数</span>
            size = len(queue)
            <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span>
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):
                r = queue.pop(<span class="number">0</span>)

                r.left,r.right=r.right,r.left<span class="comment">#swap</span>

                <span class="keyword">if</span> r.left:
                    queue.append(r.left)
                <span class="keyword">if</span> r.right:
                    queue.append(r.right)
        <span class="keyword">return</span> root</code></pre>
<p>课后习题<br><img src="./157.png" alt="Alt text"><br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>DFS：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span>
        <span class="keyword">if</span> (<span class="keyword">not</span> p) <span class="keyword">and</span> (<span class="keyword">not</span> q):<span class="comment">#全空</span>
            <span class="keyword">return</span> <span class="literal">True</span>
        <span class="keyword">elif</span> (<span class="keyword">not</span> p) <span class="keyword">or</span> (<span class="keyword">not</span> q):<span class="comment">#只有一个为空</span>
            <span class="keyword">return</span> <span class="literal">False</span>
        <span class="comment">#都不为空</span>
        <span class="keyword">elif</span> p.val !=q.val:
            <span class="keyword">return</span> <span class="literal">False</span>
        <span class="keyword">else</span>:
            <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</code></pre>
<p>我写的BFS：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span>
        <span class="comment">#都为空--&gt;相同</span>
        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:
            <span class="keyword">return</span> <span class="literal">True</span>
        <span class="comment">#只有一个为空--&gt;不相同</span>
        <span class="keyword">elif</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:
            <span class="keyword">return</span> <span class="literal">False</span>

        <span class="comment">#用两个队列分别存储两棵树的BFS结果</span>
        queue1 = [p]
        queue2=[q]
        <span class="keyword">while</span> queue1 <span class="keyword">and</span> queue2:<span class="comment"># 用and 或 or都可以，只写while queue1或者while queue2也可以~</span>
            <span class="comment"># 获取当前队列的长度，这个长度相当于 当前这一层的节点个数</span>
            size1 = len(queue1)
            size2 = len(queue2)
            <span class="comment">#同一层的结点个数不同--&gt;不相同</span>
            <span class="keyword">if</span> size1!=size2:
                <span class="keyword">return</span> <span class="literal">False</span>
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size1):
                r1 = queue1.pop(<span class="number">0</span>)
                r2=queue2.pop(<span class="number">0</span>)
                <span class="comment">#只有一个为空--&gt;不相同</span>
                <span class="keyword">if</span> (r1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> r2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">or</span> (r2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> r1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):
                    <span class="keyword">return</span> <span class="literal">False</span>
                <span class="comment">#都为空--&gt;当前结点相同，继续出队下一个结点做判断</span>
                <span class="keyword">if</span> <span class="keyword">not</span> r1 <span class="keyword">and</span> <span class="keyword">not</span> r2:
                    <span class="keyword">continue</span>
                <span class="comment">#都不为空--&gt;结构相同，则比较值</span>
                <span class="keyword">if</span> r1 <span class="keyword">and</span> r2 <span class="keyword">and</span> (r1.val!=r2.val):
                    <span class="keyword">return</span> <span class="literal">False</span>

                queue1.append(r1.left)
                queue1.append(r1.right)

                queue2.append(r2.left)
                queue2.append(r2.right)
        <span class="keyword">return</span> <span class="literal">True</span></code></pre>
<p>官方题解先判断值是都相同，并且没有将None结点入队：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:
            <span class="keyword">return</span> <span class="literal">True</span>
        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:
            <span class="keyword">return</span> <span class="literal">False</span>

        queue1 = collections.deque([p])
        queue2 = collections.deque([q])

        <span class="keyword">while</span> queue1 <span class="keyword">and</span> queue2:
            node1 = queue1.popleft()
            node2 = queue2.popleft()
            <span class="keyword">if</span> node1.val != node2.val:
                <span class="keyword">return</span> <span class="literal">False</span>
            left1, right1 = node1.left, node1.right
            left2, right2 = node2.left, node2.right
            <span class="keyword">if</span> (<span class="keyword">not</span> left1) ^ (<span class="keyword">not</span> left2):
                <span class="keyword">return</span> <span class="literal">False</span>
            <span class="keyword">if</span> (<span class="keyword">not</span> right1) ^ (<span class="keyword">not</span> right2):
                <span class="keyword">return</span> <span class="literal">False</span>
            <span class="keyword">if</span> left1:
                queue1.append(left1)
            <span class="keyword">if</span> right1:
                queue1.append(right1)
            <span class="keyword">if</span> left2:
                queue2.append(left2)
            <span class="keyword">if</span> right2:
                queue2.append(right2)

        <span class="keyword">return</span> <span class="keyword">not</span> queue1 <span class="keyword">and</span> <span class="keyword">not</span> queue2</code></pre>
<p><img src="./158.png" alt="Alt text"><br>DFS:</p>
<p>官方：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span>
        <span class="comment">#我自己加了个判断条件，貌似快了跟多</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="literal">True</span>

        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(p,q)</span>:</span>
            <span class="comment">#树为空--&gt;对称</span>
            <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:
                <span class="keyword">return</span> <span class="literal">True</span>
            <span class="comment">#此时只有左子树或右子树不为空--&gt;不对称</span>
            <span class="keyword">if</span> (<span class="keyword">not</span> p) <span class="keyword">or</span>  (<span class="keyword">not</span> q):
                <span class="keyword">return</span> <span class="literal">False</span>
            <span class="keyword">return</span> p.val ==q.val <span class="keyword">and</span> check(p.left,q.right) <span class="keyword">and</span> check(p.right,q.left)

        <span class="keyword">return</span> check(root,root)</code></pre>
<p>评论区BFS解法(tql…)：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span>
        <span class="string">"""</span>
<span class="string">        :type root: TreeNode</span>
<span class="string">        :rtype: bool</span>
<span class="string">        """</span>
        <span class="comment">#空树 or 树只有一个结点而无左右孩子--&gt;对称</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> <span class="keyword">not</span> (root.left <span class="keyword">or</span> root.right):
            <span class="keyword">return</span> <span class="literal">True</span>
        <span class="comment"># 用队列保存节点    </span>
        queue = [root.left,root.right]
        <span class="keyword">while</span> queue:
            <span class="comment"># 从队列中取出两个节点，再比较这两个节点</span>
            left = queue.pop(<span class="number">0</span>)
            right = queue.pop(<span class="number">0</span>)
            <span class="comment"># 两个节点都为空--&gt;继续循环，出队新的两个元素</span>
            <span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">or</span> right):
                <span class="keyword">continue</span>
            <span class="comment"># 两者只有一个为空--&gt;不对称</span>
            <span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">and</span> right):
                <span class="keyword">return</span> <span class="literal">False</span>
            <span class="comment"># 此时两者都不为空，但值不同--&gt;不对称</span>
            <span class="keyword">if</span> left.val!=right.val:
                <span class="keyword">return</span> <span class="literal">False</span>
            <span class="comment"># 将左节点的左孩子， 右节点的右孩子放入队列</span>
            queue.append(left.left)
            queue.append(right.right)
            <span class="comment"># 将左节点的右孩子，右节点的左孩子放入队列</span>
            queue.append(left.right)
            queue.append(right.left)
        <span class="keyword">return</span> <span class="literal">True</span></code></pre>
<p><img src="./160.png" alt="Alt text"><br>DFS:</p>
<p>我写了一半多吧，最后忘了写递归判断左右子树，于是参考了下题解</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span>
        <span class="comment">#空树--&gt;是平衡二叉树</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="literal">True</span>

        <span class="function"><span class="keyword">def</span> <span class="title">cal_depth</span><span class="params">(p)</span>:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> p:
                <span class="keyword">return</span> <span class="number">0</span>
            <span class="keyword">return</span> <span class="number">1</span>+max(cal_depth(p.left),cal_depth(p.right))

        left_depth=cal_depth(root.left)
        right_depth=cal_depth(root.right)
        <span class="keyword">if</span> abs(left_depth-right_depth)&gt;<span class="number">1</span>:
            <span class="keyword">return</span> <span class="literal">False</span>
        <span class="keyword">return</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</code></pre>
<p><img src="./161.png" alt="Alt text"></p>
<p>思路是构造一个获取当前节点最大深度的方法 depth(root) ，通过比较此子树的左右子树的最大高度差abs(depth(root.left) - depth(root.right))，来判断此子树是否是二叉平衡树。若树的所有子树都平衡时，此树才平衡。</p>
<p>从官方那里了解到，这种方法叫做<strong>自顶向下的递归</strong>:</p>
<p>类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。</p>
<p>既然有自顶向下的递归，那就有<strong>自底向上</strong>的递归：</p>
<p>自顶向下递归，对于同一个节点，函数 cal_depth会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数 cal_depth只会被调用一次。</p>
<p>具体的思路是对二叉树做后序遍历，从底至顶返回子树最大高度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</p>
<p>大佬的代码：</p>
<p><img src="./162.png" alt="Alt text"></p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span>
        <span class="keyword">return</span> self.recur(root) != <span class="number">-1</span>

    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self, root)</span>:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="number">0</span>
        <span class="comment">#左子树深度</span>
        left = self.recur(root.left)
        <span class="keyword">if</span> left == <span class="number">-1</span>: 
            <span class="keyword">return</span> <span class="number">-1</span>
        <span class="comment">#右子树深度</span>
        right = self.recur(root.right)
        <span class="keyword">if</span> right == <span class="number">-1</span>: 
            <span class="keyword">return</span> <span class="number">-1</span>

        <span class="keyword">return</span> max(left, right) + <span class="number">1</span> <span class="keyword">if</span> abs(left - right) &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">-1</span></code></pre>
<p><img src="./159.png" alt="Alt text"></p>
<p>这题我上来就是：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="number">0</span>
        <span class="keyword">return</span> <span class="number">1</span>+self.countNodes(root.left)+self.countNodes(root.right)</code></pre>
<p>此时的时间/空间复杂度都是O(n).</p>
<p>如何优化呢？</p>
<p>题目中的树是完全二叉树，所以可以利用完全二叉树的性质来优化时间复杂度。</p>
<p><img src="./163.png" alt="Alt text"></p>
<p><img src="./164.png" alt="Alt text"></p>
<p>可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。</p>
<p>大佬的代码：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="comment">#利用：根结点的深度为1，满二叉树的结点数公式：2^满二叉树数深度-1</span>
    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="number">0</span>
        left = root.left
        right = root.right

        rightHeight = <span class="number">0</span>
        leftHeight=<span class="number">0</span>

        <span class="comment">#以下求树的深度用到了完全二叉树的性质</span>
        <span class="keyword">while</span> left: <span class="comment">#求左子树深度</span>
            left = left.left
            leftHeight += <span class="number">1</span>
        <span class="keyword">while</span> right: <span class="comment">#求右子树深度</span>
            right = right.right
            rightHeight += <span class="number">1</span>
        print(leftHeight,rightHeight)
        <span class="string">"""</span>
<span class="string">        2 1</span>
<span class="string">        1 1</span>
<span class="string">        1 0</span>
<span class="string">        0 0</span>
<span class="string">        """</span>
        <span class="comment">#如果左右子树的深度相等，则说明以该结点为根的子树是一棵满二叉树</span>
        <span class="comment">#此时直接用2^树深度-1求解子树结点个数即可</span>
        <span class="keyword">if</span> leftHeight == rightHeight:
            print(<span class="string">'dd'</span>,leftHeight)
            <span class="keyword">return</span> (<span class="number">2</span>**(leftHeight+<span class="number">1</span>)) - <span class="number">1</span> <span class="comment">#加1是因为这里的height是子树的深度，而我们需要得到有根结点的树的深度，所以深度加1</span>
        <span class="keyword">return</span> self.countNodes(root.left) + self.countNodes(root.right) + <span class="number">1</span>       </code></pre>
<p>时间复杂度：O(logn * logn)，比O(n)快很多~</p>
<p>空间复杂度：O(logn)</p>
<p>我只能膜拜了，大佬太强了~~</p>
<h2 id="7-3"><a href="#7-3" class="headerlink" title="7-3"></a>7-3</h2><p>注意递归终止条件。</p>
<p><img src="./165.png" alt="Alt text"></p>
<p><img src="./166.png" alt="Alt text"></p>
<p>Python版本：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: Optional[TreeNode], targetSum: int)</span> -&gt; bool:</span>
        <span class="comment">#root为空--&gt;找不到</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="literal">False</span>
        <span class="comment">#root是叶子结点--&gt;判断root.val是否等于targetSum</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:
            <span class="keyword">return</span> root.val==targetSum
        <span class="keyword">return</span> self.hasPathSum(root.left,targetSum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right,targetSum-root.val)</code></pre>
<p>评论区BFS解法：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="literal">False</span>
        que = collections.deque()
        que.append((root, root.val))
        <span class="keyword">while</span> que:
            <span class="comment">#结点，结点值(从根结点一路向下累加的值)</span>
            node, cusum = que.popleft()
            <span class="comment">#如果是叶子节点，并且这个叶子结点的值等于sum--&gt;找到啦</span>
            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> cusum == sum:
                <span class="keyword">return</span> <span class="literal">True</span>
            <span class="keyword">if</span> node.left:
                que.append((node.left, cusum + node.left.val))
            <span class="keyword">if</span> node.right:
                que.append((node.right, cusum+ node.right.val))
        <span class="keyword">return</span> <span class="literal">False</span></code></pre>
<p>上面的队列也可以替换成栈，此时不再是BFS了，因为结点访问顺序变了，但代码一模一样：<br><img src="./168.png" alt="Alt text"></p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, sum)</span>:</span>
        <span class="string">"""</span>
<span class="string">        :type root: TreeNode</span>
<span class="string">        :type sum: int</span>
<span class="string">        :rtype: bool</span>
<span class="string">        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="literal">False</span>
        stack = []
        stack.append((root, root.val))
        <span class="keyword">while</span> stack:
            node, path = stack.pop()
            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> path == sum:
                <span class="keyword">return</span> <span class="literal">True</span>
            <span class="keyword">if</span> node.left:
                stack.append((node.left, path + node.left.val))
            <span class="keyword">if</span> node.right:
                stack.append((node.right, path + node.right.val))
        <span class="keyword">return</span> <span class="literal">False</span></code></pre>
<p>还有回溯法，等学完下一章回溯法再来看：<br><a href="https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-de-si-chong-jie-fa-dfs-hui-su-bfs-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-de-si-chong-jie-fa-dfs-hui-su-bfs-/</a></p>
<p>课后习题</p>
<p><img src="./167.png" alt="Alt text"><br>如果左节点不为空，且左节点没有左右孩子，那么这个节点就是左叶子</p>
<p>我一开始写成了：</p>
<pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
    <span class="comment">#root为空</span>
    <span class="keyword">if</span> <span class="keyword">not</span> root:
        <span class="keyword">return</span> <span class="number">0</span>

    leftNode=root.left
    <span class="comment">#root的左孩子是叶子结点</span>
    <span class="keyword">if</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> leftNode.left <span class="keyword">and</span> <span class="keyword">not</span> leftNode.right:
        <span class="keyword">return</span> leftNode.val
    <span class="keyword">return</span> self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)</code></pre>
<p>这是不对的！</p>
<p>当遍历到的root的左孩子是叶子结点时，应该暂时将其保存起来，在最后累计返回</p>
<p>看了大佬的题解后修改的正确代码如下：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="comment">#root为空</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="number">0</span>
        leftNode=root.left
        val=<span class="number">0</span><span class="comment">#存储root的左孩子的值，默认leftNode不是左孩子，此时值为0</span>

        <span class="comment">#如果root的左孩子leftNode是叶子结点，就更新val</span>
        <span class="keyword">if</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> leftNode.left <span class="keyword">and</span> <span class="keyword">not</span> leftNode.right:
            val=leftNode.val
        <span class="keyword">return</span> val+self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)</code></pre>
<p>或者下面这样写语义更清楚：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="comment">#root为空</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="number">0</span>

        leftNode=root.left<span class="comment">#root的左孩子</span>
        <span class="comment">#如果root的左孩子leftNode是叶子结点</span>
        <span class="keyword">if</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> leftNode.left <span class="keyword">and</span> <span class="keyword">not</span> leftNode.right:
            val=leftNode.val<span class="comment">#存储root的左孩子（是个叶子结点）的值</span>
            <span class="keyword">return</span> val+self.sumOfLeftLeaves(root.right)<span class="comment">#左孩子已经处理好了，只需递归处理右孩子</span>
        <span class="keyword">else</span>:
            <span class="keyword">return</span> self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)<span class="comment">#递归处理左右孩子</span></code></pre>
<p>有了上面的思考过程，我自己写出了下面的BFS代码：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="comment">#root为空</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="number">0</span>
        res=<span class="number">0</span>
        queue=[root]
        <span class="keyword">while</span> queue:
            r=queue.pop(<span class="number">0</span>)
            leftNode=r.left
            <span class="comment">#当前访问的结点r的左孩子是叶子结点</span>
            <span class="keyword">if</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> leftNode.left <span class="keyword">and</span> <span class="keyword">not</span> leftNode.right:
                res+=leftNode.val
            <span class="keyword">if</span> r.left:
                queue.append(r.left)
            <span class="keyword">if</span> r.right:
                queue.append(r.right)
        <span class="keyword">return</span> res</code></pre>
<h2 id="7-4"><a href="#7-4" class="headerlink" title="7-4"></a>7-4</h2><p><img src="./169.png" alt="Alt text"></p>
<p><img src="./170.png" alt="Alt text"></p>
<p>Python版本：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root: TreeNode)</span> -&gt; List[str]:</span>
        <span class="comment">#空结点</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []

        res=[]

        <span class="comment">#如果root是叶子节点</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:
            res.append(str(root.val))
            <span class="keyword">return</span> res

        left_paths=self.binaryTreePaths(root.left)
        <span class="keyword">for</span> s <span class="keyword">in</span> left_paths:
            res.append((str(root.val)+<span class="string">'-&gt;'</span>+s))

        right_paths=self.binaryTreePaths(root.right)
        <span class="keyword">for</span> s <span class="keyword">in</span> right_paths:
            res.append(str(root.val)+<span class="string">'-&gt;'</span>+s)
        <span class="keyword">return</span> res</code></pre>
<p>牛蛙牛蛙，我想不到~~</p>
<p>走一遍就能理解了，注意left_path中的每一个元素都是形如’1-&gt;2’的字符串：这种字符串<strong>从下往上</strong>，一点一点变长（刚开始只有叶子结点，后来加入叶子节点的父结点，直到往上走到根结点）。</p>
<p>评论区大佬的BFS：先写叶子结点，从后往前拼接字符串得到路径（和递归方法思路一致）</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root)</span>:</span>    
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []
        <span class="comment"># res是最终结果集，queue中存放的是封装的[节点,临时路径]    </span>
        res = []
        queue = [[root,<span class="string">""</span>]]
        <span class="keyword">while</span> queue:
            node,tmp = queue.pop(<span class="number">0</span>)
            <span class="keyword">if</span> <span class="keyword">not</span> node:
                <span class="keyword">continue</span>
            <span class="comment"># 如果当前节点是叶子节点，将其拼装后放入最终结果集中    </span>
            <span class="keyword">if</span> node <span class="keyword">and</span> <span class="keyword">not</span> (node.left <span class="keyword">or</span> node.right):
                res.append(tmp+str(node.val))
                <span class="keyword">continue</span>
            <span class="comment"># 如果当前节点不是叶子节点，将其左子树和新路径放入队列中    </span>
            <span class="keyword">if</span> node.left:
                queue.append( [node.left,tmp+str(node.val)+<span class="string">"-&gt;"</span>] )
            <span class="comment"># 如果当前节点不是叶子节点，将其右子树和新路径放入队列中    </span>
            <span class="keyword">if</span> node.right:
                queue.append( [node.right,tmp+str(node.val)+<span class="string">"-&gt;"</span>] )
        <span class="keyword">return</span> res</code></pre>
<p>好像两个cotinue不加也行：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root)</span>:</span>    
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []
        <span class="comment"># res是最终结果集，queue中存放的是封装的[节点,临时路径]    </span>
        res = []
        queue = [[root,<span class="string">""</span>]]
        <span class="keyword">while</span> queue:
            node,tmp = queue.pop(<span class="number">0</span>)
            <span class="comment"># 如果当前节点是叶子节点，将其拼装后放入最终结果集中    </span>
            <span class="keyword">if</span> node <span class="keyword">and</span> <span class="keyword">not</span> (node.left <span class="keyword">or</span> node.right):
                res.append(tmp+str(node.val))
            <span class="comment"># 如果当前节点不是叶子节点，将其左子树和新路径放入队列中    </span>
            <span class="keyword">if</span> node.left:
                queue.append( [node.left,tmp+str(node.val)+<span class="string">"-&gt;"</span>] )
            <span class="comment"># 如果当前节点不是叶子节点，将其右子树和新路径放入队列中    </span>
            <span class="keyword">if</span> node.right:
                queue.append( [node.right,tmp+str(node.val)+<span class="string">"-&gt;"</span>] )
        <span class="keyword">return</span> res</code></pre>
<p>也可以用两个队列，一个存结点，一个存从根结点到该结点的路径（和上面方法不同，这里结果从根结点开始，从左到右变长）：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root)</span>:</span>    
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []
        <span class="comment"># res是最终路径结果集  </span>
        res = []
        <span class="comment">#一个node和一个path对应~</span>
        node_queue = [root]
        path_queue=[str(root.val)]
        <span class="keyword">while</span> node_queue:
            node = node_queue.pop(<span class="number">0</span>)
            path=path_queue.pop(<span class="number">0</span>)
            <span class="comment"># 如果当前节点是叶子节点，将其拼装后放入最终结果集中    </span>
            <span class="keyword">if</span> <span class="keyword">not</span> (node.left <span class="keyword">or</span> node.right):
                res.append(path)
            <span class="keyword">if</span> node.left:
                node_queue.append(node.left)
                path_queue.append(path+<span class="string">'-&gt;'</span>+str(node.left.val)) 
            <span class="keyword">if</span> node.right:
                node_queue.append(node.right)
                path_queue.append(path+<span class="string">'-&gt;'</span>+str(node.right.val))
        <span class="keyword">return</span> res</code></pre>
<p>课后习题<br><img src="./171.png" alt="Alt text"></p>
<p>有了前面的铺垫，这题我自己独立做出来了：遍历从根节点出发的所有路径，存到res列表，然后返回res中所有满足和为targetSum的元素</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: Optional[TreeNode], targetSum: int)</span> -&gt; List[List[int]]:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []

        <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(root,targetSum)</span>:</span>
            res=[]
            <span class="comment">#root是叶子结点</span>
            <span class="keyword">if</span> <span class="keyword">not</span> (root.left <span class="keyword">or</span> root.right):
                res.append([root.val])
            <span class="comment">#root不是叶子结点,有左孩子</span>
            <span class="keyword">if</span> root.left:
                left_paths=solve(root.left,targetSum)
                <span class="keyword">if</span> left_paths:
                    <span class="keyword">for</span> s <span class="keyword">in</span> left_paths:
                        res.append(s+[root.val])

            <span class="comment">#root不是叶子结点，有右孩子</span>
            <span class="keyword">if</span> root.right:
                right_paths=solve(root.right,targetSum)
                <span class="keyword">if</span> len(right_paths)!=<span class="number">0</span>:
                    <span class="keyword">for</span> s <span class="keyword">in</span> right_paths:
                        res.append(s+[root.val])     
            <span class="keyword">return</span> res           
        res=solve(root,targetSum)
        <span class="keyword">return</span> [i[::<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res <span class="keyword">if</span> sum(i)==targetSum]</code></pre>
<p>因为没有用到targetSum，所以可以写成：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: Optional[TreeNode], targetSum: int)</span> -&gt; List[List[int]]:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []

        <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(root)</span>:</span>
            res=[]
            <span class="comment">#root是叶子结点</span>
            <span class="keyword">if</span> <span class="keyword">not</span> (root.left <span class="keyword">or</span> root.right):
                res.append([root.val])
            <span class="comment">#root不是叶子结点,有左孩子</span>
            <span class="keyword">if</span> root.left:
                left_paths=solve(root.left)
                <span class="keyword">if</span> left_paths:
                    <span class="keyword">for</span> s <span class="keyword">in</span> left_paths:
                        res.append(s+[root.val])

            <span class="comment">#root不是叶子结点，有右孩子</span>
            <span class="keyword">if</span> root.right:
                right_paths=solve(root.right)
                <span class="keyword">if</span> len(right_paths)!=<span class="number">0</span>:
                    <span class="keyword">for</span> s <span class="keyword">in</span> right_paths:
                        res.append(s+[root.val])     
            <span class="keyword">return</span> res           
        res=solve(root)
        <span class="keyword">return</span> [i[::<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res <span class="keyword">if</span> sum(i)==targetSum]</code></pre>
<p>当然，如果想和前面的题统一，可以及时return：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: Optional[TreeNode], targetSum: int)</span> -&gt; List[List[int]]:</span>
        <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(root)</span>:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> root:
                <span class="keyword">return</span> []
            res=[]
            <span class="comment">#root是叶子结点</span>
            <span class="keyword">if</span> <span class="keyword">not</span> (root.left <span class="keyword">or</span> root.right):
                res.append([root.val])
                <span class="keyword">return</span> res

            <span class="comment">#root不是叶子结点,有左孩子</span>
            left_paths=solve(root.left)
            <span class="keyword">for</span> s <span class="keyword">in</span> left_paths:
                res.append(s+[root.val])

            <span class="comment">#root不是叶子结点，有右孩子</span>
            right_paths=solve(root.right)
            <span class="keyword">for</span> s <span class="keyword">in</span> right_paths:
                res.append(s+[root.val])  

            <span class="keyword">return</span> res           
        res=solve(root)
        <span class="keyword">return</span> [i[::<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res <span class="keyword">if</span> sum(i)==targetSum]</code></pre>
<p>但是，上面的方法在递归时没有用到TargetSum，而是在求得全部从根结点到叶子节点的路径后再做判断的，那能不能在递归时就确定最终的结果呢？</p>
<p>可以!</p>
<p>只需要加个判断：叶子节点的值是否等于当前递归的targetSum，更改后代码如下：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: Optional[TreeNode], targetSum: int)</span> -&gt; List[List[int]]:</span>
        <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(root,targetSum)</span>:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> root:
                <span class="keyword">return</span> []
            res=[]
            <span class="comment">#root是叶子结点,并且这个叶子节点的值等于当前递归的targetSum</span>
            <span class="keyword">if</span> <span class="keyword">not</span> (root.left <span class="keyword">or</span> root.right) <span class="keyword">and</span> root.val==targetSum:
                res.append([root.val])
                <span class="keyword">return</span> res

            <span class="comment">#root不是叶子结点,有左孩子</span>
            left_paths=solve(root.left,targetSum-root.val)
            <span class="keyword">for</span> s <span class="keyword">in</span> left_paths:
                res.append(s+[root.val])

            <span class="comment">#root不是叶子结点，有右孩子</span>
            right_paths=solve(root.right,targetSum-root.val)
            <span class="keyword">for</span> s <span class="keyword">in</span> right_paths:
                res.append(s+[root.val])  

            <span class="keyword">return</span> res           
        res=solve(root,targetSum)
        <span class="keyword">return</span> [i[::<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res]</code></pre>
<p>我根据之前的题目，也写出了BFS：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: Optional[TreeNode], targetSum: int)</span> -&gt; List[List[int]]:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []

        res=[]
        node_queue=[root]<span class="comment">#当前结点</span>
        path_queue=[[root.val]]<span class="comment">#从根结点到当前结点的路径</span>

        <span class="keyword">while</span> node_queue:
            cur_node=node_queue.pop(<span class="number">0</span>)
            cur_path=path_queue.pop(<span class="number">0</span>)
            <span class="comment">#如果当前结点是叶子结点</span>
            <span class="keyword">if</span> <span class="keyword">not</span> (cur_node.left <span class="keyword">or</span> cur_node.right):
                res.append(cur_path)

            <span class="comment">#不是叶子结点,有左孩子</span>
            <span class="keyword">if</span> cur_node.left:
                node_queue.append(cur_node.left)
                path_queue.append(cur_path+[cur_node.left.val])
            <span class="comment">#不是叶子结点，有右孩子</span>
            <span class="keyword">if</span> cur_node.right:
                node_queue.append(cur_node.right)
                path_queue.append(cur_path+[cur_node.right.val])
        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> res <span class="keyword">if</span> sum(i)==targetSum]</code></pre>
<p>没错，这也是求出来了所有路径，最后判断的路径和是否等于targetSum的。</p>
<p>借鉴了之前两个队列的方法，从上往下找。</p>
<p>但上面的方法仍然没有用到targetSum。</p>
<p>可以再加一个队列，存储从根结点到当前结点的累加值，如果当前结点是叶子结点，并且从根结点到当前叶子结点的累加值等于targetSum，就找到了一条路径。</p>
<p>我写的代码：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: Optional[TreeNode], targetSum: int)</span> -&gt; List[List[int]]:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []

        res=[]
        node_queue=[root]<span class="comment">#当前结点</span>
        path_queue=[[root.val]]<span class="comment">#从根结点到当前结点的路径</span>
        dist_queue=[root.val]<span class="comment">#从根结点到当前结点的累加值</span>

        <span class="keyword">while</span> node_queue:
            cur_node=node_queue.pop(<span class="number">0</span>)
            cur_path=path_queue.pop(<span class="number">0</span>)
            cur_dist=dist_queue.pop(<span class="number">0</span>)
            <span class="comment">#如果当前结点是叶子结点,且从根结点到当前结点的累加值等于targetSum</span>
            <span class="keyword">if</span> <span class="keyword">not</span> (cur_node.left <span class="keyword">or</span> cur_node.right) <span class="keyword">and</span> cur_dist==targetSum:
                res.append(cur_path)

            <span class="comment">#不是叶子结点,有左孩子</span>
            <span class="keyword">if</span> cur_node.left:
                node_queue.append(cur_node.left)
                path_queue.append(cur_path+[cur_node.left.val])
                dist_queue.append(cur_dist+cur_node.left.val)
            <span class="comment">#不是叶子结点，有右孩子</span>
            <span class="keyword">if</span> cur_node.right:
                node_queue.append(cur_node.right)
                path_queue.append(cur_path+[cur_node.right.val])
                dist_queue.append(cur_dist+cur_node.right.val)
        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> res]</code></pre>
<p><img src="./172.png" alt="Alt text"></p>
<p>直接在之前代码最后处理下数字转字符串再转数字即可：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(root)</span>:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> root:
                <span class="keyword">return</span> []
            res=[]
            <span class="comment">#root是叶子结点,并且这个叶子节点的值等于当前递归的targetSum</span>
            <span class="keyword">if</span> <span class="keyword">not</span> (root.left <span class="keyword">or</span> root.right):
                res.append([root.val])
                <span class="keyword">return</span> res

            <span class="comment">#root不是叶子结点,有左孩子</span>
            left_paths=solve(root.left)
            <span class="keyword">for</span> s <span class="keyword">in</span> left_paths:
                res.append(s+[root.val])

            <span class="comment">#root不是叶子结点，有右孩子</span>
            right_paths=solve(root.right)
            <span class="keyword">for</span> s <span class="keyword">in</span> right_paths:
                res.append(s+[root.val])  

            <span class="keyword">return</span> res           
        res=solve(root)
        sum=<span class="number">0</span>
        <span class="keyword">for</span> path <span class="keyword">in</span> res:
            path=path[::<span class="number">-1</span>]
            path=[str(i) <span class="keyword">for</span> i <span class="keyword">in</span> path]
            sum+=int(<span class="string">''</span>.join(path))
        <span class="keyword">return</span> sum</code></pre>
<p>BFS解法一样，也是做个后处理就AC了：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []

        res=[]
        node_queue=[root]<span class="comment">#当前结点</span>
        path_queue=[[root.val]]<span class="comment">#从根结点到当前结点的路径</span>

        <span class="keyword">while</span> node_queue:
            cur_node=node_queue.pop(<span class="number">0</span>)
            cur_path=path_queue.pop(<span class="number">0</span>)
            <span class="comment">#如果当前结点是叶子结点,且从根结点到当前结点的累加值等于targetSum</span>
            <span class="keyword">if</span> <span class="keyword">not</span> (cur_node.left <span class="keyword">or</span> cur_node.right):
                res.append(cur_path)

            <span class="comment">#不是叶子结点,有左孩子</span>
            <span class="keyword">if</span> cur_node.left:
                node_queue.append(cur_node.left)
                path_queue.append(cur_path+[cur_node.left.val])

            <span class="comment">#不是叶子结点，有右孩子</span>
            <span class="keyword">if</span> cur_node.right:
                node_queue.append(cur_node.right)
                path_queue.append(cur_path+[cur_node.right.val])

        <span class="comment">#只需加个后处理即可</span>
        sum=<span class="number">0</span>
        <span class="keyword">for</span> path <span class="keyword">in</span> res:
            path=[str(i) <span class="keyword">for</span> i <span class="keyword">in</span> path]
            sum+=int(<span class="string">''</span>.join(path))
        <span class="keyword">return</span> sum</code></pre>
<p>以上做法取巧使用了Python的字符串转数字功能，那如果不能这样做呢？</p>
<p>看官方题解的DFS:</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root: TreeNode, prevTotal: int)</span> -&gt; int:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> root:
                <span class="keyword">return</span> <span class="number">0</span>
            total = prevTotal * <span class="number">10</span> + root.val
            <span class="comment">#如果是叶子结点</span>
            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:
                <span class="keyword">return</span> total
            <span class="keyword">else</span>:
                <span class="keyword">return</span> dfs(root.left, total) + dfs(root.right, total)

        <span class="keyword">return</span> dfs(root, <span class="number">0</span>)</code></pre>
<p>时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。</p>
<p>空间复杂度：O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)。</p>
<p>我根据上面的官方DFS代码，写出了下面的BFS代码：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="number">0</span>

        res=<span class="number">0</span>
        node_queue=[root]<span class="comment">#存储结点</span>
        pre_queue=[<span class="number">0</span>]<span class="comment">#存储从根节点到当前结点的父节点的数字和</span>
        <span class="keyword">while</span> node_queue:
            r=node_queue.pop(<span class="number">0</span>)
            pre=pre_queue.pop(<span class="number">0</span>)

            <span class="comment">#计算根结点到当前结点的数字和</span>
            total=pre*<span class="number">10</span>+r.val
            <span class="comment">#如果是叶子结点</span>
            <span class="keyword">if</span> <span class="keyword">not</span> (r.left <span class="keyword">or</span> r.right):
                res+=total
            <span class="comment">#如果不是叶子结点，有左孩子</span>
            <span class="keyword">if</span> r.left:
                node_queue.append(r.left)
                pre_queue.append(total)
            <span class="comment">#如果不是叶子结点，有右孩子</span>
            <span class="keyword">if</span> r.right:
                node_queue.append(r.right)
                pre_queue.append(total)
        <span class="keyword">return</span> res</code></pre>
<p>我的<code>pre_queue</code> 存储的是从根结点到当前结点的父节点的对应数字和，看了下官方的BFS解法，<code>pre_queue</code>存的是从根结点到当前结点的对应数字和.</p>
<p>于是我改了一下上面的BFS代码，让pre_queue存从根结点到当前结点的对应数字和：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="number">0</span>

        res=<span class="number">0</span>
        node_queue=[root]<span class="comment">#存储结点</span>
        pre_queue=[root.val]<span class="comment">#存储从根节点到当前结点的数字和</span>
        <span class="keyword">while</span> node_queue:
            r=node_queue.pop(<span class="number">0</span>)
            total=pre_queue.pop(<span class="number">0</span>)

            <span class="comment">#如果是叶子结点</span>
            <span class="keyword">if</span> <span class="keyword">not</span> (r.left <span class="keyword">or</span> r.right):
                res+=total
            <span class="comment">#如果不是叶子结点，有左孩子</span>
            <span class="keyword">if</span> r.left:
                node_queue.append(r.left)
                pre_queue.append(total*<span class="number">10</span>+r.left.val)
            <span class="comment">#如果不是叶子结点，有右孩子</span>
            <span class="keyword">if</span> r.right:
                node_queue.append(r.right)
                pre_queue.append(total*<span class="number">10</span>+r.right.val)
        <span class="keyword">return</span> res</code></pre>
<p>哪种方法都可以的~~</p>
<p>时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。</p>
<p>空间复杂度：O(n)，其中 nnn 是二叉树的节点个数。空间复杂度主要取决于队列，每个队列中的元素个数不会超过 n。</p>
<h2 id="7-5"><a href="#7-5" class="headerlink" title="7-5"></a>7-5</h2><p>更复杂的递归：<br><img src="./173.png" alt="Alt text"></p>
<p><img src="./174.png" alt="Alt text"></p>
<p><img src="./175.png" alt="Alt text"></p>
<p>改写成Python版本：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, targetSum: int)</span> -&gt; int:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="number">0</span>

        <span class="comment">#该函数寻找以node为根结点，且包含node的路径，路径和为num</span>
        <span class="function"><span class="keyword">def</span> <span class="title">findPath</span><span class="params">(node,num)</span>:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> node:
                <span class="keyword">return</span> <span class="number">0</span>

            res=<span class="number">0</span>
            <span class="keyword">if</span> node.val==num:
                res+=<span class="number">1</span>

            res+=findPath(node.left,num-node.val)
            res+=findPath(node.right,num-node.val)

            <span class="keyword">return</span> res


        <span class="comment">#寻找以root为根结点，且包含root的路径，路径和为targetSum</span>
        res=findPath(root,targetSum)
        <span class="comment">#寻找不包含root的路径，路径和为targetSum</span>
        res+=self.pathSum(root.left,targetSum)
        res+=self.pathSum(root.right,targetSum)
        <span class="keyword">return</span> res</code></pre>
<h2 id="7-6"><a href="#7-6" class="headerlink" title="7-6"></a>7-6</h2><p>二分搜索树</p>
<p><img src="./176.png" alt="Alt text"></p>
<p><img src="./177.png" alt="Alt text"></p>
<p>所有节点的值都是唯一的。</p>
<p> p, q 为不同节点且均存在于给定的二叉搜索树中。</p>
<p>利用了二分搜索树的性质:</p>
<pre><code>如果root.val都比p,q大，代表要往左边走
如果root.val都比p,q小，代表要往右边走
如果一个在左一个在右，代表得到结果</code></pre><p><img src="./178.png" alt="Alt text"></p>
<p>我改写成Python版本：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span>
        <span class="comment">#p和q都在左子树中</span>
        <span class="keyword">if</span> p.val&lt;root.val <span class="keyword">and</span> q.val&lt;root.val:
            <span class="keyword">return</span> self.lowestCommonAncestor(root.left,p,q)
        <span class="comment">#p和q都在右子树中</span>
        <span class="keyword">if</span> p.val&gt;root.val <span class="keyword">and</span> q.val&gt;root.val:
            <span class="keyword">return</span> self.lowestCommonAncestor(root.right,p,q)
        <span class="comment">#p和q有可能一左一右，或者其一就是root，这些情况下，它们的公共祖先就是root</span>
        <span class="keyword">return</span> root</code></pre>
<p>课后习题<br><img src="./183.png" alt="Alt text"><br>和上题相比，这里的树是普通的二叉树了。</p>
<p><img src="./184.png" alt="Alt text"></p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: <span class="keyword">return</span> root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="keyword">return</span> <span class="comment"># 1.</span>
        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right <span class="comment"># 3.</span>
        <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left <span class="comment"># 4.</span>
        <span class="keyword">return</span> root <span class="comment"># 2. if left and right</span></code></pre>
<p>没太懂。。。</p>
<p><img src="./179.png" alt="Alt text"></p>
<p>中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p>
<p>有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</p>
<p>很容易懂的一个方法：判断中序遍历结果是否有序(从小到大，不重复，leetcode要求二叉搜索树中不含有重复元素)</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span>
        arr=[]
        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> root:
                <span class="keyword">return</span> 
            dfs(root.left)
            arr.append(root.val)
            dfs(root.right)
        dfs(root)

        n=len(arr)
        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):
            <span class="keyword">if</span> arr[i]&lt;=arr[i<span class="number">-1</span>]:
                <span class="keyword">return</span> <span class="literal">False</span>
        <span class="keyword">return</span> <span class="literal">True</span></code></pre>
<p>上面的方法是先把中序遍历的结果存起来，再进行判断，也可以同时进行：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span>
        cur_max = -float(<span class="string">"INF"</span>)
        <span class="function"><span class="keyword">def</span> <span class="title">_isValidBST</span><span class="params">(root)</span>:</span>
            <span class="keyword">nonlocal</span> cur_max 
            <span class="comment"># 规律: BST的中序遍历节点数值是从小到大. </span>
            <span class="keyword">if</span> <span class="keyword">not</span> root: 
                <span class="keyword">return</span> <span class="literal">True</span>

            is_left_valid = _isValidBST(root.left)
            <span class="keyword">if</span> cur_max &lt; root.val: 
                cur_max = root.val
            <span class="keyword">else</span>: 
                <span class="keyword">return</span> <span class="literal">False</span>
            is_right_valid = _isValidBST(root.right)

            <span class="keyword">return</span> is_left_valid <span class="keyword">and</span> is_right_valid
        <span class="keyword">return</span> _isValidBST(root)</code></pre>
<p>也可以写成一个方法：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    cur_max = -float(<span class="string">"INF"</span>)
    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span>
        <span class="comment"># 规律: BST的中序遍历节点数值是从小到大.             </span>
        <span class="keyword">if</span> <span class="keyword">not</span> root: 
            <span class="keyword">return</span> <span class="literal">True</span>

        is_left_valid = self.isValidBST(root.left)
        <span class="keyword">if</span> self.cur_max &lt; root.val: 
            self.cur_max = root.val
        <span class="keyword">else</span>: 
            <span class="keyword">return</span> <span class="literal">False</span>
        is_right_valid = self.isValidBST(root.right)

        <span class="keyword">return</span> is_left_valid <span class="keyword">and</span> is_right_valid</code></pre>
<p>陷阱：不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了。</p>
<p>也可以写成非递归形式的中序遍历：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span>
        stack = []
        p = root
        pre = <span class="literal">None</span>
        <span class="keyword">while</span> p <span class="keyword">or</span> stack:
            <span class="keyword">while</span> p:
                stack.append(p)
                p = p.left
            p = stack.pop()
            <span class="keyword">if</span> pre <span class="keyword">and</span> p.val &lt;= pre.val:
                <span class="keyword">return</span> <span class="literal">False</span>
            pre = p
            p = p.right
        <span class="keyword">return</span> <span class="literal">True</span></code></pre>
<p><img src="./180.png" alt="Alt text"></p>
<p>大佬的代码，能看懂：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, root: TreeNode, key: int)</span> -&gt; TreeNode:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root  <span class="comment">#第一种情况：没找到删除的节点，遍历到空节点直接返回了</span>
        <span class="keyword">if</span> root.val == key:  
            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:  <span class="comment">#第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span>
                <span class="keyword">del</span> root
                <span class="keyword">return</span> <span class="literal">None</span>
            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> root.right:  <span class="comment">#第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span>
                tmp = root
                root = root.right
                <span class="keyword">del</span> tmp
                <span class="keyword">return</span> root
            <span class="keyword">if</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:  <span class="comment">#第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span>
                tmp = root
                root = root.left
                <span class="keyword">del</span> tmp
                <span class="keyword">return</span> root
            <span class="keyword">else</span>:  <span class="comment">#第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span>
                v = root.right
                <span class="keyword">while</span> v.left:
                    v = v.left
                v.left = root.left
                tmp = root
                root = root.right
                <span class="keyword">del</span> tmp
                <span class="keyword">return</span> root
        <span class="keyword">if</span> root.val &gt; key: root.left = self.deleteNode(root.left,key)  <span class="comment">#左递归</span>
        <span class="keyword">if</span> root.val &lt; key: root.right = self.deleteNode(root.right,key)  <span class="comment">#右递归</span>
        <span class="keyword">return</span> root</code></pre>
<p><img src="./181.png" alt="Alt text"></p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span>
        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(left,right)</span>:</span>
            <span class="keyword">if</span> left&gt;right:
                <span class="keyword">return</span> 
            mid=(right+left)//<span class="number">2</span>
            root=TreeNode(nums[mid])
            root.left=bfs(left,mid<span class="number">-1</span>)
            root.right=bfs(mid+<span class="number">1</span>,right)
            <span class="keyword">return</span> root
        <span class="keyword">return</span> bfs(<span class="number">0</span>,len(nums)<span class="number">-1</span>)</code></pre>
<p><img src="./182.png" alt="Alt text"><br>我直接：</p>
<pre><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="comment">#         self.val = val</span>
<span class="comment">#         self.left = left</span>
<span class="comment">#         self.right = right</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: Optional[TreeNode], k: int)</span> -&gt; int:</span>
        res=[]
        <span class="function"><span class="keyword">def</span> <span class="title">inorder_bfs</span><span class="params">(root)</span>:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> root:
                <span class="keyword">return</span> 
            inorder_bfs(root.left)
            res.append(root.val)
            inorder_bfs(root.right)
        inorder_bfs(root)
        <span class="keyword">return</span> res[k<span class="number">-1</span>]</code></pre>
<p>官方也是，同时也给出了迭代的方法：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span>
        <span class="string">"""</span>
<span class="string">        :type root: TreeNode</span>
<span class="string">        :type k: int</span>
<span class="string">        :rtype: int</span>
<span class="string">        """</span>
        stack = []

        <span class="keyword">while</span> <span class="literal">True</span>:
            <span class="keyword">while</span> root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            k -= <span class="number">1</span>
            <span class="keyword">if</span> <span class="keyword">not</span> k:
                <span class="keyword">return</span> root.val
            root = root.right</code></pre>
<h1 id="第八章：递归与回溯"><a href="#第八章：递归与回溯" class="headerlink" title="第八章：递归与回溯"></a>第八章：递归与回溯</h1><h2 id="8-1"><a href="#8-1" class="headerlink" title="8-1"></a>8-1</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="./185.png" alt="Alt text"></p>
<p><img src="./186.png" alt="Alt text"></p>
<p>这是一个树形问题。</p>
<p><img src="./187.png" alt="Alt text"></p>
<p>官方题解：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> digits:
            <span class="keyword">return</span> list()

        phoneMap = {
            <span class="string">"2"</span>: <span class="string">"abc"</span>,
            <span class="string">"3"</span>: <span class="string">"def"</span>,
            <span class="string">"4"</span>: <span class="string">"ghi"</span>,
            <span class="string">"5"</span>: <span class="string">"jkl"</span>,
            <span class="string">"6"</span>: <span class="string">"mno"</span>,
            <span class="string">"7"</span>: <span class="string">"pqrs"</span>,
            <span class="string">"8"</span>: <span class="string">"tuv"</span>,
            <span class="string">"9"</span>: <span class="string">"wxyz"</span>,
        }

        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(index: int)</span>:</span>
            <span class="comment">#找到一个结果</span>
            <span class="keyword">if</span> index == len(digits):
                combinations.append(<span class="string">""</span>.join(combination))
                <span class="keyword">return</span>

            digit = digits[index]
            <span class="keyword">for</span> letter <span class="keyword">in</span> phoneMap[digit]:
                <span class="comment">#选择</span>
                combination.append(letter)
                <span class="comment">#回溯</span>
                backtrack(index + <span class="number">1</span>)
                <span class="comment">#撤销选择</span>
                combination.pop()

        combination = list()
        combinations = list()
        backtrack(<span class="number">0</span>)
        <span class="keyword">return</span> combinations</code></pre>
<p>or</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> digits:
            <span class="keyword">return</span> list()

        phoneMap = {
            <span class="string">"2"</span>: <span class="string">"abc"</span>,
            <span class="string">"3"</span>: <span class="string">"def"</span>,
            <span class="string">"4"</span>: <span class="string">"ghi"</span>,
            <span class="string">"5"</span>: <span class="string">"jkl"</span>,
            <span class="string">"6"</span>: <span class="string">"mno"</span>,
            <span class="string">"7"</span>: <span class="string">"pqrs"</span>,
            <span class="string">"8"</span>: <span class="string">"tuv"</span>,
            <span class="string">"9"</span>: <span class="string">"wxyz"</span>,
        }

        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(digits,index: int)</span>:</span>
            <span class="comment">#找到一个结果</span>
            <span class="keyword">if</span> index == len(digits):
                combinations.append(<span class="string">""</span>.join(combination))
                <span class="keyword">return</span>

            digit = digits[index]
            <span class="keyword">for</span> letter <span class="keyword">in</span> phoneMap[digit]:
                <span class="comment">#选择</span>
                combination.append(letter)
                <span class="comment">#回溯</span>
                backtrack(digits,index + <span class="number">1</span>)
                <span class="comment">#撤销选择</span>
                combination.pop()

        combination = list()
        combinations = list()
        backtrack(digits,<span class="number">0</span>)
        <span class="keyword">return</span> combinations</code></pre>
<p>这里回溯函数传不传digits都可以~</p>
<p>评论区更容易理解的解法：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span>
        <span class="comment">#数字对应的英文字母列表</span>
        word_list = [<span class="string">"0"</span>, <span class="string">"0"</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>]
        <span class="comment">#如果是空字符串直接返回空列表</span>
        <span class="keyword">if</span> digits == <span class="string">""</span>:
            <span class="keyword">return</span> []
        <span class="comment">#保存结果列表</span>
        result = []
        <span class="comment">#输入的digits的长度，作为回溯函数返回的判断条件</span>
        length = len(digits)
        <span class="comment">#回溯函数（path当前路径，默认为""）</span>
        <span class="function"><span class="keyword">def</span> <span class="title">back_track</span><span class="params">(digits, index, path)</span>:</span>
            <span class="comment">#如果目前path的长度和digits的长度相等，说明已经遍历完一趟，返回结果列表</span>
            <span class="keyword">if</span> len(path) == length:
                <span class="comment">#加入result列表</span>
                result.append(path)
                <span class="comment">#返回</span>
                <span class="keyword">return</span>
            <span class="comment">#遍历当前索引的数字对应的英文列表</span>
            <span class="keyword">for</span> word <span class="keyword">in</span> word_list[int(digits[index])]:
                <span class="comment">#路径加上当前字母</span>
                path = path + word
                <span class="comment">#递归下一个数字对应的英文列表</span>
                back_track(digits, index + <span class="number">1</span>, path)
                <span class="comment">#撤销当前字母</span>
                path = path[:<span class="number">-1</span>]
        back_track(digits, <span class="number">0</span>, <span class="string">""</span>)
        <span class="keyword">return</span> result</code></pre>
<p>不传path也可以：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span>
        <span class="comment">#数字对应的英文字母列表</span>
        word_list = [<span class="string">"0"</span>, <span class="string">"0"</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>]
        <span class="comment">#如果是空字符串直接返回空列表</span>
        <span class="keyword">if</span> digits == <span class="string">""</span>:
            <span class="keyword">return</span> []
        <span class="comment">#保存结果列表</span>
        result = []
        <span class="comment">#输入的digits的长度，作为回溯函数返回的判断条件</span>
        length = len(digits)
        <span class="comment">#回溯函数（path当前路径，默认为""）</span>
        <span class="function"><span class="keyword">def</span> <span class="title">back_track</span><span class="params">(digits, index)</span>:</span>
            <span class="keyword">nonlocal</span> path
            <span class="comment">#如果目前path的长度和digits的长度相等，说明已经遍历完一趟，返回结果列表</span>
            <span class="keyword">if</span> index == length:
                <span class="comment">#加入result列表</span>
                result.append(path)
                <span class="comment">#返回</span>
                <span class="keyword">return</span>
            <span class="comment">#遍历当前索引的数字对应的英文列表</span>
            <span class="keyword">for</span> word <span class="keyword">in</span> word_list[int(digits[index])]:
                <span class="comment">#路径加上当前字母</span>
                path = path + word
                <span class="comment">#递归下一个数字对应的英文列表</span>
                back_track(digits, index + <span class="number">1</span>)
                <span class="comment">#撤销当前字母</span>
                path = path[:<span class="number">-1</span>]
        path=<span class="string">""</span>
        back_track(digits, <span class="number">0</span>)
        <span class="keyword">return</span> result</code></pre>
<p>课后习题：<br><img src="./188.png" alt="Alt text"></p>
<p><img src="./190.png" alt="Alt text"></p>
<p>有点难</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span>
        SEG_COUNT = <span class="number">4</span>
        ans = list()
        segments = [<span class="number">0</span>] * SEG_COUNT<span class="comment">#[0,0,0,0]</span>

        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(segId: int, segStart: int)</span>:</span>
            <span class="comment"># 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span>
            <span class="keyword">if</span> segId == SEG_COUNT:
                <span class="keyword">if</span> segStart == len(s):
                    ipAddr = <span class="string">"."</span>.join(str(seg) <span class="keyword">for</span> seg <span class="keyword">in</span> segments)
                    ans.append(ipAddr)
                <span class="keyword">return</span>

            <span class="comment"># 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span>
            <span class="keyword">if</span> segStart == len(s):
                <span class="keyword">return</span>

            <span class="comment"># 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span>
            <span class="keyword">if</span> s[segStart] == <span class="string">"0"</span>:
                segments[segId] = <span class="number">0</span>
                dfs(segId + <span class="number">1</span>, segStart + <span class="number">1</span>)

            <span class="comment"># 一般情况，枚举每一种可能性并递归</span>
            addr = <span class="number">0</span>
            <span class="keyword">for</span> segEnd <span class="keyword">in</span> range(segStart, len(s)):
                addr = addr * <span class="number">10</span> + (ord(s[segEnd]) - ord(<span class="string">"0"</span>))
                <span class="keyword">if</span> <span class="number">0</span> &lt; addr &lt;= <span class="number">255</span>:
                    segments[segId] = addr
                    dfs(segId + <span class="number">1</span>, segEnd + <span class="number">1</span>)
                <span class="keyword">else</span>:
                    <span class="keyword">break</span>


        dfs(<span class="number">0</span>, <span class="number">0</span>)
        <span class="keyword">return</span> ans</code></pre>
<p>来个更详细的注释：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span>
        SEG_COUNT = <span class="number">4</span>
        ans = list()
        segments = [<span class="number">0</span>] * SEG_COUNT<span class="comment">#[0,0,0,0]</span>

        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(segId: int, segStart: int)</span>:</span>
            <span class="comment"># 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span>
            <span class="keyword">if</span> segId == SEG_COUNT:
                <span class="keyword">if</span> segStart == len(s):
                    ipAddr = <span class="string">"."</span>.join(str(seg) <span class="keyword">for</span> seg <span class="keyword">in</span> segments)
                    ans.append(ipAddr)
                <span class="keyword">return</span>

            <span class="comment"># 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span>
            <span class="keyword">if</span> segStart == len(s):
                <span class="keyword">return</span>
            <span class="comment"># 如果还没有遍历完字符串就已经找到 4 段 IP 地址，那么提前回溯</span>
            <span class="keyword">if</span> segId==SEG_COUNT:
                <span class="keyword">return</span>

            <span class="comment"># 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span>
            <span class="keyword">if</span> s[segStart] == <span class="string">"0"</span>:
                segments[segId] = <span class="number">0</span>
                dfs(segId + <span class="number">1</span>, segStart + <span class="number">1</span>)

            <span class="comment"># 一般情况，枚举每一种可能性并递归</span>
            addr = <span class="number">0</span>
            <span class="keyword">for</span> segEnd <span class="keyword">in</span> range(segStart, len(s)):
                <span class="comment">#addr = addr * 10 + (ord(s[segEnd]) - ord("0"))</span>
                addr=addr*<span class="number">10</span>+int(s[segEnd])<span class="comment">#更易懂~</span>
                <span class="keyword">if</span> <span class="number">0</span> &lt; addr &lt;= <span class="number">255</span>:<span class="comment">#等于0的情况在上面已经单独处理了</span>
                    <span class="comment">#加入当前数字了</span>
                    segments[segId] = addr
                    <span class="comment">#回溯吧</span>
                    dfs(segId + <span class="number">1</span>, segEnd + <span class="number">1</span>)
                    <span class="comment">#撤销的过程：对于之前的问题，都是直接撤销，"撤销"等价于出栈或pop字符串最后一位，</span>
                    <span class="comment">#但是这里是切割问题，"撤销"等价于右移切割点，也就是for做的,更具体的，addr会变回回溯前的值。</span>
                <span class="keyword">else</span>:
                    <span class="keyword">break</span>


        dfs(<span class="number">0</span>, <span class="number">0</span>)
        <span class="keyword">return</span> ans</code></pre>
<p>我想改成用list，但死活不通过<code>&quot;010010&quot;</code>：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span>
        SEG_COUNT = <span class="number">4</span>
        ans = list()
        segments = list()

        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(segStart: int)</span>:</span>
            <span class="keyword">nonlocal</span> segments
            print(segStart,segments)
            <span class="comment"># 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span>
            <span class="keyword">if</span> len(segments) == SEG_COUNT <span class="keyword">and</span> segStart == len(s):
                ipAddr = <span class="string">"."</span>.join(str(seg) <span class="keyword">for</span> seg <span class="keyword">in</span> segments)
                ans.append(ipAddr)
                <span class="keyword">return</span>

            <span class="comment"># 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span>
            <span class="keyword">if</span> segStart == len(s):
                print(<span class="string">'a:'</span>,segStart)
                <span class="keyword">return</span>
            <span class="comment"># 如果还没有遍历完字符串就已经找到 4 段 IP 地址，那么提前回溯</span>
            <span class="keyword">if</span> len(segments)==SEG_COUNT:
                print(<span class="string">'b:'</span>,segStart)
                <span class="keyword">return</span>

            <span class="comment"># 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span>
            <span class="keyword">if</span> s[segStart] == <span class="string">"0"</span>:
                <span class="comment">#print('00000')</span>
                segments.append(<span class="number">0</span>)
                dfs(segStart + <span class="number">1</span>)

            <span class="comment"># 一般情况，枚举每一种可能性并递归</span>
            addr = <span class="number">0</span>
            <span class="keyword">for</span> segEnd <span class="keyword">in</span> range(segStart, len(s)):
                <span class="comment">#addr = addr * 10 + (ord(s[segEnd]) - ord("0"))</span>
                addr=addr*<span class="number">10</span>+int(s[segEnd])<span class="comment">#更易懂~</span>
                <span class="keyword">if</span> <span class="number">0</span> &lt; addr &lt;= <span class="number">255</span>:<span class="comment">#等于0的情况在上面已经单独处理了</span>
                    <span class="comment">#加入当前数字</span>
                    segments.append(addr)
                    <span class="comment">#回溯</span>
                    dfs(segEnd + <span class="number">1</span>)
                    <span class="comment">#撤销加入当前数字</span>
                    segments.pop()
                <span class="keyword">else</span>:
                    <span class="keyword">break</span>


        dfs(<span class="number">0</span>)
        <span class="keyword">return</span> ans</code></pre>
<p>可能是for那里的addr有个累加的过程，单纯的pop会导致之前累加的结果丢失？？？</p>
<p><img src="./189.png" alt="Alt text"></p>
<p><img src="./191.png" alt="Alt text"></p>
<p>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s: str)</span> -&gt; List[List[str]]:</span>
        res = []
        path = []  <span class="comment">#放已经回文的子串</span>
        <span class="comment"># 双指针法判断是否是回文串</span>
        <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(s)</span>:</span>
            n = len(s)
            i, j = <span class="number">0</span>, n - <span class="number">1</span>
            <span class="keyword">while</span> i &lt; j: 
                <span class="keyword">if</span> s[i] != s[j]:<span class="keyword">return</span> <span class="literal">False</span>
                i += <span class="number">1</span>
                j -= <span class="number">1</span>
            <span class="keyword">return</span> <span class="literal">True</span>

        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(s, startIndex)</span>:</span>
            <span class="keyword">if</span> startIndex == len(s): <span class="comment"># 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span>
                res.append(path[:])<span class="comment">#拷贝一份当前副本，因为之后path还会变的</span>
                <span class="keyword">return</span>  
            <span class="keyword">for</span> i <span class="keyword">in</span> range(startIndex, len(s)):
                p = s[startIndex:i+<span class="number">1</span>] <span class="comment"># 获取[startIndex,i+1]在s中的子串</span>
                <span class="keyword">if</span> isPalindrome(p): <span class="comment"># 是回文子串</span>
                    path.append(p)
                <span class="keyword">else</span>: <span class="keyword">continue</span> <span class="comment">#不是回文，跳过</span>
                backtrack(s, i + <span class="number">1</span>)
                path.pop() <span class="comment">#回溯过程，弹出本次已经填在path的子串</span>
        backtrack(s, <span class="number">0</span>)
        <span class="keyword">return</span> res</code></pre>
<p>这种题还是有些难的，目前自己很难写出来，但代码基本都是套模板，之后还要多品味~</p>
